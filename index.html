<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <title>Sandbox Delta 0.7.1c</title>
  <!-- Webapp metadata -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Sandbox Delta">
  <meta name="application-name" content="Sandbox Delta">
  <link rel="icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJhSURBVFhH7ZY9aBRBGIbfvdwld7lL7hJz+YnJJcYYY0gMwUQsRFELCwutRBELGwutxFZtRBDBwkIQRBBE0MbGRrAQRLAQRBAsgoUWFhYWFhYWYp7vnNm9XdnLzwXkwBcedmdnZ9/vne+b2bvCcRxsZRXWvzet/G6HyWRSxONxEYvFRDQaFeFwWIRCIeHz+YTP6xVer1d4PB7hdruF2+USLpdLOJ1O4XA4hN1uFzabTVitVmGxWITZbBYmk0mYTCZhNBqFwWAQer1e6HQ6odVqhUajEWq1WqhUKqFUKoVCoRByuVzI5XIhk8mETCYTUqlUSCQSIRaLBUVRQBAEQZIkQZRlQRRFQRAEQa/XC1qtVmi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFlKpVMhkMiGXy4VCodh8AHVdF4VCIWQymZBKpUIikQixWCykUqmQyWRCLpcLhUIh5HK5kMlkQiqVColEIsRisZBKpUIqlQqZTCbkcrlQKBRCLpcLmUwmpFKpkEgkQiwWC6lUKmQymZDL5UIhXwXweDwbD8AZcLvdwuVyCYfDIex2u7DZbMJqtQqLxSLMZrMwmUzCaDQKg8Eg9Hq90Ol0QqvVCo1GI9RqtVCpVEKpVAqFQiHkcrmQyWRCKpUKiUQixGKxoChKEIIgCJIkCaIsCqIoCgaDQWi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFhRFEQRBECRJEkRZFERRFPR6vdBqtUKj0Qi1Wi1UKpVQKpVCoVAIuVwuZDKZkEqlQiKRCLFYLCiKIgiCIEiSJIiyKIiiKPwXAYQQfwBCxA1TnWK6GAAAAABJRU5ErkJggg==">
  <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJhSURBVFhH7ZY9aBRBGIbfvdwld7lL7hJz+YnJJcYYY0gMwUQsRFELCwutRBELGwutxFZtRBDBwkIQRBBE0MbGRrAQRLAQRBAsgoUWFhYWFhYWYp7vnNm9XdnLzwXkwBcedmdnZ9/vne+b2bvCcRxsZRXWvzet/G6HyWRSxONxEYvFRDQaFeFwWIRCIeHz+YTP6xVer1d4PB7hdruF2+USLpdLOJ1O4XA4hN1uFzabTVitVmGxWITZbBYmk0mYTCZhNBqFwWAQer1e6HQ6odVqhUajEWq1WqhUKqFUKoVCoRByuVzI5XIhk8mETCYTUqlUSCQSIRaLBUVRQBAEQZIkQZRlQRRFQRAEQa/XC1qtVmi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFlKpVMhkMiGXy4VCodh8AHVdF4VCIWQymZBKpUIikQixWCykUqmQyWRCLpcLhUIh5HK5kMlkQiqVColEIsRisZBKpUIqlQqZTCbkcrlQKBRCLpcLmUwmpFKpkEgkQiwWC6lUKmQymZDL5UIhXwXweDwbD8AZcLvdwuVyCYfDIex2u7DZbMJqtQqLxSLMZrMwmUzCaDQKg8Eg9Hq90Ol0QqvVCo1GI9RqtVCpVEKpVAqFQiHkcrmQyWRCKpUKiUQixGKxoChKEIIgCJIkCaIsCqIoCgaDQWi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFhRFEQRBECRJEkRZFERRFPR6vdBqtUKj0Qi1Wi1UKpVQKpVCoVAIuVwuZDKZkEqlQiKRCLFYLCiKIgiCIEiSJIiyKIiiKPwXAYQQfwBCxA1TnWK6GAAAAABJRU5ErkJggg==">

  <style>
    /* Basic layout: center the page content, side panel on the right */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #game-container {
      overflow: auto;
    }

    .playing #game-container {
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
    }
    /* The main container: grid + side panel horizontally */
    #mainContainer {
      display: flex;
      flex-direction: row;
      justify-content: center;
      margin: 0 auto;
      padding: 10px;
      box-sizing: border-box;
      width: 100%;
      height: 100vh;
      gap: 20px;
    }
    /* The game grid; its size will be determined by GRID_SIZE */
    #grid {
      flex: 1;
      max-width: calc(100vh - 20px);
      aspect-ratio: 1;
      background-color: #555;
      user-select: none;
      cursor: crosshair;
      display: grid;
      grid-template-columns: repeat(50, 1fr);
      grid-template-rows: repeat(50, 1fr);
      position: relative;
    }
    .cell {
      width: 100%;
      height: 100%;
      background-color: #000;
      box-sizing: border-box;
    }
    /* Hover overlay for stroke highlighting */
    #hoverOverlay {
      position: absolute;
      pointer-events: none;
      border: 2px dashed yellow;
      background-color: rgba(255, 255, 0, 0.2);
      display: none;
      box-sizing: border-box;
    }
    /* Side panel: now wider */
    #sidePanel {
      display: flex;
      flex-direction: column;
      width: 400px;
      min-width: 400px;
      height: calc(100vh - 20px);
      border: 2px solid #444;
      box-sizing: border-box;
    }
    /* Container for the two scrollable areas side-by-side */
    #sideContent {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    /* Element list scroll area */
    #elementScroll {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Custom scrollbar for element list */
    #elementScroll::-webkit-scrollbar {
      width: 8px;
    }
    #elementScroll::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Search box for elements */
    #toolSearchContainer {
      margin-bottom: 10px;
      width: 100%;
    }
    #toolSearch {
      width: 100%;
      background-color: #333;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      padding: 5px;
      box-sizing: border-box;
      font-size: 14px;
    }
    #toolSearch::placeholder {
      color: #bbb;
    }
    /* Toolbar (element icons) */
    #toolbar {
      display: flex;
      flex-wrap: wrap;
    }
    .tool {
      position: relative;
      width: 60px;
      height: 40px;
      margin: 5px;
      border: 2px solid #fff;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      background-color: #333;
    }
    .tool span {
      position: absolute;
      font-size: 10px;
      font-weight: bold;
      color: #000;
      bottom: 2px;
      right: 2px;
      pointer-events: none;
    }
    .tool.selected {
      border: 2px solid #ffd700;
    }
    /* Category menu (tabs) placed to the right in its own scroll area */
    #categoryMenu {
      width: 150px;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    #categoryMenu button {
      width: 100%;
      margin-bottom: 5px;
      padding: 10px;
      text-align: center;
      background-color: #333;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      cursor: pointer;
    }
    #categoryMenu button.selectedCat {
      border: 2px solid #ffd700;
    }
    /* Custom scrollbar for category menu */
    #categoryMenu::-webkit-scrollbar {
      width: 8px;
    }
    #categoryMenu::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Element color classes */
    .sand         { background-color: #f4a460; }
    .wall         { background-color: #666666; }
    .water        { background-color: #1e90ff; }
    .lava         { background-color: #ff4500; }
    .stone        { background-color: #808080; }
    .water-vapor  { background-color: #e0e0e0; }
    .cloud        { background-color: #ffffff; }
    .helium       { background-color: #e6f7ff; }
    .eraser       { background-color: pink; border: 2px solid #fff; }
    .copper       { background-color: #b87333; }
    .steel        { background-color: #aaaaaa; }
    .ice          { background-color: #cceeff; }
    .wood         { background-color: #3B220E; }
    .fire         { background-color: #ffcc00; }
    .smoke        { background-color: #666666; }
    .burning-wood { background-color: #5a3310; }
    .ash          { background-color: #444444; }
    .glass        { background-color: #c2e9fb; }
    .bomb         { background-color: #006400; border: 2px solid #000; }
    .dirt         { background-color: #7B5E42; }
    .wet-dirt     { background-color: #4d2e12; }
    .wheat-seeds  { background-color: #bca136; }
    .wheat        { background-color: #c2b280; }
    .flour        { background-color: #f5f5dc; }
    .dough        { background-color: #d2b48c; }
    .bread        { background-color: #f4c986; }
    .burning-organic { background-color: #6a3400; }
    .root         { background-color: #4a3a2f; }
    .spark        { background-color: #ffdd00; border: 1px solid #ffbb00; }
    .charged-copper { background-color: #ff8c00; }
    .charged-down-copper { background-color: #cc6600; }
    .oak-seeds       { background-color: #32CD32; }
    .oak-leaves      { background-color: #228B22; }
    .oak-baby-leaves { background-color: #66bb6a; }
    .dead-oak        { background-color: #777777; }
    .wet-sand        { background-color: #d2a679; }
    .grass           { background-color: #00aa00; }
    .dead-plant      { background-color: #555555; }
    .burning-leaves  { background-color: #a0522d; }
    .burning-root    { background-color: #ff4500; }
    .dead-root       { background-color: #555555; }
    .gas             { background-color: rgba(200,200,200,0.2); }
    .burning-gas     { background-color: #ff6666; opacity: 0.75; }
    .acid            { background-color: #90EE90; }
    .acid-steam      { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud      { background-color: #98FB98; }
    .slime           { background-color: #006400; }
    /* New element classes */
    .carbon-dioxide  { background-color: rgba(128,128,128,0.2); }
    .oxygen          { background-color: rgba(200,230,255,0.2); }
    .bird            { background-color: #B8860B; }
    .meat            { background-color: #FF6B6B; }
    .cooked-meat     { background-color: #8B4513; }
    .cobblestone     { background-color: #808080; }
    .oil             { background-color: #2F4F4F; }
    /* cooler & heater */
    .cooler { background-color: #3399ff; }
    .heater { background-color: #ff3333; }
    /* Heat Separator, Input, Output, Not Gate, And Gate, Blocker */
    .heat-separator          { background-color: #ffef96; }
    .charged-heat-separator  { background-color: #ffe033; }
    .charged-down-heat-separator { background-color: #ffd700; }
    .input            { background-color: #646464; }
    .charged-input    { background-color: #ffff77; }
    .output           { background-color: #3636ff; }
    .charged-output   { background-color: #8888ff; }
    .not-gate         { background-color: #a15050; }
    .and-gate         { background-color: #405050; }
    .blocker          { background-color: #856fa8; }
    .charged-blocker  { background-color: #9b50a3; }
    /* Cloner */
    .cloner { background-color: #cc00cc; }
    /* New elements: Coal & Coal Lump */
    .coal         { background-color: #202020; }
    .coal-lump    { background-color: #303030; }
    .burning-coal         { background-color: #520f0f; }
    .burning-coal-lump    { background-color: #812626; }
    /* New element: Thermite â€“ tool styling */
    .thermite     { background-color: #AA4444; }
    .bomb         { background-color: #ff0000; }
    .big-bomb     { background-color: #ff3333; }
    .water-bomb   { background-color: #3366ff; }
    .fire-bomb    { background-color: #ff6600; }
    .cryo-bomb    { background-color: #00ccff; }
    .nuke-bomb    { background-color: #33cc33; } 
    .helium       { background-color: #e6f7ff; }
    .bouncy-ball  { background-color: #ff5599; } 
    .birch-seeds   { background-color: #8cff9b; }
    

    /* HUD area for temp, element info, and FPS */
    #hud {
      background: rgba(0,0,0,0.7);
      padding: 5px;
      border: 1px solid #444;
      font-size: 14px;
      line-height: 1.3;
      box-sizing: border-box;
    }
    #hud div { margin: 5px 0; }
    /* Bottom controls */
    #bottomControls {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }
    #speedContainer {
      margin-bottom: 10px;
      text-align: center;
      color: #fff;
    }
    #speed {
      -webkit-appearance: none;
      width: 120px;
      background: #444;
      outline: none;
      border-radius: 5px;
      border: 1px solid #888;
      height: 6px;
      cursor: pointer;
    }
    #speed::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 12px;
      width: 12px;
      background: #888;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid #aaa;
    }
    #speedValue {
      margin-left: 20px;
      min-width: 40px;
      text-align: right;
      display: inline-block;
    }
    #clearAllBtn {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      font-size: 14px;
      padding: 8px 12px;
      cursor: pointer;
    }
    #clearAllBtn:hover { background-color: #555; }
    /* Extra Sidebar Buttons */
    #optionsButtonContainer, #saveLoadButtonContainer, #modButtonContainer, #communityButtonContainer {
      text-align: center;
    }
    #optionsButton, #saveLoadButton, #modButton, #communityButton {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      margin: 5px;
    }
    #optionsButton:hover, #saveLoadButton:hover, #modButton:hover, #communityButton:hover {
      background-color: #555;
    }
    /* Mod Manager Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: rgba(0,0,0,0.8);
    }
    .modal .modal-content {
      background-color: #333;
      margin-top: 5% auto;
      padding: 20px 20px;
      border: 1px solid #888;
      width: calc(100% - 20px);
      max-width: 600px;
      max-height: 90vh;
      bottom: 0;
      position: sticky;
      display: flex !important;
      flex-direction: column;
      overflow: auto;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 5;
      scrollbar-width: thin;
      scrollbar-color: #666 #333;
    }
    .modal .close {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
    }
    .modal .close:hover,
    .modal .close:focus {
      color: #fff;
      text-decoration: none;
      cursor: pointer;
    }
    .modal input[type="text"],
    .modal textarea,
    .modal select {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      background-color: #222;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      box-sizing: border-box;
    }
    .modal button {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
    }
    .modal button:hover {
      background-color: #555;
    }
    
    /* Community saves styles */
    #communitySavesList {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 15px;
    }
    
    #communitySavesList .loading,
    #communitySavesList .no-saves,
    #communitySavesList .error {
      padding: 10px;
      text-align: center;
      color: #ddd;
    }
    
    #communitySavesList .error {
      color: #ff6b6b;
    }
    
    .save-metadata {
      display: flex;
      flex-wrap: wrap;
      font-size: 0.8em;
      color: #aaa;
      margin-top: 5px;
    }
    
    .save-metadata > div {
      margin-right: 10px;
    }
    
    .save-publisher {
      font-style: italic;
    }
    
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      width: 100px;
      height: 100px;
      background-color: #222;
      border: 1px solid #444;
    }
    
    .preview-cell {
      width: 100%;
      height: 100%;
      background-color: #000;
    }
    
    .preview-error {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100px;
      height: 100px;
      background-color: #333;
      color: #ff6b6b;
      font-size: 0.8em;
      text-align: center;
    }
    
    .save-game-card {
      display: flex;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 5px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    
    .save-preview {
      flex: 0 0 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #222;
    }
    
    .save-info {
      flex: 1;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    
    .save-title {
      font-weight: bold;
      font-size: 1.1em;
      margin-bottom: 5px;
    }
    
    .save-description {
      color: #ccc;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    
    .load-save-button {
      align-self: flex-end;
      margin-top: auto;
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 5px 10px;
      cursor: pointer;
    }
    
    .load-save-button:hover {
      background-color: #555;
    }
    /* Styles for mod cards in the mod menu */
    .modCard {
      background-color: #444;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
    }
    .modCard h3 {
      margin: 0;
      font-size: 18px;
    }
    .modCard p {
      font-size: 14px;
      margin: 5px 0;
    }
    .modCard small {
      font-size: 12px;
      color: #aaa;
    }
    .modCard small.incompatible {
      color: red;
    }
    .modCard button {
      background-color: #555;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }
    .modCard button:hover {
      background-color: #666;
    }
    .acid          { background-color: #90EE90; }
    .acid-steam    { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud    { background-color: #98FB98; }
    .slime         { background-color: #006400; }
    /* Tool styles */
    .tool.heat { background: linear-gradient(45deg, #ff4500, #ffd700); }
    .tool.cool { background: linear-gradient(45deg, #00bfff, #87ceeb); }
    .tool.cook { background-color: #deb887; }
    .tool.mix { background: repeating-linear-gradient(45deg, #444, #666 10px); }
    .tool.move { background-color: #4169e1; }
    .tool.sponge { background-color: #ffa07a; }
    .tool.extinguish { background-color: #4682b4; }
    /* Add to existing styles */
    .options-section {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .options-section.experimental {
      background-color: #333;
      border-color: #ffd700;
    }

    .options-section h3 {
      margin-top: 0;
      color: #ffd700;
      font-size: 1.2em;
      letter-spacing: 0.5px;
    }

    .options-button {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      width: 100%;
      margin: 5px 0;
    }

    .options-button:hover {
      background-color: #555;
    }

    /* Make the saved games display in a grid */
    #savedGamesList {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      max-height: 280px;
      overflow-y: auto;
      padding: 10px 0;
    }

    /* Style for each save game card */
    .save-game-card {
      border: 1px solid #555;
      border-radius: 5px;
      padding: 10px;
      background-color: #333;
      display: flex;
      flex-direction: column;
    }

    /* Container for the preview image */
    .save-preview {
      width: 100%;
      height: 120px;
      margin-bottom: 10px;
      border: 1px solid #666;
      position: relative;
      overflow: hidden;
    }

    /* The actual preview grid */
    .preview-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: grid;
    }

    /* Info section with title and description */
    .save-info {
      margin-bottom: 10px;
    }

    .save-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
    }

    .save-description {
      font-size: 12px;
      color: #aaa;
      height: 30px;
      overflow: hidden;
    }

    /* Buttons at the bottom of each card */
    .save-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: auto;
    }

    .save-buttons button {
      padding: 5px 8px;
      font-size: 12px;
      background-color: #444;
      border: none;
      color: white;
      cursor: pointer;
    }

    .save-buttons button:hover {
      background-color: #555;
    }

    .save-buttons .load-button {
      background-color: #2a6496;
    }

    .save-buttons .load-button:hover {
      background-color: #337ab7;
    }

    /* Input groups and warnings */
    .input-group {
      margin-bottom: 10px;
      position: relative;
    }

    .input-group input {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      margin-bottom: 2px;
    }

    .input-warning {
      color: #ff6b6b;
      font-size: 12px;
      height: 15px;
      margin-top: 2px;
    }

    /* Info icon next to save title */
    .save-title-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }

    .save-title {
      font-weight: bold;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }

    .info-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #4286f4;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-left: 8px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .info-icon:hover {
      background-color: #2a6496;
    }

    /* Popup for save information */
    .save-info-popup {
      position: absolute;
      right: -250px;
      top: 0;
      width: 240px;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 5px;
      padding: 10px;
      z-index: 10;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      display: none;
    }

    .save-info-popup.active {
      display: block;
    }

    .save-game-card {
      position: relative;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
    }

    .info-label {
      color: #aaa;
    }

    .info-value {
      color: white;
      font-weight: bold;
    }

    .close-info {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 14px;
      color: #aaa;
    }

    .close-info:hover {
      color: white;
    }

    #popOutWindow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 10px;
      border: 2px solid #444;
      border-radius: 5px;
      display: none;
      z-index: 2000;
    }

    /* Mobile touch support */
    @media (max-width: 1024px) {
      #mainContainer {
        flex-direction: column;
        height: auto;
      }
      #grid {
        width: 100%;
        max-width: none;
        height: auto;
      }
      #sidePanel {
        width: 100%;
        min-width: 0;
        height: auto;
      }
    }

    /* Add dynamic lighting styles */
    .cell.lit {
      transition: background-color 0.1s ease;
    }

    .cell.glass.lit {
      transition: background-color 0.2s ease;
      mix-blend-mode: screen;
    }

    /* Add to existing styles */
    .option-item {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      transition: border-color 0.2s ease;
    }

    .option-item:hover {
      border-color: #666;
    }

    .option-description {
      color: #888;
      font-size: 0.9em;
      margin: 5px 0 0 0;
      font-style: italic;
    }

    /* Main menu specific styling */
    .main-menu {
      text-align: center;
      background-color: rgba(34, 34, 34, 0.95) !important;
      min-height: 500px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 40px 20px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .main-menu h1 {
      font-size: 3.5em;
      color: #fff;
      margin: 0;
      padding: 20px 0;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
      border-radius: 10px;
      margin-bottom: 40px;
    }

    .main-menu-buttons {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 30px;
      align-items: center;
      margin: 20px 0;
    }

    .main-menu-button {
      background: linear-gradient(45deg, #444, #333);
      border: 2px solid #666;
      border-radius: 10px;
      color: #fff;
      padding: 20px 40px;
      font-size: 1.4em;
      cursor: pointer;
      width: 250px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
    }

    .main-menu-button:hover {
      background: linear-gradient(45deg, #555, #444);
      border-color: #888;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
    }

    .main-menu-button:active {
      transform: scale(0.98);
    }

    .engine-info {
      padding: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      margin-top: 20px;
    }

    /* Help Menu Styling */
    .help-menu {
      display: none;
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .help-content {
      background-color: #333;
      margin: 5% auto;
      padding: 30px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      border-radius: 15px;
      position: relative;
      display: flex;
      flex-direction: column;
      color: #fff;
    }

    .help-page {
      display: none;
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .help-page.active {
      display: block;
    }

    .help-navigation {
      display: flex;
      justify-content: space-between;
      padding: 20px 0;
      border-top: 1px solid #444;
      margin-top: 20px;
    }

    .help-nav-button {
      background: #444;
      border: none;
      padding: 10px 20px;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .help-nav-button:hover {
      background: #555;
    }

    .help-nav-button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    .help-close {
      position: absolute;
      right: 20px;
      top: 20px;
      font-size: 24px;
      color: #fff;
      cursor: pointer;
      background: none;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
    }

    .help-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Options modal height fix */
    .modal-content {
      margin: 2vh auto;
      flex-direction: column;
      max-height: 96vh;
    }
    
    /* Options content scrollable styles */
    .options-content {
      overflow-y: auto;
      padding-right: 10px;
      margin-right: -10px;
      flex: 1;
      max-height: calc(80vh - 120px);
      scrollbar-width: thin;
      scrollbar-color: #666 #333;
    }
    
    .options-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .options-content::-webkit-scrollbar-track {
      background: #333;
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb {
      background-color: #666;
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb:hover {
      background-color: #888;
    }
    
    #optionsModal h2 {
      position: sticky;
      top: 0;
      background-color: #333;
      margin-top: 0;
      padding-top: 10px;
      z-index: 5;
      color: #ffd700;
      text-align: center;
      font-size: 1.6em;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #optionsModal #applyOptionsButton #saveLoadModal {
      display: none !important;
      margin-top: 15px;
      background: linear-gradient(to bottom, #666, #444);
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      position: sticky;
      bottom: 0;
      width: calc(100% - 20px);
      margin-left: auto;
      margin-right: auto;
      border-top: 1px solid #444;
      padding-top: 15px;
      z-index: 5;
      background-color: #333;
    }
    
    #optionsModal #applyOptionsButton.show-clear-warning {
      display: block !important;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Modal footer style */
    .modal-footer {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #444;
      text-align: center;
    }

    /* Add to existing styles */
    .options-section.disabled {
      opacity: 0.5;
      pointer-events: none;
      position: relative;
    }

    .options-section.disabled::after {
      content: "Coming Soon";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
    }

    /* Confirmation Modal */
    .confirmation-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .confirmation-content {
      background-color: #333;
      margin: 15% auto;
      padding: 20px;
      width: 300px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      text-align: center;
      color: #fff;
    }

    .confirmation-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .confirmation-buttons button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .confirmation-yes {
      background-color: #4CAF50;
      color: white;
    }

    .confirmation-no {
      background-color: #f44336;
      color: white;
    }

    .confirmation-buttons button:hover {
      transform: scale(1.05);
    }

    /* Add styles for the apply button states */
    #applyOptionsButton {
      display: none;
    }

    #applyOptionsButton.show-clear-warning {
      display: block;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Community Button and Modal Styling */
    #communityButtonContainer {
      margin-top: 10px;
      text-align: center;
    }
    
    #communityButton {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    
    #communityButton:hover {
      background-color: #3a5a80;
    }
    
    /* Community Modal Styling */
    .login-form, .upload-form {
      margin: 15px 0;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input, .form-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
    }
    
    .form-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .message {
      margin-top: 10px;
      padding: 8px;
      border-radius: 4px;
    }
    
    .message.error {
      background-color: #ffebee;
      color: #c62828;
    }
    
    .message.success {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    
    .community-tabs {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 20px;
    }
    
    .community-tab-btn {
      background: none;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      font-size: 16px;
      border-bottom: 3px solid transparent;
      color: #fff;
    }
    
    .community-tab-btn.active {
      border-bottom: 3px solid #4a6fa5;
      font-weight: bold;
    }
    
    .community-tab-content {
      display: none;
    }
    
    .community-tab-content.active {
      display: block;
    }
    
    .community-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .community-filters select, .community-filters input {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
    }
    
    .community-filters input {
      flex-grow: 1;
    }
    
    .community-saves-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      max-height: 500px;
      overflow-y: auto;
    }
    
    .community-save-card {
      border: 1px solid #444;
      border-radius: 4px;
      padding: 15px;
      background-color: #333;
      position: relative;
    }
    
    .community-save-preview {
      width: 100%;
      height: 150px;
      background-color: #222;
      margin-bottom: 10px;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .community-save-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .community-save-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 5px;
      color: #fff;
    }
    
    .community-save-author, .community-save-date {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .community-save-description {
      font-size: 14px;
      margin-bottom: 10px;
      max-height: 60px;
      overflow: hidden;
      color: #ddd;
    }
    
    .community-save-actions {
      display: flex;
      justify-content: flex-end;
    }
    
    .community-save-actions button {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .community-save-actions button:hover {
      background-color: #3a5a80;
    }
    
    .local-saves-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #444;
      border-radius: 4px;
      margin-bottom: 15px;
      background-color: #222;
    }
    
    .local-save-item {
      padding: 10px;
      border-bottom: 1px solid #333;
      cursor: pointer;
      color: #ddd;
    }
    
    .local-save-item:last-child {
      border-bottom: none;
    }
    
    .local-save-item.selected {
      background-color: #2a4a70;
    }
    
    .local-save-item:hover {
      background-color: #444;
    }
    
    .community-loading {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }
    

  </style>
</head>
<body>
  <!-- Main Menu Modal -->
  <div id="mainMenuModal" class="modal" style="display: block;">
    <div class="modal-content main-menu">
      <h1>Sandbox Delta</h1>
      <div class="main-menu-buttons">
        <button id="beginGameBtn" class="main-menu-button">Begin Game</button>
        <button id="helpBtn" class="main-menu-button">Help</button>
        <button id="modsMenuBtn" class="main-menu-button">Mods (Alpha)</button>
      </div>
      <div class="engine-info">
        <span class="version-info">Sandbox Delta Version 0.7.1c</span>
        <span class="engine-version">Dabicco Engine 8.7.4</span>
      </div>
    </div>
  </div>

  <!-- Help Menu -->
  <div id="helpMenu" class="help-menu">
    <div class="help-content">
      <button class="help-close">&times;</button>
      <div class="help-page active" data-page="1">
        <h2>Welcome to Sandbox Delta</h2>
        <p>Sandbox Delta is a physics-based particle simulation game where you can experiment with various elements and their interactions. Create complex systems, generate reactions, and explore the possibilities!<br>The game is compiled on Dabicco Engine 8.7.4</p>
        
        <h3>Basic Controls</h3>
        <ul>
          <li>Left Click/Touch: Place selected element</li>
          <li>Right Click: Erase elements</li>
          <li>Mouse Wheel: Adjust brush size</li>
        </ul>

        <h3>Interface Overview</h3>
        <ul>
          <li>Main Grid: The simulation area where elements interact</li>
          <li>Side Panel: Contains element selection and categories</li>
          <li>Speed Slider: Controls simulation speed (0.0x to 4.0x)</li>
          <li>Element Search: Quick-find elements by name</li>
          <li>HUD: Shows temperature, selected element, and FPS</li>
        </ul>
      </div>

      <div class="help-page" data-page="2">
        <h2>Elements & Categories</h2>
        
        <h3>Basic Elements</h3>
        <ul>
          <li>Sand: Basic powder that falls and piles up</li>
          <li>Water: Flows and interacts with other elements</li>
          <li>Fire: Burns flammable materials and spreads</li>
          <li>Wood: Can be burned and supports plant growth</li>
          <li>Stone: Solid building material</li>
          <li>Wall: Indestructible barrier</li>
        </ul>

        <h3>Element Categories</h3>
        <ul>
          <li>Powders: Sand, Flour, Coal Lumps, etc.</li>
          <li>Liquids: Water, Lava, Oil, etc.</li>
          <li>Gases: Steam, Smoke, Gas, etc.</li>
          <li>Solids: Stone, Wood, Glass, etc.</li>
          <li>Life: Plants, Seeds, Birds, etc.</li>
          <li>Explosives: Bombs, Thermite</li>
          <li>Cooking: Dough, Bread, Meat</li>
          <li>Electricity: Copper, Circuits, Logic Gates</li>
        </ul>
      </div>

      <div class="help-page" data-page="3">
        <h2>Advanced Mechanics</h2>
        
        <h3>Temperature System</h3>
        <p>Elements have temperature properties that affect their behavior:</p>
        <ul>
          <li>Heat Transfer: Elements conduct heat between each other</li>
          <li>State Changes: Water boils to steam, lava cools to stone</li>
          <li>Reactions: High temperatures can cause burning, melting, or explosions</li>
          <li>Tools: Use Heat and Cool tools to manipulate temperature</li>
        </ul>

        <h3>Plant Growth</h3>
        <ul>
          <li>Wheat: Grows from seeds, produces flour</li>
          <li>Oak Trees: Complex growth with branches and leaves</li>
          <li>Grass: Spreads naturally on dirt</li>
          <li>Roots: Absorb water from wet soil</li>
        </ul>

        <h3>Special Tools</h3>
        <ul>
          <li>Mix Tool: Stirs elements together</li>
          <li>Move Tool: Precisely position elements</li>
          <li>Sponge: Removes burning materials</li>
          <li>Cook Tool: Process food items</li>
        </ul>
      </div>

      <div class="help-page" data-page="4">
        <h2>Advanced Features</h2>
        
        <h3>Electrical System</h3>
        <p>Create complex circuits and logic systems:</p>
        <ul>
          <li>Copper: Conducts electricity and heat</li>
          <li>Spark: Initiates electrical current</li>
          <li>Logic Gates: NOT, AND gates for circuits</li>
          <li>Input/Output: Control signal flow</li>
          <li>Heat Separator: Manages heat distribution</li>
        </ul>

        <h3>Chemical Reactions</h3>
        <ul>
          <li>Sand + Heat = Glass</li>
          <li>Water + Lava = Stone/Obsidian</li>
          <li>Flour + Water = Dough</li>
          <li>Dough + Heat = Bread</li>
          <li>Coal + Heat = Long-burning fuel</li>
        </ul>
      </div>

      <div class="help-page" data-page="5">
        <h2>Game Features</h2>
        
        <h3>Save System</h3>
        <ul>
          <li>Save/Load: Store and retrieve your creations</li>
          <li>Export: Share save files with other players</li>
          <li>Import: Load shared save files</li>
        </ul>

        <h3>World Generation</h3>
        <ul>
          <li>Terrain Generation: Create natural landscapes</li>
          <li>Cave Systems: Underground networks</li>
          <li>Ore Deposits: Find valuable materials</li>
          <li>Ecosystems: Plants and wildlife</li>
        </ul>

        <h3>Mod Support</h3>
        <ul>
          <li>Custom Elements: Add new materials</li>
          <li>New Behaviors: Modify element interactions</li>
          <li>Visual Effects: Change appearance</li>
          <li>Game Extensions: Add new features</li>
        </ul>

        <h3>Tips & Tricks</h3>
        <ul>
          <li>Use the search function to quickly find elements</li>
          <li>Adjust brush size for precise or broad placement</li>
          <li>Experiment with element combinations</li>
          <li>Watch temperature changes in the HUD</li>
          <li>Try the terrain generator for inspiration</li>
        </ul>
      </div>

      <div class="help-navigation">
        <button class="help-nav-button" id="prevPage" disabled>Previous Page</button>
        <span id="pageIndicator">Page 1 of 5</span>
        <button class="help-nav-button" id="nextPage">Next Page</button>
      </div>
    </div>
  </div>

  <script>
    // Help menu functionality
    document.addEventListener('DOMContentLoaded', function() {
      const helpMenu = document.getElementById('helpMenu');
      const helpBtn = document.getElementById('helpBtn');
      const closeHelpBtn = document.querySelector('.help-close');
      const prevPageBtn = document.getElementById('prevPage');
      const nextPageBtn = document.getElementById('nextPage');
      const pageIndicator = document.getElementById('pageIndicator');
      const pages = document.querySelectorAll('.help-page');
      let currentPage = 1;
      const totalPages = pages.length;

      function updatePageButtons() {
        prevPageBtn.disabled = currentPage === 1;
        nextPageBtn.disabled = currentPage === totalPages;
        pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
      }

      function showPage(pageNum) {
        pages.forEach(page => page.classList.remove('active'));
        document.querySelector(`[data-page="${pageNum}"]`).classList.add('active');
        currentPage = pageNum;
        updatePageButtons();
      }

      helpBtn.addEventListener('click', () => {
        helpMenu.style.display = 'block';
        showPage(1);
      });

      closeHelpBtn.addEventListener('click', () => {
        helpMenu.style.display = 'none';
      });

      prevPageBtn.addEventListener('click', () => {
        if (currentPage > 1) showPage(currentPage - 1);
      });

      nextPageBtn.addEventListener('click', () => {
        if (currentPage < totalPages) showPage(currentPage + 1);
      });

      // Fix for load save functionality
      document.getElementById('createCanvasBtn').addEventListener('click', function() {
        const creationMode = document.getElementById('gameCreationMode').value;
        
        if (creationMode === 'load') {
          // Initialize with default settings
          initGrid(50);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Show load menu
          const saveLoadModal = document.getElementById('saveLoadModal');
          saveLoadModal.style.display = 'block';
          saveLoadModal.querySelector('h2').textContent = 'Load';
          const saveSection = saveLoadModal.querySelector('div:first-of-type');
          if (saveSection) saveSection.style.display = 'none';
          updateSavedGamesList();
        } else {
          // Normal new game creation
          const size = parseInt(document.getElementById('newGameSizeSelect').value);
          const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
          
          initGrid(size);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Add terrain generation function if it doesn't exist
          if (typeof generateTerrain !== 'function') {
            window.generateTerrain = function() {
              // Simple terrain generation - create ground at the bottom half
              const groundLevel = Math.floor(GRID_SIZE * 0.7);
              
              for (let y = groundLevel; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                  // Mostly dirt with some sand and stone
                  const rand = Math.random();
                  if (rand < 0.7) {
                    grid[y][x] = DIRT;
                    temp[y][x] = 20;
                  } else if (rand < 0.9) {
                    grid[y][x] = SAND;
                    temp[y][x] = 20;
                  } else {
                    grid[y][x] = STONE;
                    temp[y][x] = 20;
                  }
                }
              }
              
              // Add some underground features
              for (let i = 0; i < Math.floor(GRID_SIZE/5); i++) {
                const caveX = Math.floor(Math.random() * GRID_SIZE);
                const caveY = Math.floor(groundLevel + Math.random() * (GRID_SIZE - groundLevel));
                const caveSize = 3 + Math.floor(Math.random() * 4);
                
                for (let dy = -caveSize; dy <= caveSize; dy++) {
                  for (let dx = -caveSize; dx <= caveSize; dx++) {
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance <= caveSize) {
                      const nx = caveX + dx;
                      const ny = caveY + dy;
                      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && ny >= groundLevel) {
                        grid[ny][nx] = EMPTY;
                        temp[ny][nx] = null;
                      }
                    }
                  }
                }
              }
              
              renderGrid();
            };
          }
          
          if (shouldGenerateTerrain) {
            generateTerrain();
          }
        }
      });
    });
  </script>

  <!-- New Game Modal -->
  <div id="newGameModal" class="modal">
    <div class="modal-content">
      <span id="closeNewGameModal" class="close">&times;</span>
      <h2>New Game</h2>
      <div class="options-section">
        <div class="option-item">
          <label for="gameCreationMode">Game Creation Mode:</label>
          <select id="gameCreationMode">
            <option value="new">New Game</option>
            <option value="load">Load Save</option>
          </select>
          <p class="option-description">Choose between creating a new game or loading an existing save.</p>
        </div>

        <div id="newGameOptions">
          <div class="option-item">
            <label for="newGameSizeSelect">Stage Size:</label>
            <select id="newGameSizeSelect">
              <option value="25">25x25x25</option>
              <option value="50" selected>50x50x50</option>
              <option value="75">75x75x75</option>
              <option value="100">100x100x100</option>
              <option value="125">125x125x125</option>
            </select>
            <p class="option-description">Changes the size of the simulation grid. Larger sizes may impact performance.</p>
          </div>

          <div class="option-item">
            <label for="generateTerrainToggle">Generate Terrain:</label>
            <select id="generateTerrainToggle">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Start with a procedurally generated world containing caves, ores, and surface features.</p>
          </div>
        </div>
      </div>
      <button id="createCanvasBtn" class="main-menu-button">Create Canvas</button>
    </div>
  </div>

  <script>
    // Game version updated to 0.7.1c
    window.currentGameVersion = "0.7.1c";

    // Initialize main menu system
    document.addEventListener('DOMContentLoaded', function() {
      const mainContainer = document.getElementById('mainContainer');
      const mainMenuModal = document.getElementById('mainMenuModal');
      const newGameModal = document.getElementById('newGameModal');
      const saveLoadModal = document.getElementById('saveLoadModal');
      const modMenu = document.getElementById('modMenu');
      const urlParams = getUrlParameters();

      // Update version displays
      document.querySelector('.version-info').textContent = `Sandbox Delta Version ${window.currentGameVersion}`;

      // Hide main container initially

      // Begin Game button
      document.getElementById('beginGameBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        newGameModal.style.display = 'block';
      });

      // Mods button
      document.getElementById('modsMenuBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        modMenu.style.display = 'block';
        updateModListUI();
      });

      // Add game creation mode handling
      document.getElementById('gameCreationMode').addEventListener('change', function(e) {
        const newGameOptions = document.getElementById('newGameOptions');
        const createCanvasBtn = document.getElementById('createCanvasBtn');
        
        if (e.target.value === 'load') {
          newGameOptions.style.display = 'none';
          createCanvasBtn.textContent = 'Continue to Load';
        } else {
          newGameOptions.style.display = 'block';
          createCanvasBtn.textContent = 'Create Canvas';
        }
      });

    // Update Create Canvas button behavior
    document.getElementById('createCanvasBtn').addEventListener('click', function() {
      const creationMode = document.getElementById('gameCreationMode').value;
      
      if (creationMode === 'load') {
        // Initialize with default settings
        initGrid(50);
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
        
        // Show load menu
        const saveLoadModal = document.getElementById('saveLoadModal');
        saveLoadModal.style.display = 'block';
        saveLoadModal.querySelector('h2').textContent = 'Load';
        const saveSection = saveLoadModal.querySelector('div:first-of-type');
        if (saveSection) saveSection.style.display = 'none';
        updateSavedGamesList();
      } else {
        // Normal new game creation
        const size = parseInt(document.getElementById('newGameSizeSelect').value);
        const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
        
        initGrid(size);
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
        
        if (shouldGenerateTerrain) {
          window.generateTerrain(); // Call the global function explicitly
        }
      }
    });

      // Close buttons for modals
      document.getElementById('closeNewGameModal').addEventListener('click', function() {
        newGameModal.style.display = 'none';
        mainMenuModal.style.display = 'block';
      });

      // When closing save/load or mods menu, return to main menu if game hasn't started
      const closeModMenu = document.getElementById('closeModMenu');
      const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');

      // Variated Colors setting in Options menu
      const variatedColorsToggle = document.getElementById('variatedColorsToggle');
      const applyVariatedColors = document.getElementById('applyVariatedColors');
      
      // DSPLE setting in Options menu
      const dspleToggle = document.getElementById('dspleToggle');
      const applyDsple = document.getElementById('applyDsple');
      
      // Initialize toggles based on current settings
      variatedColorsToggle.value = window.isVariatedColorsEnabled ? '1' : '0';
      dspleToggle.value = window.isDspleEnabled ? '1' : '0';
      
      // Apply Variated Colors setting
      applyVariatedColors.addEventListener('click', function() {
        const newVariatedColorsSetting = variatedColorsToggle.value === '1';
        
        // If setting changed from disabled to enabled, reassign all color variations
        if (!window.isVariatedColorsEnabled && newVariatedColorsSetting) {
          reassignColorVariations();
        }
        
        // Update the setting
        window.isVariatedColorsEnabled = newVariatedColorsSetting;
        
        // Re-render the grid to apply changes
        renderGrid();
      });
      
      // Apply DSPLE setting
      applyDsple.addEventListener('click', function() {
        const newDspleSetting = dspleToggle.value === '1';
        
        // Update the setting
        window.isDspleEnabled = newDspleSetting;
        
        if (newDspleSetting) {
          // Initialize the lighting engine if enabling
          initDspleLightingEngine();
        } else {
          // Clean up lighting effects if disabling
          cleanupDspleLightingEngine();
        }
        
        // Re-render the grid to apply changes
        renderGrid();
      });
      
      closeModMenu.addEventListener('click', function() {
        modMenu.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      closeSaveLoadModal.addEventListener('click', function() {
        saveLoadModal.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      // Window click handlers
      window.addEventListener('click', function(event) {
        if (event.target === newGameModal) {
          newGameModal.style.display = 'none';
          mainMenuModal.style.display = 'block';
        }
        if (event.target === saveLoadModal) {
          saveLoadModal.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
        if (event.target === modMenu) {
          modMenu.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
      });
    });
  </script>

  <div id="mainContainer">
    <!-- The simulation grid (will be rebuilt based on stage size) -->
    <div id="grid">
      <!-- Hover overlay element -->
      <div id="hoverOverlay"></div>
    </div>
    <!-- Side panel -->
    <div id="sidePanel">
      <!-- Side content: two columns (element list and category menu) -->
      <div id="sideContent">
        <!-- Element list scroll area -->
        <div id="elementScroll">
          <div id="toolSearchContainer">
            <input type="text" id="toolSearch" placeholder="Search elements...">
          </div>
          <div id="toolbar">
            <!-- Eraser is FIRST so it's always on top by default. -->
            <div class="tool eraser" data-tool="eraser" data-cat="solids" title="Eraser"><span>Eraser</span></div>
            <!-- Tools -->
            <div class="tool heat" data-tool="heat" data-cat="tools" title="Heat Tool"><span>Heat</span></div>
            <div class="tool cool" data-tool="cool" data-cat="tools" title="Cool Tool"><span>Cool</span></div>
            <div class="tool cook" data-tool="cook" data-cat="tools" title="Cook Tool"><span>Cook</span></div>
            <div class="tool mix" data-tool="mix" data-cat="tools" title="Mix Tool"><span>Mix</span></div>
            <div class="tool move" data-tool="move" data-cat="tools" title="Move Tool"><span>Move</span></div>
            <div class="tool sponge" data-tool="sponge" data-cat="tools" title="Sponge Tool"><span>Sponge</span></div>
            <div class="tool extinguish" data-tool="extinguish" data-cat="tools" title="Extinguish Tool"><span>Ext</span></div>
            <!-- Tools in desired order -->
            <div class="tool sand selected" data-tool="sand" data-cat="powders" title="Sand"><span>S</span></div>
            <div class="tool wall" data-tool="wall" data-cat="solids" title="Wall"><span>Wall</span></div>
            <div class="tool water" data-tool="water" data-cat="liquids" title="Water"><span>W</span></div>
            <div class="tool lava" data-tool="lava" data-cat="liquids" title="Lava"><span>Lv</span></div>
            <div class="tool stone" data-tool="stone" data-cat="solids" title="Stone"><span>St</span></div>
            <div class="tool water-vapor" data-tool="water-vapor" data-cat="gasses" title="Water Vapor"><span>V</span></div>
            <div class="tool copper" data-tool="copper" data-cat="electricity" title="Copper"><span>Cu</span></div>
            <div class="tool steel" data-tool="steel" data-cat="solids" title="Steel"><span>Fe</span></div>
            <div class="tool ice" data-tool="ice" data-cat="solids" title="Ice"><span>I</span></div>
            <div class="tool wood" data-tool="wood" data-cat="solids" title="Wood"><span>Wd</span></div>
            <div class="tool fire" data-tool="fire" data-cat="gasses" title="Fire"><span>F</span></div>
            <div class="tool smoke" data-tool="smoke" data-cat="gasses" title="Smoke"><span>Sm</span></div>
            <div class="tool ash" data-tool="ash" data-cat="powders" title="Ash"><span>A</span></div>
            <div class="tool glass" data-tool="glass" data-cat="solids" title="Glass"><span>G</span></div>
            <div class="tool bomb" data-tool="bomb" data-cat="explosives" title="Bomb"><span>B</span></div>
            <div class="tool dirt" data-tool="dirt" data-cat="powders" title="Dirt"><span>Di</span></div>
            <div class="tool wet-dirt" data-tool="wet-dirt" data-cat="powders" title="Wet Dirt"><span>WDi</span></div>
            <div class="tool wheat-seeds" data-tool="wheat-seeds" data-cat="life" title="Wheat Seeds"><span>WSeeds</span></div>
            <div class="tool flour" data-tool="flour" data-cat="powders,cooking" title="Flour"><span>Flr</span></div>
            <div class="tool dough" data-tool="dough" data-cat="cooking" title="Dough"><span>Dh</span></div>
            <div class="tool bread" data-tool="bread" data-cat="cooking" title="Bread"><span>Br</span></div>
            <div class="tool plant-root" data-tool="plant-root" data-cat="life" title="Plant Roots"><span>PR</span></div>
            <div class="tool spark" data-tool="spark" data-cat="electricity" title="Spark"><span>Sp</span></div>
            <div class="tool oak-seeds" data-tool="oak-seeds" data-cat="life" title="Oak Tree Seeds"><span>OakS</span></div>
            <div class="tool grass" data-tool="grass" data-cat="life" title="Grass"><span>Gr</span></div>
            <div class="tool gas" data-tool="gas" data-cat="gasses" title="Gas"><span>Gas</span></div>
            <!-- cooler & heater -->
            <div class="tool cooler" data-tool="cooler" data-cat="electricity" title="Cooler"><span>CL</span></div>
            <div class="tool heater" data-tool="heater" data-cat="electricity" title="Heater"><span>HT</span></div>
            <!-- Additional Electric Elements -->
            <div class="tool heat-separator" data-tool="heat-separator" data-cat="electricity" title="Heat Separator"><span>HS</span></div>
            <div class="tool input" data-tool="input" data-cat="electricity" title="Input"><span>In</span></div>
            <div class="tool output" data-tool="output" data-cat="electricity" title="Output"><span>Out</span></div>
            <div class="tool not-gate" data-tool="not-gate" data-cat="electricity" title="Not Gate"><span>NOT</span></div>
            <div class="tool and-gate" data-tool="and-gate" data-cat="electricity" title="And Gate"><span>AND</span></div>
            <div class="tool blocker" data-tool="blocker" data-cat="electricity" title="Blocker"><span>Blkr</span></div>
            <!-- Cloner (special) -->
            <div class="tool cloner" data-tool="cloner" data-cat="special" title="Cloner"><span>Cln</span></div>
            <!-- New elements: Coal and Coal Lump -->
            <div class="tool coal" data-tool="coal" data-cat="solids" title="Coal"><span>C</span></div>
            <div class="tool coal-lump" data-tool="coal-lump" data-cat="powders" title="Coal Lump"><span>CLu</span></div>
            <!-- New element: Thermite â€“ assign THERMITE and BURNING_THERMITE (ensure no conflict with mod Orange Juice)
            <div class="tool thermite" data-tool="thermite" data-cat="explosives,powders" title="Thermite"><span>Th</span></div>
            <!-- New elements -->
            <div class="tool acid" data-tool="acid" data-cat="liquids" title="Acid"><span>Acid</span></div>
            <div class="tool slime" data-tool="slime" data-cat="liquids" title="Slime"><span>Slime</span></div>
            <!-- Additional new elements -->
            <div class="tool carbon-dioxide" data-tool="carbon-dioxide" data-cat="gasses" title="Carbon Dioxide"><span>CO2</span></div>
            <div class="tool oxygen" data-tool="oxygen" data-cat="gasses" title="Oxygen"><span>O2</span></div>
            <div class="tool bird" data-tool="bird" data-cat="life" title="Bird"><span>Bird</span></div>
            <div class="tool meat" data-tool="meat" data-cat="cooking" title="Meat"><span>Meat</span></div>
            <div class="tool cooked-meat" data-tool="cooked-meat" data-cat="cooking" title="Cooked Meat"><span>CMeat</span></div>
            <div class="tool cobblestone" data-tool="cobblestone" data-cat="powders" title="Cobblestone"><span>Cbl</span></div>
            <div class="tool oil" data-tool="oil" data-cat="liquids" title="Oil"><span>Oil</span></div>
            <div class="tool thermite" data-tool="thermite" data-cat="powders,explosives" title="Thermite"><span>Th</span></div>
            <div class="tool big-bomb" data-tool="big-bomb" data-cat="explosives" title="Big Bomb"><span>GB</span></div>
            <div class="tool water-bomb" data-tool="water-bomb" data-cat="explosives" title="Water Bomb"><span>WB</span></div>
            <div class="tool nuke-bomb" data-tool="nuke-bomb" data-cat="explosives" title="Nuke Bomb"><span>Nuke</span></div>
            <div class="tool helium" data-tool="helium" data-cat="gasses" title="Helium"><span>He</span></div>
            <div class="tool bouncy-ball" data-tool="bouncy-ball" data-cat="special" title="Bouncy Ball"><span>BB</span></div>
            <div class="tool birch-seeds" data-tool="birch-seeds" data-cat="life" title="Birch Tree Seeds"><span>BirchS</span></div>
          </div>
        </div>
        <!-- Category menu (independent scroll area on the right) -->
        <div id="categoryMenu">
          <button data-category="all" class="selectedCat">All</button>
          <button data-category="tools">Tools</button>
          <button data-category="liquids">Liquids</button>
          <button data-category="powders">Powders</button>
          <button data-category="solids">Solids</button>
          <button data-category="gasses">Gasses</button>
          <button data-category="explosives">Explosives</button>
          <button data-category="life">Life</button>
          <button data-category="cooking">Cooking</button>
          <button data-category="electricity">Electricity Beta</button>
          <button data-category="special">Special</button>
        </div>
      </div>
      <!-- HUD (not scrollable) -->
      <div id="hud">
        <div id="hudTemp">Temp: -- Â°C</div>
        <div id="hudElem">Element: --</div>
        <div id="hudFPS">FPS: --</div>
      </div>
      <!-- Bottom controls (not scrollable) -->
      <div id="bottomControls">
        <div id="speedContainer">
          <label for="speed">Simulation Speed:</label>
          <input type="range" id="speed" min="0" max="5" step="0.01" value="1"/>
          <span id="speedValue">1</span>Ã—
        </div>
        <button id="clearAllBtn">Clear All</button>
      </div>
      <!-- Extra Sidebar Buttons -->
      <div id="optionsButtonContainer">
        <button id="optionsButton">Options</button>
      </div>
      <div id="saveLoadButtonContainer">
        <button id="saveLoadButton">Save/Load</button>
      </div>
      <div id="communityButtonContainer">
        <button id="communityButton">Community</button>
      </div>
      <div id="modButtonContainer">
        <button id="modButton">Mods</button>
      </div>
    </div>
  </div>

  <script>
    /***************************************************************
     * The Entire Game Script; Made By Dabicco (Compiled in Dabicco Engine). DO NOT COPY!!
     * Global Constants are Defined First, many comments can be
     * found throughout the code to guide with modding.
     ***************************************************************/

    // Stage size is dynamic; default is 50.
    let GRID_SIZE = 50;
    // Tool constants
    const TOOL_HEAT         = 100;
    const TOOL_COOL         = 101;
    const TOOL_COOK         = 102;
    const TOOL_MIX          = 103;
    const TOOL_MOVE         = 104;
    const TOOL_SPONGE       = 105;
    const TOOL_EXTINGUISH   = 106;

    const EMPTY             = 0;
    const ERASER            = 5;
    // Basic elements
    const SAND              = 1;
    const WALL              = 44;
    const WATER             = 2;
    const LAVA              = 3;
    const STONE             = 4;
    const WATER_VAPOR       = 6;
    const CLOUD             = 7;
    const BASALT            = 8;
    const OBSIDIAN          = 9;
    const MOLTEN_SLAG       = 10;
    const COPPER            = 11;
    const STEEL             = 12;
    const ICE               = 13;
    const WOOD              = 14;
    const FIRE              = 15;
    const SMOKE             = 16;
    const BURNING_WOOD      = 17;
    const ASH               = 18;
    const GLASS             = 19;
    const BOMB              = 20;
    // Additional
    const DIRT              = 21;
    const WET_DIRT          = 22;
    const WHEAT_SEEDS       = 23;
    const WHEAT             = 24;
    const FLOUR             = 25;
    const DOUGH             = 26;
    const BREAD             = 27;
    const ROOT              = 28;
    const BURNING_ORGANIC   = 29;
    const SPARK             = 30;
    const CHARGED_COPPER    = 31;
    const OAK_SEEDS         = 32;
    const OAK_LEAVES        = 33;
    const OAK_BABY_LEAVES   = 34;
    const DEAD_OAK          = 35;
    const WET_SAND          = 36;
    const GRASS             = 37;
    const DEAD_PLANT        = 38;
    const BURNING_LEAVES    = 39;
    const BURNING_ROOT      = 40;
    const DEAD_ROOT         = 41;
    const GAS               = 42;
    const BURNING_GAS       = 43;
    const CHARGED_DOWN_COPPER = 45;
    // COOLER & HEATER
    const COOLER            = 46;
    const HEATER            = 47;
    // Electric elements
    const HEAT_SEPARATOR                = 48;
    const CHARGED_HEAT_SEPARATOR        = 49;
    const CHARGED_DOWN_HEAT_SEPARATOR   = 50;
    const INPUT                         = 51;
    const CHARGED_INPUT                 = 52;
    const OUTPUT                        = 53;
    const CHARGED_OUTPUT                = 54;
    const NOT_GATE                      = 55;
    const AND_GATE                      = 56;
    const BLOCKER                       = 57;
    const CHARGED_BLOCKER               = 61;
    // Cloner
    const CLONER                        = 60;
    // New elements: Coal and Coal Lump
    const COAL              = 62;
    const COAL_LUMP         = 63;
    const BURNING_COAL      = 64;
    const BURNING_COAL_LUMP = 65;
    // New element: Thermite â€“ assign THERMITE and BURNING_THERMITE (ensure no conflict with mod Orange Juice)
    const THERMITE          = 68;
    const BURNING_THERMITE  = 69;
    // New elements
    const ACID              = 70;
    const ACID_STEAM        = 71;
    const ACID_CLOUD        = 72;
    const SLIME             = 73;
    // Additional new elements
    const CARBON_DIOXIDE    = 74;
    const OXYGEN            = 75;
    const BIRD             = 76;
    const MEAT             = 77;
    const COOKED_MEAT      = 78;
    const COBBLESTONE      = 79;
    const OIL              = 80;
    const BIG_BOMB         = 81;
    const WATER_BOMB       = 82;
    const FIRE_BOMB        = 83;
    const CRYO_BOMB        = 84;
    const NUKE_BOMB        = 85;
    const HELIUM           = 86;
    const BOUNCY_BALL      = 87;
    const BIRCH_SEEDS      = 88;
    const BIRCH_LEAVES     = 89;
    const BIRCH_BABY_LEAVES= 90;
    const BIRCH_WOOD       = 91;
    const DEAD_BIRCH       = 92;
    // Simulation constants
    let speed               = 1;
    const simulationTimeStep= 0.1;
    const vaporTransformThreshold= 4;
    const diffusionRate     = 0.3;
    const fireTemperature   = 600;
    const burnDuration      = 1.5;
    const burnToAshChance   = 0.25;
    const fireLifetime      = 2.0;
    const glassTemp         = 1700;
    const bombExplosionRadius= 3;
    const wetDirtEvapTemp   = 100;
    const doughBakeTemp     = 120;
    const breadBurnTemp     = 1000;
    const sparkLifetime     = 0.5;
    const burningGasDuration= 2.0;
    const burnDurationCoal      = 10.0;
    const burnDurationCoalLump  = 5.0;
    // Conduction rates
    const conductionRates = {
      // Base elements
      [EMPTY]: 0,
      [WALL]: 0, // I bloody broke wall ):
      [ERASER]: 0,
      
      // Metals (highest conductivity)
      [COPPER]: 4.0,       // Copper has excellent conductivity
      [CHARGED_COPPER]: 4.0,
      [CHARGED_DOWN_COPPER]: 4.0,
      [STEEL]: 1.5,        // Steel conducts well but less than copper
      
      // Liquids (moderate conductivity)
      [WATER]: 0.6,        // Water conducts heat moderately well
      [LAVA]: 0.8,         // Molten rock conducts better than water
      [MOLTEN_SLAG]: 0.7,
      [ACID]: 0.5,
      [OIL]: 0.3,          // Oil conducts less than water
      
      // Gases (poor conductivity but good convection)
      [WATER_VAPOR]: 0.2,  // Gases conduct poorly but move
      [CLOUD]: 0.15,
      [SMOKE]: 0.1,
      [GAS]: 0.15,
      [BURNING_GAS]: 0.2,
      [CARBON_DIOXIDE]: 0.15,
      [OXYGEN]: 0.15,
      [HELIUM]: 0.25,      // Helium conducts better than other gases
      [ACID_STEAM]: 0.2,
      [ACID_CLOUD]: 0.15,
      
      // Solids (varied conductivity)
      [STONE]: 0.3,
      [BASALT]: 0.25,
      [OBSIDIAN]: 0.2,
      [GLASS]: 0.15,       // Glass is a poor conductor
      [SAND]: 0.2,         // Sand conducts poorly
      [WET_SAND]: 0.3,     // Wet sand conducts better than dry
      [DIRT]: 0.15,
      [WET_DIRT]: 0.25,
      [COBBLESTONE]: 0.25,
      [ICE]: 0.4,          // Ice conducts better than water
      
      // Organic materials (poor conductors)
      [WOOD]: 0.12,
      [BURNING_WOOD]: 0.15,
      [ROOT]: 0.1,
      [BURNING_ROOT]: 0.15,
      [DEAD_ROOT]: 0.08,
      [WHEAT]: 0.08,
      [WHEAT_SEEDS]: 0.07,
      [FLOUR]: 0.05,
      [DOUGH]: 0.1,
      [BREAD]: 0.08,
      [GRASS]: 0.07,
      [OAK_SEEDS]: 0.07,
      [OAK_LEAVES]: 0.08,
      [OAK_BABY_LEAVES]: 0.07,
      [DEAD_OAK]: 0.06,
      [BIRCH_SEEDS]: 0.07,
      [BIRCH_LEAVES]: 0.08,
      [BIRCH_BABY_LEAVES]: 0.07,
      [BIRCH_WOOD]: 0.11,
      [DEAD_BIRCH]: 0.06,
      [DEAD_PLANT]: 0.06,
      [BURNING_LEAVES]: 0.12,
      [BURNING_ORGANIC]: 0.15,
      [MEAT]: 0.3,         // Meat conducts better due to water content
      [COOKED_MEAT]: 0.2,  // Cooked meat conducts less as water evaporates
      
      // Special elements
      [FIRE]: 0.8,         // Fire transfers heat well
      [ASH]: 0.05,         // Ash is an insulator
      [COAL]: 0.2,
      [COAL_LUMP]: 0.15,
      [BURNING_COAL]: 0.4,
      [BURNING_COAL_LUMP]: 0.35,
      [THERMITE]: 0.3,
      [BURNING_THERMITE]: 1.2,  // Thermite reaction transfers heat extremely well
      [SLIME]: 0.3,
      
      // Electronic components
      [COOLER]: 1.0,       // Designed to transfer heat
      [HEATER]: 1.0,
      [HEAT_SEPARATOR]: 0.4,
      [CHARGED_HEAT_SEPARATOR]: 0.4,
      [CHARGED_DOWN_HEAT_SEPARATOR]: 0.4,
      [INPUT]: 0.3,
      [CHARGED_INPUT]: 0.3,
      [OUTPUT]: 0.3,
      [CHARGED_OUTPUT]: 0.3,
      [NOT_GATE]: 0.3,
      [AND_GATE]: 0.3,
      [BLOCKER]: 0.3,
      [CHARGED_BLOCKER]: 0.3,
      [CLONER]: 0.3,
      
      // Explosives (low conductivity for safety)
      [BOMB]: 0.1,
      [BIG_BOMB]: 0.1,
      [WATER_BOMB]: 0.1,
      [FIRE_BOMB]: 0.1,
      [CRYO_BOMB]: 0.1,
      [NUKE_BOMB]: 0.1,
      
      // Miscellaneous
      [SPARK]: 0.3,
      [BOUNCY_BALL]: 0.2
    };
    const heatCapacities = {
      // Base elements
      [EMPTY]: 1,
      [WALL]: 1000,
      [ERASER]: 1,
      
      // Metals (low heat capacity - heat up/cool quickly)
      [COPPER]: 0.4,       // Copper heats up quickly
      [CHARGED_COPPER]: 0.4,
      [CHARGED_DOWN_COPPER]: 0.4,
      [STEEL]: 0.5,        // Steel takes a bit more energy to heat
      
      // Liquids (high heat capacity - store heat well)
      [WATER]: 4.0,        // Water has very high heat capacity
      [LAVA]: 1.0,         // Molten rock has lower capacity than water
      [MOLTEN_SLAG]: 1.0,
      [ACID]: 3.0,
      [OIL]: 2.0,          // Oil has lower capacity than water
      
      // Gases (moderate heat capacity)
      [WATER_VAPOR]: 2.0,  // Steam holds less heat than water
      [CLOUD]: 2.0,
      [SMOKE]: 1.0,
      [GAS]: 1.0,
      [BURNING_GAS]: 0.8,
      [CARBON_DIOXIDE]: 0.8,
      [OXYGEN]: 0.9,
      [HELIUM]: 5.0,       // Helium has extremely high heat capacity
      [ACID_STEAM]: 2.0,
      [ACID_CLOUD]: 2.0,
      
      // Solids (varied heat capacity)
      [STONE]: 0.8,
      [BASALT]: 0.8,
      [OBSIDIAN]: 0.8,
      [GLASS]: 0.8,
      [SAND]: 0.8,
      [WET_SAND]: 1.2,     // Water increases heat capacity
      [DIRT]: 0.9,
      [WET_DIRT]: 1.3,
      [COBBLESTONE]: 0.8,
      [ICE]: 2.0,          // Ice has high heat capacity
      
      // Organic materials (moderate heat capacity)
      [WOOD]: 1.8,
      [BURNING_WOOD]: 1.0,
      [ROOT]: 1.8,
      [BURNING_ROOT]: 1.0,
      [DEAD_ROOT]: 1.5,
      [WHEAT]: 1.5,
      [WHEAT_SEEDS]: 1.2,
      [FLOUR]: 1.2,
      [DOUGH]: 2.0,        // Water content increases capacity
      [BREAD]: 1.5,
      [GRASS]: 1.5,
      [OAK_SEEDS]: 1.2,
      [OAK_LEAVES]: 1.5,
      [OAK_BABY_LEAVES]: 1.5,
      [DEAD_OAK]: 1.2,
      [BIRCH_SEEDS]: 1.2,
      [BIRCH_LEAVES]: 1.5,
      [BIRCH_BABY_LEAVES]: 1.5,
      [BIRCH_WOOD]: 1.7,
      [DEAD_BIRCH]: 1.2,
      [DEAD_PLANT]: 1.2,
      [BURNING_LEAVES]: 0.8,
      [BURNING_ORGANIC]: 0.8,
      [MEAT]: 3.0,         // High water content means high capacity
      [COOKED_MEAT]: 1.5,  // Less water, lower capacity
      
      // Special elements
      [FIRE]: 0.2,         // Fire changes temperature quickly
      [ASH]: 0.8,
      [COAL]: 0.8,
      [COAL_LUMP]: 0.8,
      [BURNING_COAL]: 0.5,
      [BURNING_COAL_LUMP]: 0.5,
      [THERMITE]: 0.8,
      [BURNING_THERMITE]: 0.5,
      [SLIME]: 2.5,        // High water content
      
      // Electronic components (moderate capacity)
      [COOLER]: 1.0,
      [HEATER]: 1.0,
      [HEAT_SEPARATOR]: 1.0,
      [CHARGED_HEAT_SEPARATOR]: 1.0,
      [CHARGED_DOWN_HEAT_SEPARATOR]: 1.0,
      [INPUT]: 1.0,
      [CHARGED_INPUT]: 1.0,
      [OUTPUT]: 1.0,
      [CHARGED_OUTPUT]: 1.0,
      [NOT_GATE]: 1.0,
      [AND_GATE]: 1.0,
      [BLOCKER]: 1.0,
      [CHARGED_BLOCKER]: 1.0,
      [CLONER]: 1.0,
      
      // Explosives
      [BOMB]: 0.8,
      [BIG_BOMB]: 0.8,
      [WATER_BOMB]: 0.8,
      [FIRE_BOMB]: 0.8,
      [CRYO_BOMB]: 0.8,
      [NUKE_BOMB]: 0.8,
      
      // Miscellaneous
      [SPARK]: 0.2,
      [BOUNCY_BALL]: 1.5
    };
    // New Constants:
    // Add this after your element constants (SAND, WATER, etc.)
    const elementBaseColors = {
      // Basic elements
      [EMPTY]: '#000000',
      [SAND]: '#f4a460',
      [WALL]: '#666666',
      [WATER]: '#1e90ff',
      [LAVA]: '#ff4500',
      [STONE]: '#808080',
      [ERASER]: '#ffaaaa',
      
      // Gases and vapors
      [WATER_VAPOR]: '#e0e0e0',
      [CLOUD]: '#ffffff',
      [SMOKE]: '#666666',
      [GAS]: 'rgba(200,200,200,0.2)',
      [BURNING_GAS]: '#ff6666',
      [CARBON_DIOXIDE]: 'rgba(128,128,128,0.2)',
      [OXYGEN]: 'rgba(200,230,255,0.2)',
      [HELIUM]: '#e6f7ff',
      [ACID_STEAM]: '#98FB98',
      [ACID_CLOUD]: '#98FB98',
      
      // Rocks and minerals
      [BASALT]: '#555555',
      [OBSIDIAN]: '#333333',
      [MOLTEN_SLAG]: '#ff6600',
      [COBBLESTONE]: '#808080',
      [GLASS]: '#c2e9fb',
      
      // Metals
      [COPPER]: '#b87333',
      [STEEL]: '#aaaaaa',
      [CHARGED_COPPER]: '#ff8c00',
      [CHARGED_DOWN_COPPER]: '#cc6600',
      
      // Temperature elements
      [ICE]: '#cceeff',
      [FIRE]: '#ffcc00',
      [COOLER]: '#3399ff',
      [HEATER]: '#ff3333',
      
      // Wood and plants
      [WOOD]: '#3B220E',
      [BURNING_WOOD]: '#5a3310',
      [ROOT]: '#4a3a2f',
      [BURNING_ROOT]: '#ff4500',
      [DEAD_ROOT]: '#555555',
      [WHEAT_SEEDS]: '#bca136',
      [WHEAT]: '#c2b280',
      [OAK_SEEDS]: '#556b2f',
      [OAK_LEAVES]: '#228b22',
      [OAK_BABY_LEAVES]: '#32cd32',
      [DEAD_OAK]: '#8b4513',
      [BIRCH_SEEDS]: '#6b8e23',
      [BIRCH_LEAVES]: '#32cd32',
      [BIRCH_BABY_LEAVES]: '#7cfc00',
      [BIRCH_WOOD]: '#f5f5f5',
      [DEAD_BIRCH]: '#a9a9a9',
      [GRASS]: '#00aa00',
      [DEAD_PLANT]: '#555555',
      [BURNING_LEAVES]: '#a0522d',
      
      // Food and cooking
      [FLOUR]: '#f5f5dc',
      [DOUGH]: '#d2b48c',
      [BREAD]: '#f4c986',
      [MEAT]: '#FF6B6B',
      [COOKED_MEAT]: '#8B4513',
      
      // Earth elements
      [DIRT]: '#7B5E42',
      [WET_DIRT]: '#4d2e12',
      [WET_SAND]: '#d2a679',
      [ASH]: '#444444',
      
      // Special elements
      [BURNING_ORGANIC]: '#6a3400',
      [SPARK]: '#ffdd00',
      [ACID]: '#90EE90',
      [SLIME]: '#006400',
      [OIL]: '#2F4F4F',
      [BIRD]: '#B8860B',
      
      // Coal and combustibles
      [COAL]: '#202020',
      [COAL_LUMP]: '#303030',
      [BURNING_COAL]: '#ff4500',
      [BURNING_COAL_LUMP]: '#ff4500',
      [THERMITE]: '#AA4444',
      [BURNING_THERMITE]: '#ffc31f',
      
      // Electronic components
      [HEAT_SEPARATOR]: '#ffef96',
      [CHARGED_HEAT_SEPARATOR]: '#ffe033',
      [CHARGED_DOWN_HEAT_SEPARATOR]: '#ffd700',
      [INPUT]: '#646464',
      [CHARGED_INPUT]: '#ffff77',
      [OUTPUT]: '#3636ff',
      [CHARGED_OUTPUT]: '#8888ff',
      [NOT_GATE]: '#a15050',
      [AND_GATE]: '#405050',
      [BLOCKER]: '#856fa8',
      [CHARGED_BLOCKER]: '#9b50a3',
      [CLONER]: '#cc00cc',
      
      // Explosives
      [BOMB]: '#ff0000',
      [BIG_BOMB]: '#ff3333',
      [WATER_BOMB]: '#3366ff',
      [FIRE_BOMB]: '#ff6600',
      [CRYO_BOMB]: '#00ccff',
      [NUKE_BOMB]: '#33cc33',
      
      // Special objects
      [BOUNCY_BALL]: '#ff5599'
    };
    // Global arrays for grid state
    let grid = [], temp = [], moved = [];
    let vaporLife = [], cloudLife = [];
    let fireLife = [], smokeLife = [];
    let burningWoodTime = [];
    let wheatHeight = [], wheatMaxHeight = [], seedGrowthTime = [], rootLife = [];
    let sparkLife = [], sparkTimer = [];
    let smokeMaxLife = [], cloudMaxLife = [];
    let branchLevel = [], branchLen = [], branchMaxArr = [], branchSubCount = [];
    let branchDirX = [], branchDirY = [];
    let oakTreeGrowthTime = [], oakTreeHeight = [], oakTreeMaxHeight = [];
    let oakTreeRootTimer = [], oakTreeRootDepth = [], oakTreeRootMax = [];
    let grassStage = [];
    let burningGasTime = [];
    let chargedStateTime = [];
    // Bird movement arrays
    let birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
    let birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballVelocityX = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballVelocityY = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // New global variable: stroke thickness (in cells)
    let strokeThickness = 1;

    // Game version updated to 0.5.0a
    const currentGameVersion = "0.7.1c";

    // Add these right after the GRID_SIZE declaration and before any functions
    // Global lighting system variables
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    
    // Graphics settings
    window.isVariatedColorsEnabled = true; // Default to enabled
    window.isDspleEnabled = false; // DSPLE disabled by default
    window.lightSources = []; // Array to store light sources
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };
    
    function getTemperatureAdjustedColor(baseColor, temperature, elementType, x, y) {
      // Parse the base color (handles both hex and rgb formats)
      let r, g, b;
      
      if (baseColor.startsWith('#')) {
        // Handle hex color
        const hex = baseColor.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
      } else if (baseColor.startsWith('rgb')) {
        // Handle rgb color
        const matches = baseColor.match(/\d+/g);
        r = parseInt(matches[0]);
        g = parseInt(matches[1]);
        b = parseInt(matches[2]);
      } else {
        // Default fallback
        return baseColor;
      }
      
      // Adjust color based on temperature
      // Hot: more red/yellow, Cold: more blue
      if (temperature > 100) {
        // Hot - shift toward red/yellow
        const factor = Math.min((temperature - 100) / 900, 1); // Max effect at 1000Â°C
        r = Math.min(r + (255 - r) * factor * 0.7, 255);
        g = Math.max(g - g * factor * 0.3, 0);
        b = Math.max(b - b * factor * 0.5, 0);
      } else if (temperature < 0) {
        // Cold - shift toward blue
        const factor = Math.min(Math.abs(temperature) / 100, 1); // Max effect at -100Â°C
        r = Math.max(r - r * factor * 0.5, 0);
        g = Math.max(g - g * factor * 0.3, 0);
        b = Math.min(b + (255 - b) * factor * 0.5, 255);
      }
      
      // Only apply color variations if the feature is enabled
      if (window.isVariatedColorsEnabled) {
        // Apply stored color variation for non-liquid elements
        // For liquids, continue to use random variations
        const liquidElements = [WATER, LAVA, ACID, OIL, MOLTEN_SLAG];
        
        if (liquidElements.includes(elementType)) {
          // For liquids, add a new random variation each time
          const variation = 0.05;
          r = Math.min(Math.max(Math.floor(r * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
          g = Math.min(Math.max(Math.floor(g * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
          b = Math.min(Math.max(Math.floor(b * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
        } else if (colorVariations[y][x]) {
          // For other elements, use the stored variation
          r = Math.min(Math.max(Math.floor(r * colorVariations[y][x].r), 0), 255);
          g = Math.min(Math.max(Math.floor(g * colorVariations[y][x].g), 0), 255);
          b = Math.min(Math.max(Math.floor(b * colorVariations[y][x].b), 0), 255);
        }
      }
      
      return `rgb(${r}, ${g}, ${b})`;
    }

    // Add this function to parse URL parameters
function getUrlParameters() {
  const params = {};
  const queryString = window.location.search.substring(1);
  const pairs = queryString.split('&');
  
  for (let i = 0; i < pairs.length; i++) {
    if(!pairs[i]) continue;
    const pair = pairs[i].split('=');
    params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  
  return params;
}

    // DSPLE (Dabicco Shader-Pixel Lighting Engine) functions
    let lightingCanvas = null;
    let lightingContext = null;
    let previousLightMap = null; // Store previous frame's light map for smooth transitions
    let lightingAnimationFrame = null; // Store animation frame ID
    
    // Initialize the DSPLE lighting engine
    function initDspleLightingEngine() {
      // Create lighting canvas overlay if it doesn't exist
      if (!lightingCanvas) {
        lightingCanvas = document.createElement('canvas');
        lightingCanvas.id = 'lightingCanvas';
        lightingCanvas.style.position = 'absolute';
        lightingCanvas.style.top = '0';
        lightingCanvas.style.left = '0';
        lightingCanvas.style.width = '100%';
        lightingCanvas.style.height = '100%';
        lightingCanvas.style.pointerEvents = 'none'; // Allow clicks to pass through
        lightingCanvas.style.zIndex = '1'; // Above the grid but below UI
        lightingCanvas.style.mixBlendMode = 'screen'; // Light blend mode
        lightingCanvas.style.imageRendering = 'pixelated'; // Ensure crisp pixel edges
        
        // Add the canvas to the grid container
        gridContainer.appendChild(lightingCanvas);
        
        // Get the context for drawing
        lightingContext = lightingCanvas.getContext('2d');
      }
      
      // Update canvas dimensions to match the grid
      updateLightingCanvasDimensions();
      
      // Initialize previous light map based on current grid size
      resetLightMap();
      
      // Start the lighting render loop
      lightingAnimationFrame = requestAnimationFrame(renderLighting);
      
      // Add resize observer to handle stage size changes
      if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver(entries => {
          if (window.isDspleEnabled) {
            updateLightingCanvasDimensions();
            resetLightMap();
          }
        });
        resizeObserver.observe(gridContainer);
      }
    }
    
    // Update lighting canvas dimensions to match the grid exactly
    function updateLightingCanvasDimensions() {
      if (lightingCanvas) {
        const gridRect = gridContainer.getBoundingClientRect();
        // Set the canvas size to exactly match the grid container
        lightingCanvas.width = gridRect.width;
        lightingCanvas.height = gridRect.height;
        
        // Ensure the canvas is positioned correctly
        lightingCanvas.style.top = '0';
        lightingCanvas.style.left = '0';
        lightingCanvas.style.width = '100%';
        lightingCanvas.style.height = '100%';
      }
    }
    
    // Reset the light map based on current grid size
    function resetLightMap() {
      previousLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    }
    
    // Clean up the DSPLE lighting engine
    function cleanupDspleLightingEngine() {
      if (lightingCanvas) {
        // Cancel animation frame if active
        if (lightingAnimationFrame) {
          cancelAnimationFrame(lightingAnimationFrame);
          lightingAnimationFrame = null;
        }
        
        // Remove the lighting canvas
        gridContainer.removeChild(lightingCanvas);
        lightingCanvas = null;
        lightingContext = null;
        previousLightMap = null;
      }
    }
    
    // Identify light sources in the grid
    function identifyLightSources() {
      // Clear existing light sources
      window.lightSources = [];
      
      // Define elements that emit light
      const lightEmitters = {
        [FIRE]: { intensity: 1.0, radius: 8, color: '#ffcc00' },
        [LAVA]: { intensity: 0.8, radius: 6, color: '#ff4500' },
        [BURNING_WOOD]: { intensity: 0.7, radius: 5, color: '#ff6600' },
        [BURNING_LEAVES]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_ORGANIC]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_ROOT]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_COAL]: { intensity: 0.9, radius: 7, color: '#ff4500' },
        [BURNING_COAL_LUMP]: { intensity: 1.0, radius: 8, color: '#ff4500' },
        [BURNING_THERMITE]: { intensity: 1.2, radius: 10, color: '#ffff00' },
        [BURNING_GAS]: { intensity: 0.5, radius: 4, color: '#ff6666' },
        [CHARGED_COPPER]: { intensity: 0.4, radius: 3, color: '#ff8c00' },
        [CHARGED_DOWN_COPPER]: { intensity: 0.3, radius: 2, color: '#cc6600' },
        [SPARK]: { intensity: 0.9, radius: 5, color: '#ffdd00' },
        [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, radius: 3, color: '#ffe033' },
        [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, radius: 2, color: '#ffd700' },
        [CHARGED_INPUT]: { intensity: 0.4, radius: 3, color: '#ffff77' },
        [CHARGED_OUTPUT]: { intensity: 0.4, radius: 3, color: '#8888ff' },
        [MOLTEN_SLAG]: { intensity: 0.8, radius: 6, color: '#ff4500' }
      };
      
      // Scan the grid for light sources
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          
          // Check if this element is a light emitter
          if (lightEmitters[element]) {
            const emitter = lightEmitters[element];
            
            // Get temperature for intensity variation
            const temperature = temp[y][x] || 20;
            let intensityMod = 1.0;
            
            // Increase intensity with temperature for fire elements
            if ([FIRE, BURNING_WOOD, BURNING_LEAVES, BURNING_ORGANIC, BURNING_COAL, BURNING_COAL_LUMP, BURNING_THERMITE].includes(element)) {
              intensityMod = Math.min(1.0 + (temperature - 500) / 1000, 2.0);
            }
            
            // Add to light sources
            window.lightSources.push({
              x: x,
              y: y,
              intensity: emitter.intensity * intensityMod,
              radius: emitter.radius,
              color: emitter.color
            });
          }
        }
      }
    }
    
    // Render the lighting effects
    function renderLighting() {
      // Only continue if DSPLE is enabled
      if (!window.isDspleEnabled || !lightingContext) {
        return;
      }
      
      // Identify light sources
      identifyLightSources();
      
      // Clear the canvas
      lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
      
      // Calculate cell size
      const cellSize = lightingCanvas.width / GRID_SIZE;
      
      // Create a grid-based lighting map for the current frame
      const currentLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // For each light source, calculate its contribution to each cell
      for (const source of window.lightSources) {
        // Parse the color
        let r, g, b;
        if (source.color.startsWith('#')) {
          const hex = source.color.substring(1);
          r = parseInt(hex.substring(0, 2), 16);
          g = parseInt(hex.substring(2, 4), 16);
          b = parseInt(hex.substring(4, 6), 16);
        } else {
          // Default to orange if color format is unknown
          r = 255;
          g = 165;
          b = 0;
        }
        
        // Calculate the light's influence area
        const radius = Math.ceil(source.radius);
        // Reduce intensity by 40% to make lighting less intense
        const intensity = source.intensity * 0.6;
        
        // Loop through cells in the influence area
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            const nx = source.x + dx;
            const ny = source.y + dy;
            
            // Skip if out of bounds
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
            
            // Calculate distance (in cells) from light source
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // Skip if outside the radius
            if (distance > radius) continue;
            
            // More realistic voxel-based lighting with inverse square law falloff
            // Use a steeper falloff curve for more realistic light propagation
            const falloff = Math.pow(1 - Math.min(distance / radius, 1), 2);
            const cellIntensity = intensity * falloff;
            
            // Initialize the cell's light value if needed
            if (!currentLightMap[ny][nx]) {
              currentLightMap[ny][nx] = { r: 0, g: 0, b: 0, a: 0 };
            }
            
            // Add this light's contribution (additive blending)
            // Reduce RGB values for less intensity
            currentLightMap[ny][nx].r += r * cellIntensity;
            currentLightMap[ny][nx].g += g * cellIntensity;
            currentLightMap[ny][nx].b += b * cellIntensity;
            currentLightMap[ny][nx].a = Math.min(currentLightMap[ny][nx].a + cellIntensity * 0.3, 0.7); // Reduced alpha cap
          }
        }
      }
      
      // Create the final light map with smooth transitions from previous frame
      const finalLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Blend current frame with previous frame for smooth transitions
      const transitionSpeed = 0.2; // Lower = slower transitions (0.2 = 20% change per frame)
      
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const current = currentLightMap[y][x];
          const previous = previousLightMap[y][x];
          
          // If no light in current or previous frame, skip
          if (!current && !previous) continue;
          
          // Initialize final light map cell
          finalLightMap[y][x] = { r: 0, g: 0, b: 0, a: 0 };
          
          // If there's light in the current frame
          if (current) {
            if (previous) {
              // Blend with previous frame for smooth transition
              finalLightMap[y][x].r = previous.r + (current.r - previous.r) * transitionSpeed;
              finalLightMap[y][x].g = previous.g + (current.g - previous.g) * transitionSpeed;
              finalLightMap[y][x].b = previous.b + (current.b - previous.b) * transitionSpeed;
              finalLightMap[y][x].a = previous.a + (current.a - previous.a) * transitionSpeed;
            } else {
              // Fade in new light
              finalLightMap[y][x].r = current.r * transitionSpeed;
              finalLightMap[y][x].g = current.g * transitionSpeed;
              finalLightMap[y][x].b = current.b * transitionSpeed;
              finalLightMap[y][x].a = current.a * transitionSpeed;
            }
          } else if (previous) {
            // Fade out disappearing light
            finalLightMap[y][x].r = previous.r * (1 - transitionSpeed);
            finalLightMap[y][x].g = previous.g * (1 - transitionSpeed);
            finalLightMap[y][x].b = previous.b * (1 - transitionSpeed);
            finalLightMap[y][x].a = previous.a * (1 - transitionSpeed);
          }
        }
      }
      
      // Store the final light map for the next frame
      previousLightMap = finalLightMap;
      
      // Render the final light map to the canvas
      lightingContext.globalCompositeOperation = 'lighter';
      
      // Simple approach - just draw directly to match the grid exactly
      
      // First, clear the canvas with a fully transparent background
      lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
      
      // Draw each cell with exact matching to the grid cells
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const light = finalLightMap[y][x];
          if (light && light.a > 0.03) { // Lower threshold to catch fading lights
            // Clamp RGB values
            const r = Math.min(Math.max(Math.floor(light.r), 0), 255);
            const g = Math.min(Math.max(Math.floor(light.g), 0), 255);
            const b = Math.min(Math.max(Math.floor(light.b), 0), 255);
            const a = light.a;
            
            // Draw a full square for this cell with exact positioning
            lightingContext.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
            
            // Use the exact same cell size and position calculation as the main grid
            lightingContext.fillRect(
              x * cellSize, 
              y * cellSize, 
              cellSize, 
              cellSize
            );
          }
        }
      }
      
      // Continue the render loop
      lightingAnimationFrame = requestAnimationFrame(renderLighting);
    }
    
    // Function to reassign color variations to all cells
    function reassignColorVariations() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] !== EMPTY) {
            // Initialize color variation for this element
            const variation = 0.05;
            colorVariations[y][x] = {
              r: 1 + (Math.random() * variation * 2 - variation),
              g: 1 + (Math.random() * variation * 2 - variation),
              b: 1 + (Math.random() * variation * 2 - variation)
            };
          }
        }
      }
      renderGrid(); // Re-render the grid with new variations
    }
    
    // Function to initialize the grid based on GRID_SIZE.
    function initGrid(newSize) {
      GRID_SIZE = newSize;
      // Update grid DOM: set grid template columns/rows according to new size.
      gridContainer.innerHTML = "";
      gridContainer.appendChild(hoverOverlay);
      gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.style.gridTemplateRows = `repeat(${GRID_SIZE}, 1fr)`;
      
      // Reset all arrays
      grid = [];
      temp = [];
      moved = [];
      vaporLife = [];
      cloudLife = [];
      fireLife = [];
      smokeLife = [];
      burningWoodTime = [];
      wheatHeight = [];
      wheatMaxHeight = [];
      seedGrowthTime = [];
      rootLife = [];
      sparkLife = [];
      sparkTimer = [];
      smokeMaxLife = [];
      cloudMaxLife = [];
      branchLevel = [];
      branchLen = [];
      branchMaxArr = [];
      branchSubCount = [];
      branchDirX = [];
      branchDirY = [];
      oakTreeGrowthTime = [];
      oakTreeHeight = [];
      oakTreeMaxHeight = [];
      oakTreeRootTimer = [];
      oakTreeRootDepth = [];
      oakTreeRootMax = [];
      grassStage = [];
      burningGasTime = [];
      chargedStateTime = [];
      
      // Reset physics arrays
      ballVelocityX = [];
      ballVelocityY = [];
      
      // Reset color variations
      colorVariations = [];
      
      // Reset lighting arrays
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Initialize bird arrays
      birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
      birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

      cells.length = 0;
      for (let y = 0; y < GRID_SIZE; y++) {
        let row = [], trow = [], mrow = [];
        let vrow = [], crow = [], frow = [], srow = [], bwrow = [];
        let wH = [], wMH = [], sGT = [], rLifeRow = [];
        let spLifeRow = [], spTimerRow = [];
        let smaxrow = [], cmaxrow = [];
        let bLevel = [], bLen = [], bMax = [], bSub = [], bDirXrow = [], bDirYrow = [];
        let otGrowth = [], otHeight = [], otMaxHeight = [];
        let otRootTimer = [], otRootDepth = [], otRootMax = [];
        let grassRow = [];
        let burnGasRow = [];
        let cdtRow = [];
        let bVelX = [], bVelY = [];
        let colorVarRow = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          row.push(EMPTY);
          trow.push(null);
          mrow.push(false);
          vrow.push(0);
          crow.push(0);
          frow.push(0);
          srow.push(0);
          bwrow.push(0);
          wH.push(0);
          wMH.push(0);
          sGT.push(0);
          rLifeRow.push(0);
          spLifeRow.push(0);
          spTimerRow.push(0);
          smaxrow.push(1.0 + 2.0 * Math.random());
          cmaxrow.push(5.0 + 5.0 * Math.random());
          bLevel.push(-1);
          bLen.push(0);
          bMax.push(0);
          bSub.push(-1);
          bDirXrow.push(0);
          bDirYrow.push(0);
          otGrowth.push(0);
          otHeight.push(0);
          otMaxHeight.push(0);
          otRootTimer.push(0);
          otRootDepth.push(0);
          otRootMax.push(0);
          grassRow.push(1);
          burnGasRow.push(0);
          cdtRow.push(0);
          bVelX.push(0);
          bVelY.push(0);
          colorVarRow.push(null);
        }
        grid.push(row);
        temp.push(trow);
        moved.push(mrow);
        vaporLife.push(vrow);
        cloudLife.push(crow);
        fireLife.push(frow);
        smokeLife.push(srow);
        burningWoodTime.push(bwrow);
        wheatHeight.push(wH);
        wheatMaxHeight.push(wMH);
        seedGrowthTime.push(sGT);
        rootLife.push(rLifeRow);
        sparkLife.push(spLifeRow);
        sparkTimer.push(spTimerRow);
        smokeMaxLife.push(smaxrow);
        cloudMaxLife.push(cmaxrow);
        branchLevel.push(bLevel);
        branchLen.push(bLen);
        branchMaxArr.push(bMax);
        branchSubCount.push(bSub);
        branchDirX.push(bDirXrow);
        branchDirY.push(bDirYrow);
        oakTreeGrowthTime.push(otGrowth);
        oakTreeHeight.push(otHeight);
        oakTreeMaxHeight.push(otMaxHeight);
        oakTreeRootTimer.push(otRootTimer);
        oakTreeRootDepth.push(otRootDepth);
        oakTreeRootMax.push(otRootMax);
        grassStage.push(grassRow);
        burningGasTime.push(burnGasRow);
        chargedStateTime.push(cdtRow);
        ballVelocityX.push(bVelX);
        ballVelocityY.push(bVelY);
        colorVariations.push(colorVarRow);
        // Create cell divs.
        let rowOfCells = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.id = `cell-${x}-${y}`;
          gridContainer.appendChild(cell);
          rowOfCells.push(cell);
        }
        cells.push(rowOfCells);
      }
      
      // Reinitialize lighting arrays when grid size changes
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    }
    /***************************************
     * DOM
     ***************************************/
    const gridContainer = document.getElementById('grid');
    const hoverOverlay = document.getElementById('hoverOverlay');
    const toolElements = document.getElementsByClassName('tool');
    const speedSlider = document.getElementById('speed');
    const speedValueDisplay = document.getElementById('speedValue');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const hudTemp = document.getElementById('hudTemp');
    const hudElem = document.getElementById('hudElem');
    const hudFPS = document.getElementById('hudFPS');
    const toolSearch = document.getElementById('toolSearch');
    const toolbar = document.getElementById('toolbar');
    const categoryButtons = document.querySelectorAll('#categoryMenu button');
    let activeCategory = 'all';
    const cells = [];
    // The initGrid function will create the cells.
    initGrid(50); // Default stage size 50x50x50
    let currentTool = SAND;
    function selectTool(el) {
      Array.from(toolElements).forEach(t => t.classList.remove('selected'));
      el.classList.add('selected');
      const name = el.getAttribute('data-tool');
      switch (name) {
        case "eraser": currentTool = ERASER; break;
        case "sand": currentTool = SAND; break;
        case "wall": currentTool = WALL; break;
        case "water": currentTool = WATER; break;
        case "lava": currentTool = LAVA; break;
        case "stone": currentTool = STONE; break;
        case "water-vapor": currentTool = WATER_VAPOR; break;
        case "copper": currentTool = COPPER; break;
        case "steel": currentTool = STEEL; break;
        case "ice": currentTool = ICE; break;
        case "wood": currentTool = WOOD; break;
        case "fire": currentTool = FIRE; break;
        case "smoke": currentTool = SMOKE; break;
        case "ash": currentTool = ASH; break;
        case "glass": currentTool = GLASS; break;
        case "bomb": currentTool = BOMB; break;
        case "dirt": currentTool = DIRT; break;
        case "wet-dirt": currentTool = WET_DIRT; break;
        case "wheat-seeds": currentTool = WHEAT_SEEDS; break;
        case "flour": currentTool = FLOUR; break;
        case "dough": currentTool = DOUGH; break;
        case "bread": currentTool = BREAD; break;
        case "plant-root": currentTool = ROOT; break;
        case "spark": currentTool = SPARK; break;
        case "oak-seeds": currentTool = OAK_SEEDS; break;
        case "grass": currentTool = GRASS; break;
        case "gas": currentTool = GAS; break;
        case "cooler": currentTool = COOLER; break;
        case "heater": currentTool = HEATER; break;
        case "heat-separator": currentTool = HEAT_SEPARATOR; break;
        case "input": currentTool = INPUT; break;
        case "output": currentTool = OUTPUT; break;
        case "not-gate": currentTool = NOT_GATE; break;
        case "and-gate": currentTool = AND_GATE; break;
        case "blocker": currentTool = BLOCKER; break;
        case "cloner": currentTool = CLONER; break;
        case "coal": currentTool = COAL; break;
        case "coal-lump": currentTool = COAL_LUMP; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "heat": currentTool = TOOL_HEAT; break;
        case "cool": currentTool = TOOL_COOL; break;
        case "cook": currentTool = TOOL_COOK; break;
        case "mix": currentTool = TOOL_MIX; break;
        case "move": currentTool = TOOL_MOVE; break;
        case "sponge": currentTool = TOOL_SPONGE; break;
        case "extinguish": currentTool = TOOL_EXTINGUISH; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "carbon-dioxide": currentTool = CARBON_DIOXIDE; break;
        case "oxygen": currentTool = OXYGEN; break;
        case "bird": currentTool = BIRD; break;
        case "meat": currentTool = MEAT; break;
        case "cooked-meat": currentTool = COOKED_MEAT; break;
        case "cobblestone": currentTool = COBBLESTONE; break;
        case "oil": currentTool = OIL; break;
        case "big-bomb": currentTool = BIG_BOMB; break;
        case "water-bomb": currentTool = WATER_BOMB; break;
        case "fire-bomb": currentTool = FIRE_BOMB; break;
        case "cryo-bomb": currentTool = CRYO_BOMB; break;
        case "nuke-bomb": currentTool = NUKE_BOMB; break;
        case "helium": currentTool = HELIUM; break;
        case "bouncy-ball": currentTool = BOUNCY_BALL; break;
        case "birch-seeds": currentTool = BIRCH_SEEDS; break;
      }
    }
    Array.from(toolElements).forEach(el => { el.addEventListener('click', () => selectTool(el)); });
    speedSlider.addEventListener('input', e => { speed = parseFloat(e.target.value); speedValueDisplay.textContent = speed.toFixed(2); });
    clearAllBtn.addEventListener('click', () => { for (let y = 0; y < GRID_SIZE; y++) { for (let x = 0; x < GRID_SIZE; x++) { eraseCell(x, y); } } });
    let isLeftMouseDown = false, isRightMouseDown = false;
    let hoveredX = null, hoveredY = null;
    function onMouseDown(e) {
      e.preventDefault();
      if (e.button === 0) isLeftMouseDown = true;
      else if (e.button === 2) isRightMouseDown = true;
    }
    function onMouseUp(e) {
      e.preventDefault();
      if (e.button === 0) isLeftMouseDown = false;
      else if (e.button === 2) isRightMouseDown = false;
    }
    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('mouseleave', () => {
      isLeftMouseDown = false;
      isRightMouseDown = false;
      hoveredX = null; hoveredY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });
    gridContainer.addEventListener('mousemove', e => { const { x, y } = getMousePos(e); hoveredX = x; hoveredY = y; });
    // Listen for scroll (wheel) events to adjust stroke thickness.
    gridContainer.addEventListener('wheel', e => {
      e.preventDefault();
      if (e.deltaY < 0) {
        strokeThickness = Math.min(strokeThickness + 1, 50);
      } else {
        strokeThickness = Math.max(strokeThickness - 1, 1);
      }
    });
    function getMousePos(e) {
      // Use clientWidth to avoid scaling issues.
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let px = Math.floor((e.clientX - rect.left) / cellSize);
      let py = Math.floor((e.clientY - rect.top) / cellSize);
      return { x: Math.max(0, Math.min(GRID_SIZE - 1, px)), y: Math.max(0, Math.min(GRID_SIZE - 1, py)) };
    }
    // Modified spamPlace to place elements over a square area based on strokeThickness.
    function spamPlace() { 
      if (hoveredX === null || hoveredY === null) return; 
      let half = Math.floor(strokeThickness / 2);
      
      // Handle special tools
      if (currentTool >= 100 && currentTool <= 106) {
        if (isLeftMouseDown) {
          for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
            for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
              let x = hoveredX + dx, y = hoveredY + dy;
              if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
              
              switch(currentTool) {
                case 100: // TOOL_HEAT
                  if (temp[y][x] !== null) temp[y][x] = Math.min(temp[y][x] + 50, 3000);
                  break;
                case 101: // TOOL_COOL
                  if (temp[y][x] !== null) temp[y][x] = Math.max(temp[y][x] - 50, -271);
                  break;
                case 102: // TOOL_COOK
                  if (grid[y][x] === DOUGH) {
                    grid[y][x] = BREAD;
                    temp[y][x] = 30;
                  }
                  break;
                case 103: // TOOL_MIX
                  if (Math.random() < 0.5) {
                    let dirs = [[1,0], [-1,0], [0,1], [0,-1]];
                    let dir = dirs[Math.floor(Math.random() * dirs.length)];
                    let nx = x + dir[0], ny = y + dir[1];
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                      let tmpElem = grid[y][x];
                      let tmpTemp = temp[y][x];
                      grid[y][x] = grid[ny][nx];
                      temp[y][x] = temp[ny][nx];
                      grid[ny][nx] = tmpElem;
                      temp[ny][nx] = tmpTemp;
                    }
                  }
                  break;
                case 105: // TOOL_SPONGE
                  if ([BURNING_WOOD, BURNING_ORGANIC, BURNING_LEAVES, ASH, FIRE].includes(grid[y][x])) {
                    eraseCell(x, y);
                  }
                  break;
                case 106: // TOOL_EXTINGUISH
                  if (grid[y][x] === FIRE) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_WOOD) {
                    grid[y][x] = WOOD;
                    temp[y][x] = 20;
                  } else if (grid[y][x] === BURNING_ORGANIC) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_LEAVES) {
                    grid[y][x] = OAK_LEAVES;
                    temp[y][x] = 20;
                  }
                  break;
              }
            }
          }
        }
        return;
      }
      
      // Regular element placement
      for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
        for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
          let x = hoveredX + dx, y = hoveredY + dy;
          if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          if (isLeftMouseDown) {
            placeElementAt(x, y, currentTool);
          } else if (isRightMouseDown) {
            placeElementAt(x, y, ERASER);
          }
        }
      }
    }
    // Update the hover overlay that shows the stroke area.
    function updateHoverOverlay() {
      if (hoveredX === null || hoveredY === null) {
        hoverOverlay.style.display = "none";
        return;
      }
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let half = Math.floor(strokeThickness / 2);
      let startX = (hoveredX - half) * cellSize;
      let startY = (hoveredY - half) * cellSize;
      hoverOverlay.style.display = "block";
      hoverOverlay.style.left = startX + "px";
      hoverOverlay.style.top = startY + "px";
      hoverOverlay.style.width = (strokeThickness * cellSize) + "px";
      hoverOverlay.style.height = (strokeThickness * cellSize) + "px";
    }
    /***************************************
     * PLACEMENT & ERASURE
     ***************************************/
     function placeElementAt(x, y, tool) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      if (grid[y][x] === tool) return;
      if (tool === ERASER) { eraseCell(x, y); return; }
      eraseCell(x, y);
      grid[y][x] = tool;
      switch (tool) {
        case SAND: temp[y][x] = 20; break;
        case WALL: temp[y][x] = 20; break;
        case WATER: temp[y][x] = 20; break;
        case LAVA: temp[y][x] = 1200; break;
        case STONE: temp[y][x] = 20; break;
        case WATER_VAPOR: temp[y][x] = 100; vaporLife[y][x] = 0; break;
        case COPPER: temp[y][x] = 100; break;
        case STEEL: temp[y][x] = 50; break;
        case ICE: temp[y][x] = -5; break;
        case WOOD: temp[y][x] = 20; burningWoodTime[y][x] = 0; break;
        case FIRE: temp[y][x] = fireTemperature; fireLife[y][x] = 0; break;
        case SMOKE: temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); break;
        case BURNING_WOOD: temp[y][x] = 20; break;
        case BURNING_ORGANIC: temp[y][x] = fireTemperature; break;
        case ASH: temp[y][x] = 20; break;
        case GLASS: temp[y][x] = 300; break;
        case BOMB: temp[y][x] = 20; break;
        case DIRT: temp[y][x] = 20; break;
        case WET_DIRT: temp[y][x] = 20; break;
        case WHEAT_SEEDS: temp[y][x] = 20; seedGrowthTime[y][x] = 0; break;
        case FLOUR: temp[y][x] = 20; break;
        case DOUGH: temp[y][x] = 25; break;
        case BREAD: temp[y][x] = 30; break;
        case ROOT: temp[y][x] = 15; break;
        case BURNING_ORGANIC: temp[y][x] = fireTemperature; break;
        case SPARK: temp[y][x] = 20; sparkLife[y][x] = 0; break;
        case CHARGED_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case OAK_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case BIRCH_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case GRASS: temp[y][x] = 20; grassStage[y][x] = 1; break;
        case GAS: temp[y][x] = 20; break;
        case CHARGED_DOWN_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case COOLER: temp[y][x] = 20; break;
        case HEATER: temp[y][x] = 20; break;
        case HEAT_SEPARATOR: temp[y][x] = 20; break;
        case CHARGED_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CHARGED_DOWN_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case INPUT: temp[y][x] = 20; break;
        case CHARGED_INPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case OUTPUT: temp[y][x] = 20; break;
        case CHARGED_OUTPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case NOT_GATE: temp[y][x] = 20; break;
        case AND_GATE: temp[y][x] = 20; break;
        case BLOCKER: temp[y][x] = 20; break;
        case CHARGED_BLOCKER: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CLONER: temp[y][x] = 20; break;
        case COAL: temp[y][x] = 20; break;
        case COAL_LUMP: temp[y][x] = 20; break;
        case THERMITE: temp[y][x] = 20; break;
        case BURNING_THERMITE: temp[y][x] = 3200; break;
        case ACID: temp[y][x] = 20; break;
        case SLIME: temp[y][x] = 20; break;
        case ACID_STEAM: temp[y][x] = 120; break;
        case ACID_CLOUD: temp[y][x] = 50; break;
        case CARBON_DIOXIDE: temp[y][x] = 20; break;
        case OXYGEN: temp[y][x] = 20; break;
        case BIRD: temp[y][x] = 20; break;
        case MEAT: temp[y][x] = 20; break;
        case COOKED_MEAT: temp[y][x] = 20; break;
        case COBBLESTONE: temp[y][x] = 20; break;
        case OIL: temp[y][x] = 20; break;
        case BIG_BOMB: temp[y][x] = 20; break;
        case WATER_BOMB: temp[y][x] = 20; break;
        case FIRE_BOMB: temp[y][x] = 20; break;
        case CRYO_BOMB: temp[y][x] = 20; break;
        case NUKE_BOMB: temp[y][x] = 20; break;
        case BOUNCY_BALL: 
          temp[y][x] = 20; 
          // Initialize with a small random velocity
          ballVelocityX[y][x] = (Math.random() - 0.5) * 2;
          ballVelocityY[y][x] = -2 - Math.random() * 2; // Initial upward velocity
          break;
      }
      
      // Initialize color variation for this element
      const variation = 0.05;
      colorVariations[y][x] = {
        r: 1 + (Math.random() * variation * 2 - variation),
        g: 1 + (Math.random() * variation * 2 - variation),
        b: 1 + (Math.random() * variation * 2 - variation)
      };
    }
    function eraseCell(x, y) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[y][x] = false;
      vaporLife[y][x] = 0;
      cloudLife[y][x] = 0;
      fireLife[y][x] = 0;
      smokeLife[y][x] = 0;
      burningWoodTime[y][x] = 0;
      wheatHeight[y][x] = 0;
      wheatMaxHeight[y][x] = 0;
      seedGrowthTime[y][x] = 0;
      rootLife[y][x] = 0;
      sparkLife[y][x] = 0;
      sparkTimer[y][x] = 0;
      oakTreeGrowthTime[y][x] = 0;
      oakTreeHeight[y][x] = 0;
      oakTreeMaxHeight[y][x] = 0;
      oakTreeRootTimer[y][x] = 0;
      oakTreeRootDepth[y][x] = 0;
      oakTreeRootMax[y][x] = 0;
      branchLevel[y][x] = -1;
      branchLen[y][x] = 0;
      branchMaxArr[y][x] = 0;
      branchSubCount[y][x] = -1;
      branchDirX[y][x] = 0;
      branchDirY[y][x] = 0;
      grassStage[y][x] = 1;
      burningGasTime[y][x] = 0;
      chargedStateTime[y][x] = 0;
      colorVariations[y][x] = null;
    }
    /***************************************
     * RENDER & HUD
     ***************************************/
     function renderCell(x, y) {
      const cell = cells[y][x];
      cell.className = 'cell';
      cell.style.opacity = "";
      cell.style.backgroundColor = "";
      
      const e = grid[y][x];
      if (e === EMPTY) return;
      
      // Get base color
      let baseColor = elementBaseColors[e];
      
      if (baseColor) {
        // Get temperature
        const temperature = temp[y][x] !== null ? temp[y][x] : 20;
        
        // Apply temperature and random variations
        const adjustedColor = getTemperatureAdjustedColor(baseColor, temperature, e, x, y);
        
        // Apply the color
        cell.style.backgroundColor = adjustedColor;
        
        // Special case for smoke opacity
        if (e === SMOKE) {
          let max = smokeMaxLife[y][x];
          let life = smokeLife[y][x];
          let ratio = 1 - (life / max);
          if (ratio < 0) ratio = 0;
          cell.style.opacity = ratio.toString();
        }
        
        // Special case for other transparent elements
        if ([GAS, WATER_VAPOR, BURNING_GAS, CARBON_DIOXIDE, OXYGEN, HELIUM].includes(e)) {
          cell.style.opacity = "0.7";
        }
      } else {
        // Fallback to class-based styling if no base color is defined
        switch (e) {
          case SAND: cell.classList.add('sand'); break;
          case WALL: cell.classList.add('wall'); break;
          case WATER: cell.classList.add('water'); break;
          case LAVA: cell.classList.add('lava'); break;
          case STONE: cell.classList.add('stone'); break;
          case WATER_VAPOR: cell.classList.add('water-vapor'); break;
          case CLOUD: cell.classList.add('cloud'); break;
          case BASALT: cell.classList.add('stone'); break;
          case OBSIDIAN: cell.classList.add('stone'); break;
          case MOLTEN_SLAG: cell.classList.add('lava'); break;
          case COPPER: cell.classList.add('copper'); break;
          case STEEL: cell.classList.add('steel'); break;
          case ICE: cell.classList.add('ice'); break;
          case WOOD: cell.classList.add('wood'); break;
          case FIRE: cell.classList.add('fire'); break;
          case SMOKE: cell.classList.add('smoke'); break;
          case BURNING_WOOD: cell.classList.add('burning-wood'); break;
          case BURNING_ORGANIC: cell.classList.add('burning-organic'); break;
          case ASH: cell.classList.add('ash'); break;
          case GLASS: cell.classList.add('glass'); break;
          case BOMB: cell.classList.add('bomb'); break;
          case DIRT: cell.classList.add('dirt'); break;
          case WET_DIRT: cell.classList.add('wet-dirt'); break;
          case WHEAT_SEEDS: cell.classList.add('wheat-seeds'); break;
          case WHEAT: cell.classList.add('wheat'); break;
          case FLOUR: cell.classList.add('flour'); break;
          case DOUGH: cell.classList.add('dough'); break;
          case BREAD: cell.classList.add('bread'); break;
          case ROOT: cell.classList.add('root'); break;
          case BURNING_ROOT: cell.classList.add('burning-root'); break;
          case DEAD_ROOT: cell.classList.add('dead-root'); break;
          case SPARK: cell.classList.add('spark'); break;
          case CHARGED_COPPER: cell.classList.add('charged-copper'); break;
          case CHARGED_DOWN_COPPER: cell.classList.add('charged-down-copper'); break;
          case OAK_SEEDS: cell.classList.add('oak-seeds'); break;
          case OAK_LEAVES: cell.classList.add('oak-leaves'); break;
          case OAK_BABY_LEAVES: cell.classList.add('oak-baby-leaves'); break;
          case DEAD_OAK: cell.classList.add('dead-oak'); break;
          case BIRCH_SEEDS: cell.classList.add('birch-seeds'); break;
          case BIRCH_LEAVES: cell.classList.add('birch-leaves'); break;
          case BIRCH_BABY_LEAVES: cell.classList.add('birch-baby-leaves'); break;
          case BIRCH_WOOD: cell.classList.add('birch-wood'); break;
          case DEAD_BIRCH: cell.classList.add('dead-birch'); break;
          case WET_SAND: cell.classList.add('wet-sand'); break;
          case GRASS: cell.classList.add('grass'); break;
          case DEAD_PLANT: cell.classList.add('dead-plant'); break;
          case BURNING_LEAVES: cell.classList.add('burning-leaves'); break;
          case GAS: cell.classList.add('gas'); break;
          case BURNING_GAS: cell.classList.add('burning-gas'); break;
          case COOLER: cell.classList.add('cooler'); break;
          case HEATER: cell.classList.add('heater'); break;
          case HEAT_SEPARATOR: cell.classList.add('heat-separator'); break;
          case CHARGED_HEAT_SEPARATOR: cell.classList.add('charged-heat-separator'); break;
          case CHARGED_DOWN_HEAT_SEPARATOR: cell.classList.add('charged-down-heat-separator'); break;
          case INPUT: cell.classList.add('input'); break;
          case CHARGED_INPUT: cell.classList.add('charged-input'); break;
          case OUTPUT: cell.classList.add('output'); break;
          case CHARGED_OUTPUT: cell.classList.add('charged-output'); break;
          case NOT_GATE: cell.classList.add('not-gate'); break;
          case AND_GATE: cell.classList.add('and-gate'); break;
          case BLOCKER: cell.classList.add('blocker'); break;
          case CHARGED_BLOCKER: cell.classList.add('charged-blocker'); break;
          case CLONER: cell.classList.add('cloner'); break;
          case COAL: cell.classList.add('coal'); break;
          case COAL_LUMP: cell.classList.add('coal-lump'); break;
          case BURNING_COAL: cell.classList.add('burning-coal'); break;
          case BURNING_COAL_LUMP: cell.classList.add('burning-coal-lump'); break;
          case THERMITE: cell.classList.add('thermite'); break;
          case BURNING_THERMITE: cell.classList.add('burning-thermite'); break;
          case ACID: cell.classList.add('acid'); break;
          case ACID_STEAM: cell.classList.add('acid-steam'); break;
          case ACID_CLOUD: cell.classList.add('acid-cloud'); break;
          case SLIME: cell.classList.add('slime'); break;
          case CARBON_DIOXIDE: cell.classList.add('carbon-dioxide'); break;
          case OXYGEN: cell.classList.add('oxygen'); break;
          case BIRD: cell.classList.add('bird'); break;
          case MEAT: cell.classList.add('meat'); break;
          case COOKED_MEAT: cell.classList.add('cooked-meat'); break;
          case COBBLESTONE: cell.classList.add('cobblestone'); break;
          case OIL: cell.classList.add('oil'); break;
          case BIG_BOMB: cell.classList.add('big-bomb'); break;
          case WATER_BOMB: cell.classList.add('water-bomb'); break;
          case FIRE_BOMB: cell.classList.add('fire-bomb'); break;
          case CRYO_BOMB: cell.classList.add('cryo-bomb'); break;
          case NUKE_BOMB: cell.classList.add('nuke-bomb'); break;
          case HELIUM: cell.classList.add('helium'); break;
          case BOUNCY_BALL: cell.classList.add('bouncy-ball'); break;
          default: break;
        }
      }
    }
    function renderGrid(){
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          renderCell(x, y);
        }
      }
    }
    function updateHUD(){
      if (hoveredX !== null && hoveredY !== null){
        let t = temp[hoveredY][hoveredX];
        let displayT = (t === null) ? "--" : t.toFixed(1);
        hudTemp.textContent = `Temp: ${displayT} Â°C`;
        hudElem.textContent = `Element: ${getElementName(grid[hoveredY][hoveredX])}`;
      }
    }
    function getElementName(e){
      switch(e){
        case EMPTY: return "Empty";
        case SAND: return "Sand";
        case WALL: return "Wall";
        case WATER: return "Water";
        case LAVA: return "Lava";
        case STONE: return "Stone";
        case ERASER: return "Eraser";
        case WATER_VAPOR: return "Water Vapor";
        case CLOUD: return "Cloud";
        case BASALT: return "Basalt";
        case OBSIDIAN: return "Obsidian";
        case MOLTEN_SLAG: return "Molten Slag";
        case COPPER: return "Copper";
        case STEEL: return "Steel";
        case ICE: return "Ice";
        case WOOD: return "Wood";
        case FIRE: return "Fire";
        case SMOKE: return "Smoke";
        case BURNING_WOOD: return "Burning Wood";
        case BURNING_ORGANIC: return "Burning Organic";
        case ASH: return "Ash";
        case GLASS: return "Glass";
        case BOMB: return "Bomb";
        case DIRT: return "Dirt";
        case WET_DIRT: return "Wet Dirt";
        case WHEAT_SEEDS: return "Wheat Seeds";
        case WHEAT: return "Wheat";
        case FLOUR: return "Flour";
        case DOUGH: return "Dough";
        case BREAD: return "Bread";
        case ROOT: return "Plant Root";
        case BURNING_ROOT: return "Burning Root";
        case DEAD_ROOT: return "Dead Root";
        case SPARK: return "Spark";
        case CHARGED_COPPER: return "Charged Copper";
        case CHARGED_DOWN_COPPER: return "Charged-Down Copper";
        case OAK_SEEDS: return "Oak Seeds";
        case OAK_LEAVES: return "Oak Leaves";
        case OAK_BABY_LEAVES: return "Oak Baby Leaves";
        case DEAD_OAK: return "Dead Oak";
        case BIRCH_SEEDS: return "Birch Seeds";
        case BIRCH_LEAVES: return "Birch Leaves";
        case BIRCH_BABY_LEAVES: return "Birch Baby Leaves";
        case BIRCH_WOOD: return "Birch Wood";
        case DEAD_BIRCH: return "Dead Birch";
        case WET_SAND: return "Wet Sand";
        case GRASS: return "Grass";
        case DEAD_PLANT: return "Dead Plant";
        case BURNING_LEAVES: return "Burning Leaves";
        case GAS: return "Gas";
        case BURNING_GAS: return "Burning Gas";
        case COOLER: return "Cooler";
        case HEATER: return "Heater";
        case HEAT_SEPARATOR: return "Heat Separator";
        case CHARGED_HEAT_SEPARATOR: return "Charged Heat Separator";
        case CHARGED_DOWN_HEAT_SEPARATOR: return "Charged-Down Heat Separator";
        case INPUT: return "Input";
        case CHARGED_INPUT: return "Charged Input";
        case OUTPUT: return "Output";
        case CHARGED_OUTPUT: return "Charged Output";
        case NOT_GATE: return "Not Gate";
        case AND_GATE: return "And Gate";
        case BLOCKER: return "Blocker";
        case CHARGED_BLOCKER: return "Charged Blocker";
        case CLONER: return "Cloner";
        case COAL: return "Coal";
        case COAL_LUMP: return "Coal Lump";
        case BURNING_COAL: return "Burning Coal";
        case BURNING_COAL_LUMP: return "Burning Coal Lump";
        case THERMITE: return "Thermite";
        case BURNING_THERMITE: return "Molten Thermite";
        case ACID: return "Acid";
        case SLIME: return "Slime";
        case ACID_STEAM: return "Acid Steam";
        case ACID_CLOUD: return "Acid Cloud";
        case CARBON_DIOXIDE: return "Carbon Dioxide";
        case OXYGEN: return "Oxygen";
        case BIRD: return "Bird";
        case MEAT: return "Meat";
        case COOKED_MEAT: return "Cooked Meat";
        case COBBLESTONE: return "Cobblestone";
        case OIL: return "Oil";
        case BIG_BOMB: return "Big Bomb";
        case WATER_BOMB: return "Water Bomb";
        case FIRE_BOMB: return "Fire Bomb";
        case CRYO_BOMB: return "Cryo Bomb";
        case NUKE_BOMB: return "Nuke Bomb";
        case HELIUM: return "Helium";
        case BOUNCY_BALL: return "Bouncy Ball";
        default: return "Unknown";
      }
    }
    function resetMoved(){
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          moved[y][x] = false;
        }
      }
    }
    /***************************************
     * GAME LOOP
     ***************************************/
    let stepAccumulator = 0;
    let lastTime = performance.now();
    let frames = 0, fps = 0;
    let lastFrameTime = performance.now();
    let fixedTimeStep = 1000 / 60; // Base simulation on 60fps

    function gameLoop(timestamp) {
  // Calculate actual time elapsed since last frame
  const deltaTime = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  
  // Calculate FPS for display
  frames++;
  if(timestamp - lastTime >= 1000) {
    fps = frames;
    frames = 0;
    lastTime = timestamp;
  }
  hudFPS.textContent = `FPS: ${fps}`;
  
  // Handle user input
  spamPlace();
  
  if(speed > 0) {
    // Convert real time to simulation time
    // This is the key part - we accumulate time based on real elapsed milliseconds
    const simulationTimeToAdd = (deltaTime / 1000) * (speed / 0.80);
    stepAccumulator += simulationTimeToAdd;
    
    // Run a fixed number of simulation steps based on accumulated time
    const fixedTimeStep = 0.016; // 16ms, equivalent to 60fps
    
    while(stepAccumulator >= fixedTimeStep) {
      resetMoved();
      performSimulationStep();
      updateTemperature();
      unifyCopperClusters();
      processTransformations();
      stepAccumulator -= fixedTimeStep;
    }
  }
  
  updateHUD();
  renderGrid();
  updateHoverOverlay();
  requestAnimationFrame(gameLoop);
}
    /***************************************
     * SIMULATION STEP
     ***************************************/
    function performSimulationStep(){
      let yPositions = [];
      for (let i = 0; i < GRID_SIZE; i++) yPositions.push(i);
      shuffle(yPositions);
      for (let i = yPositions.length - 1; i >= 0; i--){
        let y = yPositions[i];
        let xPositions = [];
        for (let j = 0; j < GRID_SIZE; j++) xPositions.push(j);
        shuffle(xPositions);
        for (let j = 0; j < xPositions.length; j++){
          let x = xPositions[j];
          if(moved[y][x]) continue;
          let e = grid[y][x];
          if(e === WALL) continue;

          switch(e) {
            case SPARK:
              sparkLife[y][x] += simulationTimeStep;
              if(sparkLife[y][x] >= sparkLifetime){
                eraseCell(x, y);
                continue;
              }
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of neighbors){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BOMB){
                    explodeBomb(nx, ny);
                  }
                  if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){
                    grid[ny][nx] = CHARGED_COPPER;
                    temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                    chargedStateTime[ny][nx] = 0;
                  }
                }
              }
              break;

            case SAND:
            case ASH:
            case THERMITE:
            case BOMB:
            case BIG_BOMB:
            case WATER_BOMB:
            case FIRE_BOMB:
            case CRYO_BOMB:
            case NUKE_BOMB:
            case DIRT:
            case WET_DIRT:
            case WHEAT_SEEDS:
            case OAK_SEEDS:
            case BIRCH_SEEDS:
            case FLOUR:
            case DEAD_PLANT:
            case GRASS:
            case COAL_LUMP:
            case COBBLESTONE:
              moveLikePowder(x, y, temp[y][x], e);
              break;

            case WET_SAND:
            case DOUGH:
            case BREAD:
              moveNonPowderGravity(x, y, temp[y][x], e);
              break;

            case WATER:
              moveLikeLiquid(x, y, temp[y][x], WATER);
              break;

            case OIL:
              moveOil(x, y, temp[y][x]);
              break;

            case BOUNCY_BALL:
              moveBouncyBall(x, y, temp[y][x]);
              break;

            case LAVA:
            case MOLTEN_SLAG:
              if(Math.random() < 0.5) continue;
              moveLikeLiquid(x, y, temp[y][x], LAVA);
              break;

            case BURNING_THERMITE:
              moveLikeLiquid(x, y, temp[y][x], THERMITE);
              break;

            case WATER_VAPOR:
              vaporLife[y][x] += simulationTimeStep;
              moveVaporUp(x, y, temp[y][x]);
              break;

            case CLOUD:
              cloudLife[y][x] += simulationTimeStep;
              moveCloud(x, y, temp[y][x]);
              break;

            case FIRE:
              fireLife[y][x] += simulationTimeStep;
              moveFire(x, y, temp[y][x]);
              break;

            case SMOKE:
              smokeLife[y][x] += simulationTimeStep;
              moveSmoke(x, y, temp[y][x]);
              break;

            case GAS:
            case BURNING_GAS:
            case CARBON_DIOXIDE:
            case OXYGEN:
              moveGasElement(x, y, temp[y][x], e);
              break;

            case ACID:
              moveAcid(x, y, temp[y][x]);
              break;

            case SLIME:
              moveSlime(x, y, temp[y][x]);
              break;

            case BIRD:
              moveBird(x, y, temp[y][x]);
              break;

            case HELIUM:
              moveHelium(x, y, temp[y][x]);
              break;

            case MEAT:
            case COOKED_MEAT:
              if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                moveCell(x, y, x, y+1, temp[y][x], e);
              }
              break;
          }
        }
      }
    }
    /***************************************
     * HELPER: shuffle
     ***************************************/
    function shuffle(array){
      for (let i = array.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    /***************************************
     * MOVEMENT
     ***************************************/
    function moveCell(x, y, nx, ny, oldT, newElem){
      if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) return;
      grid[ny][nx] = newElem;
      temp[ny][nx] = oldT;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[ny][nx] = true;
      
      // Transfer color variation data when moving cells
      if(colorVariations[y][x]) {
        colorVariations[ny][nx] = colorVariations[y][x];
        colorVariations[y][x] = null;
      }
      if(newElem === WATER_VAPOR){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === ACID_STEAM){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === CLOUD){
        cloudLife[ny][nx] = cloudLife[y][x];
        cloudLife[y][x] = 0;
        cloudMaxLife[ny][nx] = cloudMaxLife[y][x];
      }
      if(newElem === FIRE){
        fireLife[ny][nx] = fireLife[y][x];
        fireLife[y][x] = 0;
      }
      if(newElem === SMOKE){
        smokeLife[ny][nx] = smokeLife[y][x];
        smokeLife[y][x] = 0;
        smokeMaxLife[ny][nx] = smokeMaxLife[y][x];
      }
      if(newElem === BURNING_WOOD || newElem === BURNING_ORGANIC || newElem === BURNING_ROOT){
        burningWoodTime[ny][nx] = burningWoodTime[y][x];
        burningWoodTime[y][x] = 0;
      }
      if(newElem === WHEAT_SEEDS){
        seedGrowthTime[ny][nx] = seedGrowthTime[y][x];
        seedGrowthTime[y][x] = 0;
      }
      if(newElem === WHEAT){
        wheatHeight[ny][nx] = wheatHeight[y][x];
        wheatMaxHeight[ny][nx] = wheatMaxHeight[y][x];
        wheatHeight[y][x] = 0;
        wheatMaxHeight[y][x] = 0;
      }
      if(newElem === BOUNCY_BALL) {
        ballVelocityX[ny][nx] = ballVelocityX[y][x];
        ballVelocityY[ny][nx] = ballVelocityY[y][x];
        ballVelocityX[y][x] = 0;
        ballVelocityY[y][x] = 0;
      }
      if(newElem === GAS || newElem === BURNING_GAS){
        burningGasTime[ny][nx] = burningGasTime[y][x];
        burningGasTime[y][x] = 0;
      }
      if(newElem === GRASS){
        grassStage[ny][nx] = grassStage[y][x];
      }
      if(newElem === SPARK){
        sparkLife[ny][nx] = sparkLife[y][x];
        sparkTimer[ny][nx] = sparkTimer[y][x];
        sparkLife[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      if(newElem === CHARGED_COPPER || newElem === CHARGED_DOWN_COPPER ||
         newElem === CHARGED_HEAT_SEPARATOR || newElem === CHARGED_DOWN_HEAT_SEPARATOR ||
         newElem === CHARGED_INPUT || newElem === CHARGED_OUTPUT ||
         newElem === CHARGED_BLOCKER){
        chargedStateTime[ny][nx] = chargedStateTime[y][x];
        chargedStateTime[y][x] = 0;
      }
    }
    function moveLikePowder(x, y, oldT, elem){
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA) && !moved[y+1][x]){
        // Special case for oil floating on water
        if(elem === OIL && grid[y+1][x] === WATER) {
          let tempWater = temp[y+1][x];
          grid[y+1][x] = OIL;
          temp[y+1][x] = oldT;
          grid[y][x] = WATER;
          temp[y][x] = tempWater;
          moved[y+1][x] = true;
          return;
        }

        // For other elements, displace liquid upwards and fall through
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move powder down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        } else {
          // If no empty space found, behave like normal powder
          let diag = [];
          if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
          if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
          shuffle(diag);
          for(let d of diag){
            let nx = x + d, ny = y + 1;
            if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
              moveCell(x, y, nx, ny, oldT, elem);
              break;
            }
          }
        }
      }
      else{
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y + 1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            break;
          }
        }
      }
    }
    function moveNonPowderGravity(x, y, oldT, elem) {
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA) && !moved[y+1][x]){
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move element down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        }
      }
    }

    function moveLikeLiquid(x, y, oldT, elem){
      // Slow down lava movement
      if(elem === LAVA && Math.random() < 0.5) return;

      if(y+1 < GRID_SIZE && [EMPTY].includes(grid[y+1][x]) && !moved[y+1][x]){
        let below = grid[y+1][x];
        if(below === CLOUD){
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = CLOUD;
          temp[y][x] = 50;
          cloudLife[y][x] = 0;
          moved[y+1][x] = true;
          return;
        }
        else if(below === WATER_VAPOR){
          // Save the vapor's properties before moving it
          let vaporTemp = temp[y+1][x];
          let vaporLifeValue = vaporLife[y+1][x];
          
          if(y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
            // Move vapor up properly
            grid[y-1][x] = WATER_VAPOR;
            temp[y-1][x] = vaporTemp;
            vaporLife[y-1][x] = vaporLifeValue;
            moved[y-1][x] = true;
            
            // Now move water down safely
            grid[y+1][x] = elem;
            temp[y+1][x] = oldT;
            grid[y][x] = EMPTY;
            temp[y][x] = null;
            moved[y+1][x] = true;
          } else {
            // Try to move vapor to the sides if possible
            let moved_vapor = false;
            let sides = [[-1, 0], [1, 0]];
            shuffle(sides);
            
            for(let i = 0; i < sides.length; i++) {
              let dx = sides[i][0];
              let dy = sides[i][1];
              let vx = x + dx, vy = y + 1;
              if(vx >= 0 && vx < GRID_SIZE && vy >= 0 && vy < GRID_SIZE && 
                grid[vy][vx] === EMPTY && !moved[vy][vx]) {
                // Move vapor to the side
                grid[vy][vx] = WATER_VAPOR;
                temp[vy][vx] = vaporTemp;
                vaporLife[vy][vx] = vaporLifeValue;
                moved[vy][vx] = true;
                moved_vapor = true;
                break;
              }
            }
            
            // Only if we couldn't move vapor anywhere, proceed with water movement
            if(!moved_vapor) {
              moveCell(x, y, x, y+1, oldT, elem);
            } else {
              // Water moves down, vapor moved to side
              grid[y+1][x] = elem;
              temp[y+1][x] = oldT;
              grid[y][x] = EMPTY;
              temp[y][x] = null;
              moved[y+1][x] = true;
            }
          }
          return; // Important to return here
        }
        else {
          moveCell(x, y, x, y+1, oldT, elem);
        }
      }
      else {
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let dir of dirs){
          let nx = x + dir, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y+1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
      }
    }
    function moveFire(x, y, oldT){
      let possible = [[0,-1], [-1,-1], [1,-1], [-1,0], [1,0]];
      shuffle(possible);
      for(let [dx, dy] of possible){
        let nx = x + dx, ny = y + dy;
        if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, FIRE);
            break;
          }
        }
      }
    }
    function moveSmoke(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, SMOKE);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, SMOKE);
            break;
          }
        }
      }
    }
    function moveBouncyBall(x, y, oldT) {
  // Apply gravity to velocity
  ballVelocityY[y][x] += 0.2;
  
  // Calculate new position based on velocity
  let nx = Math.round(x + ballVelocityX[y][x]);
  let ny = Math.round(y + ballVelocityY[y][x]);
  
  // Check boundaries and handle bouncing
  if (nx < 0) {
    nx = 0;
    ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.8; // Bounce with energy loss
  } else if (nx >= GRID_SIZE) {
    nx = GRID_SIZE - 1;
    ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.8;
  }
  
  if (ny < 0) {
    ny = 0;
    ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.8;
  } else if (ny >= GRID_SIZE) {
    ny = GRID_SIZE - 1;
    ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.8;
  }
  
  // Check destination cell
  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
    if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
      // Empty space - normal movement
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
    } 
    else if (grid[ny][nx] === WATER && !moved[ny][nx]) {
      // Move through water (slower and less bouncy)
      ballVelocityX[y][x] *= 0.7; // Slow down in water
      ballVelocityY[y][x] *= 0.7;
      
      // Save the water to place it behind the ball
      let waterTemp = temp[ny][nx];
      
      // Move the ball
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
      
      // Place water in the original position
      grid[y][x] = WATER;
      temp[y][x] = waterTemp;
    }
    else if (grid[ny][nx] === OIL && !moved[ny][nx]) {
      // Move through oil (faster)
      ballVelocityX[y][x] *= 1.2; // Speed up in oil
      ballVelocityY[y][x] *= 1.2;
      
      // Save the oil to place it behind the ball
      let oilTemp = temp[ny][nx];
      
      // Move the ball
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
      
      // Place oil in the original position
      grid[y][x] = OIL;
      temp[y][x] = oilTemp;
    }
    else if (grid[ny][nx] === LAVA || grid[ny][nx] === FIRE) {
      // Burn in lava or fire
      eraseCell(x, y);
      // Optional: create some fire or smoke particles
      if (Math.random() < 0.5) {
        grid[y][x] = FIRE;
        temp[y][x] = fireTemperature;
        fireLife[y][x] = 0;
      } else {
        grid[y][x] = SMOKE;
        temp[y][x] = 100;
        smokeLife[y][x] = 0;
      }
    }
    else {
      // Collision with something else - bounce
      // Calculate bounce direction based on the direction of impact
      let dx = nx - x;
      let dy = ny - y;
      
      if (dx !== 0) {
        ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.9;
      }
      if (dy !== 0) {
        ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.9;
      }
      
      // Add a small random component to prevent getting stuck
      ballVelocityX[y][x] += (Math.random() - 0.5) * 0.1;
      ballVelocityY[y][x] += (Math.random() - 0.5) * 0.1;
    }
  }
  
  // Apply minimum velocity threshold to prevent tiny movements
  if (Math.abs(ballVelocityX[y][x]) < 0.05) ballVelocityX[y][x] = 0;
  if (Math.abs(ballVelocityY[y][x]) < 0.05) ballVelocityY[y][x] = 0;
  
  // If ball has stopped completely, give it a tiny kick to prevent sticking
  if (ballVelocityX[y][x] === 0 && ballVelocityY[y][x] === 0 && Math.random() < 0.1) {
    ballVelocityY[y][x] = -0.1; // Small upward kick
    ballVelocityX[y][x] = (Math.random() - 0.5) * 0.2;
  }
}  
      function moveVaporUp(x, y, oldT){
        let ty = y - 1;
        if(ty >= 0){
          if(grid[ty][x] === EMPTY && !moved[ty][x]){
            moveCell(x, y, x, ty, oldT, WATER_VAPOR);
            return;
          }
          else if(grid[ty][x] === WATER && !moved[ty][x]){
            let swpT = temp[ty][x];
            
            // Save the vapor's life value
            let currentVaporLife = vaporLife[y][x];
            
            // Update the cell above (water becomes vapor)
            grid[ty][x] = WATER_VAPOR;
            temp[ty][x] = oldT;
            vaporLife[ty][x] = currentVaporLife;
            moved[ty][x] = true;
            
            // Update the current cell (vapor becomes water)
            grid[y][x] = WATER;
            temp[y][x] = swpT;
            vaporLife[y][x] = 0; // Clear the vapor life in the old position
            
            return;
          }
        }
        
        // Rest of the function remains the same
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, WATER_VAPOR);
            return;
          }
        }
      }
    function moveCloud(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, CLOUD);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, CLOUD);
            break;
          }
        }
      }
    }
    function moveGasElement(x, y, oldT, elem){
      let possible = [];
      for(let dy = -1; dy <= 1; dy++){
        for(let dx = -1; dx <= 1; dx++){
          if(dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            possible.push([dx, dy]);
          }
        }
      }
      if(possible.length > 0){
        let [dx, dy] = possible[Math.floor(Math.random() * possible.length)];
        moveCell(x, y, x + dx, y + dy, oldT, elem);
      }
    }
    function moveHelium(x, y, oldT) {
      // First try to move directly up
      if (y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]) {
        moveCell(x, y, x, y-1, oldT, HELIUM);
        return;
      }
      
      // Then try diagonally up
      let dirs = shuffle([-1, 1]);
      for (let dir of dirs) {
        let nx = x + dir, ny = y - 1;
        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && grid[ny][nx] === EMPTY && !moved[ny][nx]) {
          moveCell(x, y, nx, ny, oldT, HELIUM);
          return;
        }
      }
      
      // If can't move up, move like regular gas
      moveGasElement(x, y, oldT, HELIUM);
    }
    /***************************************
     * BOMBS & TEMPERATURE
     ***************************************/
    function explodeBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB){
              explodeBomb(x, y);
            }
            else {
              if(Math.random() < 0.3){
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function explodeBigBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius * 4; // Double the radius
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
               grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
            }
            else {
              if(Math.random() < 0.6){ // Increased chance to erase
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
          }
        }
      }
    }
  }
}

function explodeWaterBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          grid[y][x] = WATER;
          temp[y][x] = 20;
        }
      }
    }
  }
}

function explodeFireBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 1.5; // Slightly larger radius
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === EMPTY) {
          // Always place fire in empty cells
          grid[y][x] = FIRE;
          temp[y][x] = fireTemperature * 2; // Hotter fire
          fireLife[y][x] = 0;
        }
        else {
          // For non-empty cells, set them on fire if possible
          let e = grid[y][x];
          if(e === WOOD) {
            grid[y][x] = BURNING_WOOD;
            temp[y][x] = fireTemperature;
            burningWoodTime[y][x] = 0;
          } 
          else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES) {
            grid[y][x] = BURNING_LEAVES;
            temp[y][x] = fireTemperature;
          }
          else {
            // For other elements, just make them very hot
            temp[y][x] = Math.max(temp[y][x] || 0, fireTemperature * 1.5);
          }
        }
      }
    }
  }
}

function explodeCryoBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === WATER) {
          grid[y][x] = ICE;
          temp[y][x] = -20;
        }
        else {
          temp[y][x] = -50;
        }
      }
    }
  }
}

function explodeNukeBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 25;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          if(dist < radius / 3) {
            eraseCell(x, y);
          }
          else if(dist < radius * 2/3) {
            grid[y][x] = FIRE;
            temp[y][x] = fireTemperature * 2;
            fireLife[y][x] = 0;
          }
          else {
            if(Math.random() < 0.7) {
              grid[y][x] = FIRE;
              temp[y][x] = fireTemperature;
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
  }
}
    function unifyCopperClusters(){
      // Skip this function for very large grid sizes to prevent performance issues
      if (GRID_SIZE > 200) return;
      
      let visited = [];
      for(let y = 0; y < GRID_SIZE; y++){
        visited[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          visited[y][x] = false;
        }
      }
      
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === COPPER && !visited[y][x]){
            let cluster = [], sumT = 0;
            let queue = [[x, y]];
            visited[y][x] = true;
            
            // Limit cluster size to prevent performance issues
            const maxClusterSize = 1000;
            
            while(queue.length > 0 && cluster.length < maxClusterSize){
              let [cx, cy] = queue.shift();
              cluster.push([cx, cy]);
              
              // Safely add temperature, handling null or undefined
              const cellTemp = temp[cy][cx];
              if (cellTemp !== null && cellTemp !== undefined && !isNaN(cellTemp)) {
                sumT += cellTemp;
              } else {
                // Default temperature if none exists
                sumT += 20;
              }
              
              for(let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]){
                let nx = cx + dx, ny = cy + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(!visited[ny][nx] && grid[ny][nx] === COPPER){
                    visited[ny][nx] = true;
                    queue.push([nx, ny]);
                  }
                }
              }
            }
            
            // Calculate average temperature with safety checks
            let avg = 20; // Default temperature
            if (cluster.length > 0) {
              avg = sumT / cluster.length;
              
              // Sanity check to prevent extreme temperatures
              if (isNaN(avg) || !isFinite(avg)) {
                avg = 20;
              } else {
                // Clamp temperature to reasonable range
                avg = Math.max(-273, Math.min(3000, avg));
              }
            }
            
            // Apply the average temperature to all cells in the cluster
            for(let [cx, cy] of cluster){
              temp[cy][cx] = avg;
            }
          }
        }
      }
    }
    function updateTemperature(){
      let newTemp = [];
      for(let y = 0; y < GRID_SIZE; y++){
        newTemp[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          newTemp[y][x] = temp[y][x];
        }
      }
      
      // Process non-copper elements first
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Skip copper elements for now - we'll handle them separately
          if(e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) {
            continue;
          }
          
          if(e === EMPTY || temp[y][x] === null){
            newTemp[y][x] = null;
            continue;
          }
          if(e === FIRE){
            newTemp[y][x] = fireTemperature;
            continue;
          }
          
          // Get current temperature with safety check
          let oldT = temp[y][x];
          if (isNaN(oldT) || !isFinite(oldT)) {
            oldT = 20; // Reset to default if it's NaN or infinite
            temp[y][x] = oldT; // Fix the original temperature too
          }
          
          let wSum = 0, tWeight = 0;
          for(let dy = -1; dy <= 1; dy++){
            for(let dx = -1; dx <= 1; dx++){
              if(dx === 0 && dy === 0) continue;
              let ny = y + dy, nx = x + dx;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx], nt = temp[ny][nx];
                if(ne !== EMPTY && nt !== null){
                  // Skip invalid temperatures
                  if (isNaN(nt) || !isFinite(nt)) continue;
                  
                  if((e === HEAT_SEPARATOR || e === CHARGED_HEAT_SEPARATOR || e === CHARGED_DOWN_HEAT_SEPARATOR) &&
                     (ne === COPPER || ne === CHARGED_COPPER || ne === CHARGED_DOWN_COPPER)){
                    continue;
                  }
                  
                  let cFactor = conductionRates[e] * conductionRates[ne];
                  wSum += cFactor * nt;
                  tWeight += cFactor;
                }
              }
            }
          }
          
          if(tWeight > 0){
            let avg = wSum / tWeight;
            
            // Safety check for the average
            if (isNaN(avg) || !isFinite(avg)) {
              avg = oldT; // Keep the old temperature if calculation is invalid
            }
            
            let cap = heatCapacities[e] || 1.0; // Default to 1.0 if undefined
            let myFactor = (conductionRates[e] || 0.5) * diffusionRate;
            
            // Limit the rate of temperature change
            let maxDelta = 10; // Maximum temperature change per step
            let rawDelta = myFactor * (avg - oldT) / cap;
            let delta = Math.max(-maxDelta, Math.min(maxDelta, rawDelta));
            
            // Calculate new temperature with bounds
            let newT = oldT + delta;
            newTemp[y][x] = Math.max(-273, Math.min(3000, newT)); // Clamp to reasonable range
          }
        }
      }
      
      // Now handle copper elements with more careful temperature handling
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          if(e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) {
            if(temp[y][x] === null){
              newTemp[y][x] = 20; // Default temperature for copper
              continue;
            }
            
            // Get current temperature with safety check
            let oldT = temp[y][x];
            if (isNaN(oldT) || !isFinite(oldT)) {
              oldT = 20; // Reset to default if it's NaN or infinite
              temp[y][x] = oldT; // Fix the original temperature too
            }
            
            // Copper conducts heat more gradually to prevent temperature spikes
            let wSum = 0, tWeight = 0;
            let validNeighbors = 0;
            
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                if(dx === 0 && dy === 0) continue;
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let ne = grid[ny][nx], nt = temp[ny][nx];
                  if(ne !== EMPTY && nt !== null){
                    // Skip invalid temperatures
                    if (isNaN(nt) || !isFinite(nt)) continue;
                    
                    // Skip heat separators
                    if(ne === HEAT_SEPARATOR || ne === CHARGED_HEAT_SEPARATOR || ne === CHARGED_DOWN_HEAT_SEPARATOR){
                      continue;
                    }
                    
                    validNeighbors++;
                    let cFactor = 0.5 * conductionRates[ne]; // Reduced factor for copper
                    wSum += cFactor * nt;
                    tWeight += cFactor;
                  }
                }
              }
            }
            
            if(tWeight > 0 && validNeighbors > 0){
              let avg = wSum / tWeight;
              
              // Safety check for the average
              if (isNaN(avg) || !isFinite(avg)) {
                avg = oldT; // Keep the old temperature if calculation is invalid
              }
              
              // For copper, use a much smaller temperature change rate
              let copperDiffusionRate = diffusionRate * 0.2; // 20% of normal diffusion rate
              let delta = copperDiffusionRate * (avg - oldT);
              
              // Limit the maximum temperature change for copper
              delta = Math.max(-5, Math.min(5, delta));
              
              // Calculate new temperature with bounds
              let newT = oldT + delta;
              newTemp[y][x] = Math.max(-273, Math.min(3000, newT)); // Clamp to reasonable range
            }
          }
        }
      }
      
      // Handle burning coal separately
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_COAL || grid[y][x] === BURNING_COAL_LUMP){
            if(temp[y][x] !== null && newTemp[y][x] !== null) {
              let oldT = temp[y][x];
              if (isNaN(oldT) || !isFinite(oldT)) {
                oldT = 20;
                temp[y][x] = oldT;
              }
              
              let delta = newTemp[y][x] - oldT;
              if(delta > 0) newTemp[y][x] = oldT + delta * 0.1;
              if(newTemp[y][x] > 500) newTemp[y][x] = 500;
            }
          }
        }
      }
      temp = newTemp;
    }
    /***************************************
     * REACTIONS & TRANSFORMS
     ***************************************/
    function processTransformations(){
      transformLavaToRock();
      transformWaterAndLavaToStone();
      transformWaterVapor();
      transformCloudToWater();
      transformIceWater();
      transformFireToSmoke();
      transformBurningWood();
      transformWoodIgnition();
      transformBurningLeaves();
      transformSandToGlass();
      transformDirtWetDirt();
      transformSandWetSand();
      transformFlourToDough();
      transformDoughToBread();
      transformBreadToAshIfHot();
      handleSeedsGrowth();
      handleWheatGrowth();
      handleWheatRootGrowth();
      handleRootsAbsorbWater();
      handleFlammables();
      handleOakTreeGrowth();
      handleOakTreeRootGrowth();
      handleBirchTreeGrowth();
      handleBirchTreeRootGrowth();
      handleGrassGrowth();
      igniteHotElements();
      triggerBombs();
      transformGas();
      handleBurningGas();
      transformRoots();
      handleChargedCopper();
      handleElectricalElements();
      handleCoolerHeater();
      handleCloners();
      transformThermite();
      transformGrass();
      
      // Handle new elements
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Handle meat cooking
          if(e === MEAT && temp[y][x] >= doughBakeTemp){
            grid[y][x] = COOKED_MEAT;
            temp[y][x] = 30;
          }
          
          // Handle bird cooking
          if(e === BIRD && temp[y][x] >= doughBakeTemp){
            grid[y][x] = COOKED_MEAT;
            temp[y][x] = 30;
          }
          
          // Handle cobblestone melting
          if(e === COBBLESTONE && temp[y][x] >= 800){
            grid[y][x] = MOLTEN_SLAG;
            temp[y][x] = 1200;
          }
          
          // Handle oil ignition
          if(e === OIL){
            let shouldIgnite = false;
            if(temp[y][x] >= 200) shouldIgnite = true;
            
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              grid[y][x] = BURNING_GAS;
              temp[y][x] = fireTemperature;
              burningGasTime[y][x] = 0;
            }
          }
          
          // Handle Carbon Dioxide transformation
          if(e === CARBON_DIOXIDE){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === WHEAT || ne === GRASS || ne === OAK_LEAVES || 
                   ne === OAK_BABY_LEAVES || ne === BIRCH_LEAVES || 
                   ne === BIRCH_BABY_LEAVES || ne === WHEAT_SEEDS){
                  grid[y][x] = OXYGEN;
                  temp[y][x] = 20;
                  break;
                }
              }
            }
          }
          
          // Handle Oxygen reactions
          if(e === OXYGEN){
            let shouldIgnite = false;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            
            // Check for burning elements
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
                // Check for birds (convert to CO2)
                if(ne === BIRD){
                  grid[y][x] = CARBON_DIOXIDE;
                  temp[y][x] = 20;
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              grid[y][x] = FIRE;
              temp[y][x] = 500;
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
    // New transformation for Thermite:
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of neighbors){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    function igniteFlammable(x, y){
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      let e = grid[y][x];
      // Oak wood ignites easily
      if(e === WOOD){
        grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      // Birch wood has a 50% chance to resist ignition from nearby flames
      else if(e === BIRCH_WOOD){
        if(Math.random() > 0.5) { // 50% chance to resist ignition
          grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
        } else {
          // Just heat up the birch wood instead of igniting
          temp[y][x] = Math.min(temp[y][x] + 50, fireTemperature - 50);
        }
      }
      else if(e === FLOUR || e === WHEAT_SEEDS || e === WHEAT){
        grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      // Oak leaves ignite easily
      else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
        grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      // Birch leaves have a 60% chance to resist ignition from nearby flames
      else if(e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES){
        if(Math.random() > 0.6) { // 40% chance to ignite
          grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
        } else {
          // Just heat up the birch leaves instead of igniting
          temp[y][x] = Math.min(temp[y][x] + 50, fireTemperature - 50);
        }
      }
      else if(e === GRASS){
        grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      else if(e === COAL){
        grid[y][x] = BURNING_COAL; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0;
        temp[y][x] = (temp[y][x] < 100 ? 100 : temp[y][x]);
      }
      else if(e === COAL_LUMP){
        grid[y][x] = BURNING_COAL_LUMP; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0;
        temp[y][x] = (temp[y][x] < 100 ? 100 : temp[y][x]);
      }
    }
    function handleBurningGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_GAS){
            burningGasTime[y][x] += simulationTimeStep;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e === GAS){
                  grid[ny][nx] = BURNING_GAS; temp[ny][nx] = fireTemperature; burningGasTime[ny][nx] = 0;
                }
                igniteFlammable(nx, ny);
              }
            }
            if(burningGasTime[y][x] >= burningGasDuration){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); burningGasTime[y][x] = 0;
            }
          }
        }
      }
    }
    function transformGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GAS){
            if(temp[y][x] >= 300){
              grid[y][x] = BURNING_GAS; temp[y][x] = fireTemperature; burningGasTime[y][x] = 0;
            }
            else {
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let e = grid[ny][nx];
                  if(e === FIRE || e === BURNING_WOOD || e === BURNING_ORGANIC || e === BURNING_LEAVES || e === BURNING_ROOT || e === BURNING_GAS){
                    grid[y][x] = BURNING_GAS; temp[y][x] = fireTemperature; burningGasTime[y][x] = 0; break;
                  }
                }
              }
            }
          }
        }
      }
    }
    function handleSeedsGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT_SEEDS){
        let below = grid[y+1][x];
            if(below === DIRT || below === WET_DIRT || below === SAND || below === WET_SAND || below === ROOT){
              seedGrowthTime[y][x] += simulationTimeStep;
              if(seedGrowthTime[y][x] >= 3){
                grid[y][x] = WHEAT; temp[y][x] = 20; wheatHeight[y][x] = 1; wheatMaxHeight[y][x] = 2 + Math.floor(Math.random() * 4);
                // Add color variation to wheat
                const variation = 0.1;
                colorVariations[y][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
              }
            }
          }
        }
      }
    }
    function handleWheatGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            let h = wheatHeight[y][x], mh = wheatMaxHeight[y][x];
            if(h < mh){
              if(Math.random() < 0.01){
                if(y > 0 && grid[y-1][x] === EMPTY){
                  grid[y-1][x] = WHEAT; temp[y-1][x] = 20; wheatHeight[y-1][x] = h + 1; wheatMaxHeight[y-1][x] = mh;
                  // Add color variation to wheat
                  const variation = 0.1;
                  colorVariations[y-1][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                }
              }
            }
          }
        }
      }
    }
    function handleWheatRootGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            for(let depth = 1; depth <= 2; depth++){
              let ny = y + depth;
              if(ny < GRID_SIZE){
                if(grid[ny][x] === EMPTY || grid[ny][x] === DIRT || grid[ny][x] === WET_DIRT || grid[ny][x] === SAND || grid[ny][x] === WET_SAND){
                  if(Math.random() < 0.0005){
                    placeElementAt(x, ny, ROOT);
                  }
                }
                else { break; }
              }
            }
          }
        }
      }
    }
    function handleRootsAbsorbWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT){
            let nb = [[1,0],[-1,0],[0,1],[0,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WET_DIRT){
                  grid[ny][nx] = DIRT; temp[ny][nx] = 20;
                }
                else if(grid[ny][nx] === WET_SAND){
                  grid[ny][nx] = SAND; temp[ny][nx] = 20;
                }
              }
            }
          }
        }
      }
    }
    function handleFlammables(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_ORGANIC){
            sparkTimer[y][x] += simulationTimeStep;
            let sparkLimit = 0.2 + 0.1 * Math.random();
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === EMPTY){
                    grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                    break;
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= 1.0){
              let r = Math.random();
              if(r < burnToAshChance){
                grid[y][x] = ASH; temp[y][x] = 50;
              }
              else {
                grid[y][x] = FIRE; temp[y][x] = fireTemperature; fireLife[y][x] = 0;
              }
            }
          }
          else if(grid[y][x] === BURNING_COAL){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoal){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
          else if(grid[y][x] === BURNING_COAL_LUMP){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoalLump){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
        }
      }
    }
    function handleOakTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_SEEDS){
            // Only check for growing conditions if the seed has something solid below it
            // This allows seeds to fall naturally until they land on something
            if(y === GRID_SIZE - 1 || ![EMPTY, WATER, WATER_VAPOR, CLOUD, FIRE, SMOKE, OIL, ACID, ACID_STEAM, ACID_CLOUD].includes(grid[y+1][x])) {
              // Check if the seed is on suitable ground
              if(y === GRID_SIZE - 1){
                grid[y][x] = DEAD_OAK; temp[y][x] = 20;
              }
              else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
                grid[y][x] = DEAD_OAK; temp[y][x] = 20;
              }
              else {
                oakTreeGrowthTime[y][x] += simulationTimeStep;
                if(oakTreeGrowthTime[y][x] >= 15.0){
                  grid[y][x] = WOOD; temp[y][x] = 20;
                  // Add color variation to wood
                  const variation = 0.05;
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[y][x] = 1;
                  oakTreeMaxHeight[y][x] = 10 + Math.floor(Math.random() * 11);
                  oakTreeRootTimer[y][x] = 0;
                  oakTreeRootDepth[y][x] = 0;
                  oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                  branchLevel[y][x] = 0;
                  branchLen[y][x] = 0;
                  branchDirX[y][x] = 0;
                  branchDirY[y][x] = 0;
                  for(let dy = -1; dy <= 1; dy++){
                    for(let dx = -1; dx <= 1; dx++){
                      let nx = x + dx, ny = y + dy;
                      if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                        grid[ny][nx] = OAK_BABY_LEAVES; temp[ny][nx] = 20;
                        // Add color variation to baby leaves
                        const leafVariation = 0.1;
                        colorVariations[ny][nx] = {
                          r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === WOOD || grid[y-1][x] === OAK_LEAVES || grid[y-1][x] === OAK_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = WOOD; temp[y-1][x] = 20;
                // Add color variation to wood
                const variation = 0.05;
                colorVariations[y-1][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  // Add color variation to branch wood
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  // Add color variation to branch wood
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = OAK_LEAVES; temp[ny][nx] = 20;
                  // Add color variation to side leaves
                  const leafVariation = 0.1;
                  colorVariations[ny][nx] = {
                    r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                  };
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    function handleOakTreeRootGrowth(){
      const oakRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= oakRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    
    function handleBirchTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_SEEDS){
            // Only check for growing conditions if the seed has something solid below it
            // This allows seeds to fall naturally until they land on something
            if(y === GRID_SIZE - 1 || ![EMPTY, WATER, WATER_VAPOR, CLOUD, FIRE, SMOKE, OIL, ACID, ACID_STEAM, ACID_CLOUD].includes(grid[y+1][x])) {
              // Check if the seed is on suitable ground
              if(y === GRID_SIZE - 1){
                grid[y][x] = DEAD_BIRCH; temp[y][x] = 20;
              }
              else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
                grid[y][x] = DEAD_BIRCH; temp[y][x] = 20;
              }
              else {
                oakTreeGrowthTime[y][x] += simulationTimeStep;
                if(oakTreeGrowthTime[y][x] >= 15.0){
                  grid[y][x] = BIRCH_WOOD; temp[y][x] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[y][x] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[y][x] = 1;
                  // Birch trees are a bit taller than oak trees
                  oakTreeMaxHeight[y][x] = 12 + Math.floor(Math.random() * 11);
                  oakTreeRootTimer[y][x] = 0;
                  oakTreeRootDepth[y][x] = 0;
                  oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                  branchLevel[y][x] = 0;
                  branchLen[y][x] = 0;
                  branchDirX[y][x] = 0;
                  branchDirY[y][x] = 0;
                  for(let dy = -1; dy <= 1; dy++){
                    for(let dx = -1; dx <= 1; dx++){
                      let nx = x + dx, ny = y + dy;
                      if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                        grid[ny][nx] = BIRCH_BABY_LEAVES; temp[ny][nx] = 20;
                        // Add color variation to leaves
                        const leafVariation = 0.1;
                        colorVariations[ny][nx] = {
                          r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === BIRCH_WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === BIRCH_WOOD || grid[y-1][x] === BIRCH_LEAVES || grid[y-1][x] === BIRCH_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = BIRCH_WOOD; temp[y-1][x] = 20;
                // Add color variation
                const variation = 0.05;
                colorVariations[y-1][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
                
                // 1/4 chance for black birch wood
                if (Math.random() < 0.25) {
                  // Override the base color to be black instead of white
                  colorVariations[y-1][x] = {
                    r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                    g: 0.2 + (Math.random() * 0.1),
                    b: 0.2 + (Math.random() * 0.1)
                  };
                }
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === BIRCH_LEAVES || grid[by][bx] === BIRCH_BABY_LEAVES)){
                  grid[by][bx] = BIRCH_WOOD; temp[by][bx] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[by][bx] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = BIRCH_LEAVES; temp[ly][lx] = 20;
                      // Add color variation to leaves
                      const leafVariation = 0.1;
                      colorVariations[ly][lx] = {
                        r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                      };
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === BIRCH_LEAVES || grid[by][bx] === BIRCH_BABY_LEAVES)){
                  grid[by][bx] = BIRCH_WOOD; temp[by][bx] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[by][bx] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = BIRCH_LEAVES; temp[ly][lx] = 20;
                      // Add color variation to leaves
                      const leafVariation = 0.1;
                      colorVariations[ly][lx] = {
                        r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                      };
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = BIRCH_LEAVES; temp[ny][nx] = 20;
                  // Add color variation to leaves
                  const leafVariation = 0.1;
                  colorVariations[ny][nx] = {
                    r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                  };
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BIRCH_WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    
    function handleBirchTreeRootGrowth(){
      const birchRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= birchRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    
    function handleGrassGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GRASS){
            let st = grassStage[y][x];
            if(st === 1){
              if(y > 0 && grid[y-1][x] === EMPTY){
                if(Math.random() < 0.0005){
                  grid[y-1][x] = GRASS; grassStage[y-1][x] = 2; temp[y-1][x] = 20;
                }
              }
            }
            let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
              if(grid[ny][nx] === DIRT || grid[ny][nx] === WET_DIRT){
                let ay = ny - 1;
                if(ay >= 0){
                  if(grid[ay][nx] === EMPTY){
                    if(Math.random() < 0.0003){
                      grid[ny][nx] = GRASS; grassStage[ny][nx] = 1; temp[ny][nx] = 20;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformRoots(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT && temp[y][x] >= 200){
            grid[y][x] = BURNING_ROOT; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
          }
          else if(grid[y][x] === BURNING_ROOT){
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= burnDuration){
              grid[y][x] = DEAD_ROOT; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function igniteHotElements(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let t = temp[y][x];
          if(t !== null){
            let e = grid[y][x];
            // Oak wood ignites at 200Â°C
            if(e === WOOD && t > 200){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Birch wood requires higher temperature (350Â°C) to ignite
            else if(e === BIRCH_WOOD && t > 350){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            else if((e === FLOUR || e === WHEAT_SEEDS || e === WHEAT) && t > 200){
              grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Oak leaves ignite at 200Â°C
            else if((e === OAK_LEAVES || e === OAK_BABY_LEAVES) && t > 200){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Birch leaves require higher temperature (300Â°C) to ignite
            else if((e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES) && t > 300){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
          }
        }
      }
    }
    function triggerBombs(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
             grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
        
        if(temp[y][x] >= 200) {
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        
        let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
        for(let [dx, dy] of neighbors){
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
            let e = grid[ny][nx];
            if(e === FIRE || e === BURNING_WOOD || e === BURNING_LEAVES || e === BURNING_ORGANIC || e === BURNING_ROOT || e === BURNING_GAS){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
              break;
            }
          }
        }
      }
    }
  }
}
    function transformLavaToRock(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === LAVA && t < 600){
            if(Math.random() < 0.5){ grid[y][x] = BASALT; temp[y][x] = 500; }
            else { grid[y][x] = OBSIDIAN; temp[y][x] = 500; }
          }
          if(e === BASALT && t >= 800){ grid[y][x] = LAVA; temp[y][x] = 1200; }
          if(e === OBSIDIAN && t >= 700){ grid[y][x] = MOLTEN_SLAG; temp[y][x] = 1200; }
          if(e === MOLTEN_SLAG && t < 800){ grid[y][x] = OBSIDIAN; temp[y][x] = 600; }
        }
      }
    }
    function transformWaterAndLavaToStone(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === WATER || e === LAVA){
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if((e === WATER && grid[ny][nx] === LAVA) || (e === LAVA && grid[ny][nx] === WATER)){
                    cpy[y][x] = STONE; temp[y][x] = 20;
                    cpy[ny][nx] = STONE; temp[ny][nx] = 20;
                  }
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformWaterVapor(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WATER){
            if(temp[y][x] >= 100){
              grid[y][x] = WATER_VAPOR; temp[y][x] = 120; vaporLife[y][x] = 0;
            }
          }
          else if(grid[y][x] === WATER_VAPOR){
            if(vaporLife[y][x] >= vaporTransformThreshold || vaporLife[y][x] >= 6){
              let count = 0;
              for(let dy = -1; dy <= 1; dy++){
                for(let dx = -1; dx <= 1; dx++){
                  let ny = y + dy, nx = x + dx;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === WATER_VAPOR && vaporLife[ny][nx] >= vaporTransformThreshold){
                      count++;
                    }
                  }
                }
              }
              if(count >= 3 || vaporLife[y][x] >= 6){
                grid[y][x] = CLOUD; temp[y][x] = 50; cloudLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function transformCloudToWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLOUD){
            if(temp[y][x] < 10){ grid[y][x] = WATER; temp[y][x] = 20; }
            else if(cloudLife[y][x] >= cloudMaxLife[y][x]){ grid[y][x] = WATER; temp[y][x] = 20; cloudLife[y][x] = 0; }
          }
        }
      }
    }
    function transformIceWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === WATER && t < 0){ grid[y][x] = ICE; temp[y][x] = -5; }
          else if(e === ICE && t > 2){ grid[y][x] = WATER; temp[y][x] = 5; }
        }
      }
    }
    function transformFireToSmoke(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            if(fireLife[y][x] >= fireLifetime){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random();
            }
            else { temp[y][x] = fireTemperature; }
          }
          else if(grid[y][x] === SMOKE){
            if(smokeLife[y][x] >= smokeMaxLife[y][x]){ eraseCell(x, y); }
          }
        }
      }
    }
    function transformBurningWood(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_WOOD){
            // Check if this was originally birch wood by looking at color variations
            // Birch wood typically has much lighter color variations than oak
            let isBirch = false;
            if (colorVariations[y][x]) {
              // If r, g, and b are all close to 1 or higher, it's likely birch wood
              // Or if it's very dark (black birch variant)
              if ((colorVariations[y][x].r > 0.95 && colorVariations[y][x].g > 0.95 && colorVariations[y][x].b > 0.95) ||
                  (colorVariations[y][x].r < 0.3 && colorVariations[y][x].g < 0.3 && colorVariations[y][x].b < 0.3)) {
                isBirch = true;
              }
            }
            
            // Sparks (fire spreading)
            sparkTimer[y][x] += simulationTimeStep;
            // Birch wood produces sparks less frequently
            let sparkLimit = isBirch ? (0.3 + 0.15 * Math.random()) : (0.2 + 0.1 * Math.random());
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              // Birch wood has less chance to spread fire
              if (!isBirch || Math.random() < 0.7) {
                for(let [dx, dy] of nb){
                  let nx = x + dx, ny = y + dy;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === EMPTY){
                      grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                      break;
                    }
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            
            // Burning duration
            // Birch wood burns 1.5x slower than oak wood
            let burnMultiplier = isBirch ? 0.67 : 1.0; // 1/1.5 = 0.67
            burningWoodTime[y][x] += simulationTimeStep * burnMultiplier;
            
            if(burningWoodTime[y][x] >= burnDuration){
              let r = Math.random();
              // Birch wood is more likely to turn to ash than to fire
              let ashChance = isBirch ? (burnToAshChance * 1.5) : burnToAshChance;
              ashChance = Math.min(ashChance, 0.9); // Cap at 90%
              
              let newElem = (r < ashChance) ? ASH : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 50; }
            }
          }
        }
      }
    }
    function transformWoodIgnition(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                // Oak wood ignites immediately on contact with fire
                if(e === WOOD){
                  grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                }
                // Birch wood has a 40% chance to resist immediate ignition from fire
                if(e === BIRCH_WOOD){
                  if(Math.random() > 0.4) { // 60% chance to ignite
                    grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                  } else {
                    // Just heat up the birch wood instead of igniting
                    temp[ny][nx] = Math.min(temp[ny][nx] + 75, 250);
                  }
                }
                // Oak leaves ignite immediately on contact with fire
                if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
                  grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                }
                // Birch leaves have a 50% chance to resist immediate ignition from fire
                if(e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES){
                  if(Math.random() > 0.5) { // 50% chance to ignite
                    grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                  } else {
                    // Just heat up the birch leaves instead of igniting
                    temp[ny][nx] = Math.min(temp[ny][nx] + 75, 250);
                  }
                }
                if(e === COAL){
                  grid[ny][nx] = BURNING_COAL; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
                if(e === COAL_LUMP){
                  grid[ny][nx] = BURNING_COAL_LUMP; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
              }
            }
          }
        }
      }
    }
    function transformBurningLeaves(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_LEAVES){
            sparkTimer[y][x] += simulationTimeStep;
            if(sparkTimer[y][x] >= burnDuration){
              let r = Math.random();
              let newElem = (r < 0.5) ? DEAD_PLANT : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 20; }
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let en = grid[ny][nx];
                  if(en === WOOD || en === OAK_LEAVES || en === OAK_BABY_LEAVES){
                    if(en === WOOD){
                      grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                    else {
                      grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformSandToGlass(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND && temp[y][x] >= glassTemp){
            grid[y][x] = GLASS; temp[y][x] = 300;
          }
        }
      }
    }
    function transformDirtWetDirt(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === DIRT){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  cpy[y][x] = WET_DIRT; temp[y][x] = 20;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
          else if(e === WET_DIRT){
            if(temp[y][x] >= wetDirtEvapTemp){
              cpy[y][x] = DIRT; temp[y][x] = 20;
            }
            else {
              let foundWater = null, foundDirt = null;
              let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WATER) foundWater = [nx, ny];
                  if(grid[ny][nx] === DIRT) foundDirt = [nx, ny];
                }
              }
              if(foundWater && foundDirt){
                let [wx, wy] = foundWater, [dx2, dy2] = foundDirt;
                cpy[dy2][dx2] = WET_DIRT; temp[dy2][dx2] = 20;
                cpy[wy][wx] = EMPTY; temp[wy][wx] = null;
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformSandWetSand(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  grid[y][x] = WET_SAND; temp[y][x] = 20;
                  break;
                }
              }
            }
          }
          else if(grid[y][x] === WET_SAND){
            if(temp[y][x] >= wetDirtEvapTemp){
              grid[y][x] = SAND; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function transformFlourToDough(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FLOUR){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  cpy[y][x] = DOUGH; temp[y][x] = 25;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformDoughToBread(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === DOUGH && temp[y][x] >= doughBakeTemp){
            grid[y][x] = BREAD; temp[y][x] = 30;
          }
        }
      }
    }
    function transformBreadToAshIfHot(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BREAD && temp[y][x] >= breadBurnTemp){
            grid[y][x] = ASH; temp[y][x] = 50;
          }
        }
      }
    }
    function handleChargedCopper(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              cpy[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
              continue;
            }
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_COPPER;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              grid[y][x] = COPPER; chargedStateTime[y][x] = 0; continue;
            }
            chargedStateTime[y][x] += simulationTimeStep;
            let anyCopper = false;
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){ anyCopper = true; break; }
              }
            }
            if(!anyCopper || chargedStateTime[y][x] >= 1.0){
              grid[y][x] = CHARGED_DOWN_COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
          else if(e === CHARGED_DOWN_COPPER){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){
              grid[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
        }
      }
    }
    function handleElectricalElements(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_HEAT_SEPARATOR){
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === HEAT_SEPARATOR && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_HEAT_SEPARATOR;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_HEAT_SEPARATOR;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = CHARGED_DOWN_HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
          else if(e === CHARGED_DOWN_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
        }
      }
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === INPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let shouldCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === CHARGED_COPPER || ne === CHARGED_DOWN_COPPER){ shouldCharge = true; break; }
              }
            }
            if(shouldCharge){ cpy[y][x] = CHARGED_INPUT; chargedStateTime[y][x] = 0; }
            else { cpy[y][x] = INPUT; }
          }
        }
      }
      grid = cpy;
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OUTPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let doCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === CHARGED_HEAT_SEPARATOR || ne === CHARGED_DOWN_HEAT_SEPARATOR ||
                   ne === CHARGED_OUTPUT || ne === CHARGED_BLOCKER || ne === NOT_GATE || ne === AND_GATE){
                  doCharge = true; break;
                }
              }
            }
            if(doCharge){ cpy[y][x] = CHARGED_OUTPUT; chargedStateTime[y][x] = chargedStateTime[y][x] || 0; }
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_OUTPUT){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 3.0){
              grid[y][x] = OUTPUT; chargedStateTime[y][x] = 0;
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_INPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let stillCharged = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_COPPER || grid[ny][nx] === CHARGED_DOWN_COPPER){ stillCharged = true; break; }
              }
            }
            if(!stillCharged){ grid[y][x] = INPUT; }
          }
        }
      }
    }
    function handleCoolerHeater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === COOLER || e === HEATER){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let hasChargedInput = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_INPUT){ hasChargedInput = true; break; }
              }
            }
            if(!hasChargedInput) continue;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e2 = grid[ny][nx];
                if(e2 === CHARGED_COPPER || e2 === CHARGED_DOWN_COPPER){
                  if(e === COOLER){ temp[ny][nx] = Math.max(temp[ny][nx] - 100 * simulationTimeStep, -1000); }
                  else { temp[ny][nx] = Math.min(temp[ny][nx] + 100 * simulationTimeStep, 3000); }
                }
              }
            }
          }
        }
      }
    }
    function handleCloners(){
      let replication = [];
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLONER){
            let directions = [[0,-1],[0,1],[-1,0],[1,0]];
            let foundOccupants = [];
            for(let [dx, dy] of directions){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e !== EMPTY && e !== CLONER){
                  foundOccupants.push({ ox: nx, oy: ny });
                }
              }
            }
            if(foundOccupants.length > 0){
              for(let occupant of foundOccupants){
                let ex = occupant.ox, ey = occupant.oy;
                for(let [dx2, dy2] of directions){
                  let rx = x + dx2, ry = y + dy2;
                  if(rx === ex && ry === ey) continue;
                  if(rx >= 0 && rx < GRID_SIZE && ry >= 0 && ry < GRID_SIZE){
                    if(grid[ry][rx] === EMPTY){
                      replication.push({ srcX: ex, srcY: ey, dstX: rx, dstY: ry });
                    }
                  }
                }
              }
            }
          }
        }
      }
      for(let rep of replication){
        let sX = rep.srcX, sY = rep.srcY;
        let dX = rep.dstX, dY = rep.dstY;
        if(grid[dY][dX] !== EMPTY) continue;
        cloneCell(sX, sY, dX, dY);
      }
    }
    function cloneCell(sx, sy, dx, dy){
      let occupant = grid[sy][sx];
      grid[dy][dx] = occupant;
      temp[dy][dx] = temp[sy][sx];
      if(occupant === WATER_VAPOR){ vaporLife[dy][dx] = vaporLife[sy][sx]; }
      if(occupant === CLOUD){ cloudLife[dy][dx] = cloudLife[sy][sx]; cloudMaxLife[dy][dx] = cloudMaxLife[sy][dx]; }
      if(occupant === FIRE){ fireLife[dy][dx] = fireLife[sy][sx]; }
      if(occupant === SMOKE){ smokeLife[dy][dx] = smokeLife[sy][sx]; smokeMaxLife[dy][dx] = smokeMaxLife[sy][sx]; }
      if(occupant === BURNING_WOOD || occupant === BURNING_ORGANIC || occupant === BURNING_ROOT){ burningWoodTime[dy][dx] = burningWoodTime[sy][sx]; }
      if(occupant === WHEAT_SEEDS){ seedGrowthTime[dy][dx] = seedGrowthTime[sy][sx]; }
      if(occupant === WHEAT){ wheatHeight[dy][dx] = wheatHeight[sy][sx]; wheatMaxHeight[dy][dx] = wheatMaxHeight[sy][sx]; }
      if(occupant === GAS || occupant === BURNING_GAS){ burningGasTime[dy][dx] = burningGasTime[sy][sx]; }
      if(occupant === GRASS){ grassStage[dy][dx] = grassStage[sy][sx]; }
      if(occupant === SPARK){ sparkLife[dy][dx] = sparkLife[sy][sx]; sparkTimer[dy][dx] = sparkTimer[sy][sx]; }
      if(occupant === CHARGED_COPPER || occupant === CHARGED_DOWN_COPPER ||
         occupant === CHARGED_HEAT_SEPARATOR || occupant === CHARGED_DOWN_HEAT_SEPARATOR ||
         occupant === CHARGED_INPUT || occupant === CHARGED_OUTPUT || occupant === CHARGED_BLOCKER){
        chargedStateTime[dy][dx] = chargedStateTime[sy][dx];
      }
    }
    /*******************************************
     * New Transformation: Thermite
     *******************************************/
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of nb){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    /*******************************************
     * CATEGORY / SEARCH FILTERING
     *******************************************/
    categoryButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        categoryButtons.forEach(b => b.classList.remove('selectedCat'));
        btn.classList.add('selectedCat');
        activeCategory = btn.getAttribute('data-category');
        filterTools();
      });
    });
    toolSearch.addEventListener('input', filterTools);
    function filterTools(){
      const searchVal = toolSearch.value.trim().toLowerCase();
      
      Array.from(toolElements).forEach(tool => {
        const toolName = tool.getAttribute('data-tool') || '';
        const cats = (tool.getAttribute('data-cat') || '').toLowerCase().split(',');
        
        // Tools only show in tools tab
        let inCat = (activeCategory === 'all' && !cats.includes('tools')) || cats.includes(activeCategory);
        let inSearch = !searchVal || toolName.toLowerCase().includes(searchVal);
        
        tool.style.display = (inCat && inSearch) ? 'flex' : 'none';
      });
    }
    filterTools();

    // Add acid and slime movement functions
    function moveAcid(x, y, oldT) {
      if (y+1 < GRID_SIZE && [EMPTY, WATER_VAPOR, CLOUD].includes(grid[y+1][x]) && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, ACID);
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, ACID);
            return;
          }
        }
        
        // Destroy adjacent non-cloner elements with updated behavior
        let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dx, dy] of neighbors) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== ACID && 
                grid[ny][nx] !== CLONER && grid[ny][nx] !== ACID_STEAM && 
                grid[ny][nx] !== ACID_CLOUD) {
              if (Math.random() < 0.1) {
                eraseCell(nx, ny);
                // 1/4 chance to delete itself when deleting another element
                if (Math.random() < 0.25) {
                  eraseCell(x, y);
            return;
          }
        }
      }
    }
        }
        
        // Evaporation
        if (temp[y][x] >= 100 && Math.random() < 0.1) {
          grid[y][x] = ACID_STEAM;
          temp[y][x] = 120;
        }
      }
    }

    function moveSlime(x, y, oldT) {
      if (Math.random() < 0.1) { // Very slow movement
        if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, SLIME);
        } else {
          let dirs = [];
          if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
          if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
          shuffle(dirs);
          for (let dir of dirs) {
            let nx = x + dir;
            if (grid[y][nx] === EMPTY && !moved[y][nx]) {
              moveCell(x, y, nx, y, oldT, SLIME);
              return;
            }
          }
        }
      }
    }

    // Add to conductionRates
    conductionRates[ACID] = 0.8;
    conductionRates[ACID_STEAM] = 0.6;
    conductionRates[ACID_CLOUD] = 0.3;
    conductionRates[SLIME] = 0.4;

    // Add to heatCapacities
    heatCapacities[ACID] = 1;
    heatCapacities[ACID_STEAM] = 0.5;
    heatCapacities[ACID_CLOUD] = 0.5;
    heatCapacities[SLIME] = 2;

    function transformGrass() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === GRASS) {
            // Check temperature
            if (temp[y][x] >= 200) {
              grid[y][x] = BURNING_ORGANIC;
              temp[y][x] = fireTemperature;
              burningWoodTime[y][x] = 0;
            }
            // Check for nearby fire
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === FIRE || grid[ny][nx] === BURNING_ORGANIC) {
                  grid[y][x] = BURNING_ORGANIC;
                  temp[y][x] = fireTemperature;
                  burningWoodTime[y][x] = 0;
                  break;
                }
              }
            }
          }
        }
      }
    }

    // Initialize debug elements after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });

      // Add downloadOfflineBtn event listener here
      const downloadOfflineBtn = document.getElementById('downloadOfflineBtn');
      if (downloadOfflineBtn) {
        downloadOfflineBtn.addEventListener('click', function() {
          const htmlContent = document.documentElement.outerHTML;
          const blob = new Blob([htmlContent], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'sandbox_game.html';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
      }
    });

    // Add to global variables
    let targetFps = 0;
    let popOutWindow = null;

    // Add event handlers
    document.getElementById('downloadOfflineBtn').addEventListener('click', function() {
      const htmlContent = document.documentElement.outerHTML;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sandbox_game.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    document.getElementById('dabyFps').addEventListener('change', function(e) {
      targetFps = parseInt(e.target.value);
    });

    document.getElementById('popOutMode').addEventListener('change', function(e) {
      if (parseInt(e.target.value) === 1) {
        if (!popOutWindow || popOutWindow.closed) {
          popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
          const popOutDoc = popOutWindow.document;
          
          // Create pop-out window content
          popOutDoc.write(`
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { margin: 0; background: #222; overflow: hidden; }
                #popOutGrid { width: 100%; height: 100%; }
              </style>
            </head>
            <body>
              <div id="popOutGrid"></div>
            </body>
            </html>
          `);
          
          // Move grid to pop-out window
          const originalGrid = document.getElementById('grid');
          popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
          
          // Handle window resize
          popOutWindow.addEventListener('resize', function() {
            const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
            originalGrid.style.width = size + 'px';
            originalGrid.style.height = size + 'px';
          });
          
          // Handle window close
          popOutWindow.addEventListener('unload', function() {
            if (!popOutWindow.closed) {
              document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
              originalGrid.style.width = '500px';
              originalGrid.style.height = '500px';
              document.getElementById('popOutMode').value = "0";
            }
          });
        }
      } else {
        if (popOutWindow && !popOutWindow.closed) {
          popOutWindow.close();
        }
      }
    });

    function moveBird(x, y, oldT) {
      if (moved[y][x]) return;
      
      birdTimers[y][x] += simulationTimeStep;
      
      // Change direction randomly
      if (birdTimers[y][x] >= 1.0) {
        if (Math.random() < 0.2) {
          birdDirections[y][x] *= -1;
        }
        if (Math.random() < 0.1) {
          birdYMovement[y][x] = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
        } else {
          birdYMovement[y][x] = 0;
        }
        birdTimers[y][x] = 0;
      }

      // Try to move in current direction
      let nx = x + birdDirections[y][x];
      let ny = y + birdYMovement[y][x];

      // Check boundaries and wrap around if needed
      if (nx < 0) nx = GRID_SIZE - 1;
      if (nx >= GRID_SIZE) nx = 0;
      if (ny < 0 || ny >= GRID_SIZE) {
        ny = y;
        birdYMovement[y][x] = 0;
      }

      // Check for oak leaves to eat
      let foundLeaves = false;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          let checkX = x + dx, checkY = y + dy;
          if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
            if (grid[checkY][checkX] === OAK_LEAVES || grid[checkY][checkX] === OAK_BABY_LEAVES) {
              eraseCell(checkX, checkY);
              foundLeaves = true;
            }
          }
        }
      }

      // Move if possible
      if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
        moveCell(x, y, nx, ny, oldT, BIRD);
        birdDirections[ny][nx] = birdDirections[y][x];
        birdTimers[ny][nx] = birdTimers[y][x];
        birdYMovement[ny][nx] = birdYMovement[y][x];
      }
    }

    function moveOil(x, y, oldT) {
      if (moved[y][x]) return;
      
      if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, OIL);
      } else if (y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]) {
        // Oil floats on water
        let tempWater = temp[y+1][x];
        grid[y+1][x] = OIL;
        temp[y+1][x] = oldT;
        grid[y][x] = WATER;
        temp[y][x] = tempWater;
        moved[y+1][x] = true;
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, OIL);
            return;
          }
        }
      }
    }

    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('auxclick', e => {
      if (e.button === 1) { // Middle click
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const element = grid[y][x];
        if (element === EMPTY) return;

        // Find the tool element for this element
        const tools = Array.from(toolElements);
        for (const tool of tools) {
          if (getToolElementId(tool.getAttribute('data-tool')) === element) {
            // Select the tool
            selectTool(tool);
            
            // Find its category
            const category = tool.getAttribute('data-cat');
            if (category) {
              // Select the category
              const categoryButtons = document.querySelectorAll('#categoryMenu button');
              categoryButtons.forEach(btn => {
                if (btn.getAttribute('data-category') === category) {
                  btn.click();
                  
                  // Wait for DOM update then scroll tool into view
                  setTimeout(() => {
                    tool.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }, 100);
                }
              });
            }
            break;
          }
        }
      }
    });

    // Helper function to get element ID from tool name
    function getToolElementId(toolName) {
      switch(toolName) {
        case "eraser": return ERASER;
        case "sand": return SAND;
        case "wall": return WALL;
        case "water": return WATER;
        case "lava": return LAVA;
        case "stone": return STONE;
        case "water-vapor": return WATER_VAPOR;
        case "copper": return COPPER;
        case "steel": return STEEL;
        case "ice": return ICE;
        case "wood": return WOOD;
        case "fire": return FIRE;
        case "smoke": return SMOKE;
        case "ash": return ASH;
        case "glass": return GLASS;
        case "bomb": return BOMB;
        case "dirt": return DIRT;
        case "wet-dirt": return WET_DIRT;
        case "wheat-seeds": return WHEAT_SEEDS;
        case "flour": return FLOUR;
        case "dough": return DOUGH;
        case "bread": return BREAD;
        case "plant-root": return ROOT;
        case "spark": return SPARK;
        case "oak-seeds": return OAK_SEEDS;
        case "grass": return GRASS;
        case "gas": return GAS;
        case "cooler": return COOLER;
        case "heater": return HEATER;
        case "heat-separator": return HEAT_SEPARATOR;
        case "input": return INPUT;
        case "output": return OUTPUT;
        case "not-gate": return NOT_GATE;
        case "and-gate": return AND_GATE;
        case "blocker": return BLOCKER;
        case "cloner": return CLONER;
        case "coal": return COAL;
        case "coal-lump": return COAL_LUMP;
        case "thermite": return THERMITE;
        case "acid": return ACID;
        case "slime": return SLIME;
        case "carbon-dioxide": return CARBON_DIOXIDE;
        case "oxygen": return OXYGEN;
        case "bird": return BIRD;
        case "meat": return MEAT;
        case "cooked-meat": return COOKED_MEAT;
        case "cobblestone": return COBBLESTONE;
        case "oil": return OIL;
        case "example-element": return EXAMPLE_ELEMENT;
        case "big-bomb": return BIG_BOMB;
        case "water-bomb": return WATER_BOMB;
        case "fire-bomb": return FIRE_BOMB;
        case "cryo-bomb": return CRYO_BOMB;
        case "nuke-bomb": return NUKE_BOMB;
        default: return null;
      }
    }

    // Add touch support
    let lastTouchX = null;
    let lastTouchY = null;
    let touchStartTime = 0;
    let isTouchActive = false;

    gridContainer.addEventListener('touchstart', function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      lastTouchX = x;
      lastTouchY = y;
      hoveredX = x;
      hoveredY = y;
      touchStartTime = Date.now();
      isTouchActive = true;
      isLeftMouseDown = true;
      spamPlace();
      updateHoverOverlay();
    });

    gridContainer.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!isTouchActive) return;
      
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      
      // Only update if position changed
      if (x !== lastTouchX || y !== lastTouchY) {
        hoveredX = x;
        hoveredY = y;
        lastTouchX = x;
        lastTouchY = y;
        spamPlace();
        updateHoverOverlay();
        
        // Update HUD
        if (temp[y][x] !== null) {
          hudTemp.textContent = `Temp: ${temp[y][x].toFixed(1)} Â°C`;
          hudElem.textContent = `Element: ${getElementName(grid[y][x])}`;
        }
      }
    });

    gridContainer.addEventListener('touchend', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    gridContainer.addEventListener('touchcancel', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    // Update getMousePos to better handle touch events
    function getMousePos(e) {
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let clientX = e.clientX || e.touches[0].clientX;
      let clientY = e.clientY || e.touches[0].clientY;
      let px = Math.floor((clientX - rect.left) / cellSize);
      let py = Math.floor((clientY - rect.top) / cellSize);
      return { 
        x: Math.max(0, Math.min(GRID_SIZE - 1, px)), 
        y: Math.max(0, Math.min(GRID_SIZE - 1, py)) 
      };
    }

    // Initialize dynamic lighting system
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // Add light-emitting properties for elements
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };

    // Add lighting calculation function
    function calculateLighting() {
      if (!window.isDynamicLightingEnabled) return;
      
      // Reset light levels
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          window.lightLevels[y][x] = 0;
          window.lightColors[y][x] = null;
        }
      }

      // Calculate light emission
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          const emitter = window.lightEmitters[element];
          
          if (emitter) {
            // Spread light in a radius
            const radius = Math.floor(emitter.intensity * 5);
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  if (distance <= radius) {
                    const intensity = (1 - distance / radius) * emitter.intensity;
                    window.lightLevels[ny][nx] = Math.max(window.lightLevels[ny][nx], intensity);
                    if (!window.lightColors[ny][nx]) window.lightColors[ny][nx] = emitter.color;
                    else {
                      // Mix colors based on intensity
                      const currentColor = window.lightColors[ny][nx];
                      const r1 = parseInt(currentColor.slice(1, 3), 16);
                      const g1 = parseInt(currentColor.slice(3, 5), 16);
                      const b1 = parseInt(currentColor.slice(5, 7), 16);
                      const r2 = parseInt(emitter.color.slice(1, 3), 16);
                      const g2 = parseInt(emitter.color.slice(3, 5), 16);
                      const b2 = parseInt(emitter.color.slice(5, 7), 16);
                      const mix = intensity / (window.lightLevels[ny][nx] + intensity);
                      const r = Math.round(r1 * (1 - mix) + r2 * mix);
                      const g = Math.round(g1 * (1 - mix) + g2 * mix);
                      const b = Math.round(b1 * (1 - mix) + b2 * mix);
                      window.lightColors[ny][nx] = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Modify renderCell to include lighting
    const originalRenderCell = window.renderCell;
    window.renderCell = function(x, y) {
      originalRenderCell(x, y);
      const cell = cells[y][x];
      
      if (window.isDynamicLightingEnabled && window.lightLevels[y][x] > 0) {
        cell.classList.add('lit');
        const element = grid[y][x];
        
        if (element === GLASS) {
          // Glass reflects nearby light with a slight tint
          const color = window.lightColors[y][x];
          const intensity = window.lightLevels[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = intensity * 0.3;
        } else if (element === EMPTY) {
          // Empty cells show light more prominently
          const color = window.lightColors[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = window.lightLevels[y][x] * 0.2;
        } else {
          // Other cells get a slight glow effect
          const lightColor = window.lightColors[y][x];
          if (lightColor) {
            cell.style.boxShadow = `0 0 ${window.lightLevels[y][x] * 10}px ${lightColor}`;
          }
        }
      } else {
        cell.classList.remove('lit');
        cell.style.boxShadow = '';
      }
    };

    // Add lighting calculation to game loop
    const originalGameLoop = window.gameLoop;
    window.gameLoop = function(timestamp) {
      if (window.isDynamicLightingEnabled) {
        calculateLighting();
      }
      originalGameLoop(timestamp);
    };

    // Initialize dynamic lighting toggle
    function initializeDynamicLighting() {
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.addEventListener('change', function(e) {
          window.isDynamicLightingEnabled = parseInt(e.target.value) === 1;
          alert('Dynamic Lighting ' + (window.isDynamicLightingEnabled ? 'Enabled' : 'Disabled')); // Immediate feedback
          
          if (!window.isDynamicLightingEnabled) {
            // Clear all lighting effects
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                const cell = cells[y][x];
                cell.classList.remove('lit');
                cell.style.boxShadow = '';
                if (grid[y][x] === EMPTY) {
                  cell.style.backgroundColor = '';
                  cell.style.opacity = '';
                }
              }
            }
          }
        });
      }
    }

    // Call initialization when document is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeDynamicLighting);
    } else {
      initializeDynamicLighting();
    }

    // Add to applyOptionsButton click handler
    document.getElementById('applyOptionsButton').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('stageSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        initGrid(newSize);
        // Only reinitialize lighting arrays if size changed
        window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      }
      optionsModal.style.display = 'none';
    });

    // Handle grid size change
    document.getElementById('applyGridSize').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('gridSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        GRID_SIZE = newSize;
        initGrid();
        
        // Reinitialize DSPLE if it's enabled
        if (window.isDspleEnabled) {
          // Clean up existing lighting engine
          cleanupDspleLightingEngine();
          // Reinitialize with new grid size
          initDspleLightingEngine();
        }
        
        renderGrid();
      }
    });

    // Community Feature Implementation
    const SERVER_URL = 'http://localhost:8700';
    let communityUserData = null;
    let loginAttempts = 0;
    let selectedLocalSave = null;
    let communitySaves = [];
    
    // Initialize Community elements after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize Community Modal
      const communityModal = document.getElementById('communityModal');
      const communityButton = document.getElementById('communityButton');
      const closeCommunityModal = document.getElementById('closeCommunityModal');
      
      if (!communityButton || !communityModal) {
        console.error('Community elements not found');
        return;
      }
      
      // Community sections
      const communityLoginSection = document.getElementById('communityLoginSection');
      const communityContent = document.getElementById('communityContent');
    
      // Login/Register elements
      const communityUsername = document.getElementById('communityUsername');
      const communityEmail = document.getElementById('communityEmail');
      const communityPassword = document.getElementById('communityPassword');
      const communityLoginBtn = document.getElementById('communityLoginBtn');
      const communityRegisterBtn = document.getElementById('communityRegisterBtn');
      const communityLoginMessage = document.getElementById('communityLoginMessage');
      
      // Community content tabs
      const communityTabBtns = document.querySelectorAll('.community-tab-btn');
      const communityTabContents = document.querySelectorAll('.community-tab-content');
      
      // Community saves list and filters
      const communitySavesList = document.getElementById('communitySavesList');
      const communitySortFilter = document.getElementById('communitySortFilter');
      const communitySearchFilter = document.getElementById('communitySearchFilter');
      
      // Upload section
      const communityLocalSavesList = document.getElementById('communityLocalSavesList');
      const communityUploadTitle = document.getElementById('communityUploadTitle');
      const communityUploadDescription = document.getElementById('communityUploadDescription');
      const communityUploadBtn = document.getElementById('communityUploadBtn');
      const communityUploadMessage = document.getElementById('communityUploadMessage');
    
    // Open Community Modal
      communityButton.addEventListener('click', function() {
        communityModal.style.display = 'block';
        
        // If user is logged in, load community saves
        if (communityUserData) {
          loadCommunitySaves();
          loadLocalSaves();
        }
      });
      
      // Close Community Modal
      closeCommunityModal.addEventListener('click', function() {
        communityModal.style.display = 'none';
      });
      
      // Tab switching
      communityTabBtns.forEach(btn => {
        btn.addEventListener('click', function() {
          const tabName = this.getAttribute('data-tab');
          
          // Update active tab button
          communityTabBtns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          
          // Show selected tab content
          communityTabContents.forEach(content => {
            content.classList.remove('active');
            if (content.id === tabName + 'CommunityTab') {
              content.classList.add('active');
            }
          });
          
          // Load data for the selected tab
          if (tabName === 'browse') {
            loadCommunitySaves();
          } else if (tabName === 'upload') {
            loadLocalSaves();
          }
        });
      });
      
      // Login functionality
      communityLoginBtn.addEventListener('click', function() {
      const username = communityUsername.value.trim();
      const email = communityEmail.value.trim();
      const password = communityPassword.value;
      
      if (!username || !email) {
        showLoginMessage('Please enter both username and email', 'error');
        return;
      }
      
      // Check login attempts
      if (loginAttempts >= 5) {
        showLoginMessage('Too many login attempts. Please try again later.', 'error');
        return;
      }
      
      loginAttempts++;
      
      // Simulate login for now (would be replaced with actual server call)
      loginUser(username, email, password)
        .then(response => {
          if (response.success) {
            communityUserData = response.userData;
            showLoginMessage('Login successful!', 'success');
            
            // Show community content
            communityLoginSection.style.display = 'none';
            communityContent.style.display = 'block';
            
            // Load community saves
            loadCommunitySaves();
          } else {
            showLoginMessage(response.message || 'Login failed. Please check your credentials.', 'error');
          }
        })
        .catch(error => {
          showLoginMessage('Error connecting to server. Please try again later.', 'error');
          console.error('Login error:', error);
        });
    });
    
    // Register functionality
    communityRegisterBtn.addEventListener('click', function() {
      const username = communityUsername.value.trim();
      const email = communityEmail.value.trim();
      const password = communityPassword.value;
      
      if (!username || !email) {
        showLoginMessage('Please enter both username and email', 'error');
        return;
      }
      
      // Simulate registration for now (would be replaced with actual server call)
      registerUser(username, email, password)
        .then(response => {
          if (response.success) {
            communityUserData = response.userData;
            showLoginMessage('Registration successful! You are now logged in.', 'success');
            
            // Show community content
            communityLoginSection.style.display = 'none';
            communityContent.style.display = 'block';
            
            // Load community saves
            loadCommunitySaves();
          } else {
            showLoginMessage(response.message || 'Registration failed. Please try again.', 'error');
          }
        })
        .catch(error => {
          showLoginMessage('Error connecting to server. Please try again later.', 'error');
          console.error('Registration error:', error);
        });
    });
    
    // Filter and sort community saves
    communitySortFilter.addEventListener('change', function() {
      filterAndSortCommunitySaves();
    });
    
    communitySearchFilter.addEventListener('input', function() {
      filterAndSortCommunitySaves();
    });
    
    // Upload save functionality
    communityUploadBtn.addEventListener('click', function() {
      const title = communityUploadTitle.value.trim();
      const description = communityUploadDescription.value.trim();
      
      if (!title) {
        communityUploadMessage.textContent = 'Please enter a title for your save';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      if (!selectedLocalSave) {
        communityUploadMessage.textContent = 'Please select a save to upload';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      // Get the save data
      const saveData = localStorage.getItem(selectedLocalSave);
      if (!saveData) {
        communityUploadMessage.textContent = 'Error retrieving save data';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      // Upload the save
      uploadSave(title, description, saveData)
        .then(response => {
          if (response.success) {
            communityUploadMessage.textContent = 'Save uploaded successfully!';
            communityUploadMessage.className = 'message success';
            
            // Clear form
            communityUploadTitle.value = '';
            communityUploadDescription.value = '';
            selectedLocalSave = null;
            
            // Update local saves list
            loadLocalSaves();
            
            // Switch to browse tab
            document.querySelector('.community-tab-btn[data-tab="browse"]').click();
          } else {
            communityUploadMessage.textContent = response.message || 'Upload failed. Please try again.';
            communityUploadMessage.className = 'message error';
          }
        })
        .catch(error => {
          communityUploadMessage.textContent = 'Error connecting to server. Please try again later.';
          communityUploadMessage.className = 'message error';
          console.error('Upload error:', error);
        });
    });
    
    // Helper Functions
    
    // Community saves functionality
    function updateCommunitySavesList() {
      const container = document.getElementById('communitySavesList');
      container.innerHTML = '<div class="loading">Loading community saves...</div>';
      
      // Fetch the list of community saves from the ./communitysaves directory
      fetchCommunitySaves()
        .then(saves => {
          container.innerHTML = '';
          
          if (saves.length === 0) {
            container.innerHTML = '<div class="no-saves">No community saves found.</div>';
            return;
          }
          
          // Sort saves by date (newest first)
          saves.sort((a, b) => b.timestamp - a.timestamp);
          
          // Create a card for each community save
          saves.forEach(save => {
            // Create a card for each saved game
            const card = document.createElement('div');
            card.className = 'save-game-card';
            
            // Create the preview section
            const previewContainer = document.createElement('div');
            previewContainer.className = 'save-preview';
            
            // Create the actual preview grid
            const previewGrid = document.createElement('div');
            previewGrid.className = 'preview-grid';
            
            // Try to load the save data to create a preview
            try {
              // Parse the save data
              const saveData = save.saveData;
              const previewSize = 10; // Small preview grid
              
              // Create a miniature grid for preview
              for (let y = 0; y < previewSize; y++) {
                for (let x = 0; x < previewSize; x++) {
                  const cell = document.createElement('div');
                  cell.className = 'preview-cell';
                  
                  // Sample from the actual grid to create preview
                  const gridX = Math.floor(x * (saveData.GRID_SIZE / previewSize));
                  const gridY = Math.floor(y * (saveData.GRID_SIZE / previewSize));
                  
                  if (saveData.grid && saveData.grid[gridY] && saveData.grid[gridY][gridX] !== undefined) {
                    const element = saveData.grid[gridY][gridX];
                    if (element !== 0) { // Not empty
                      // Get the class name for this element
                      const elementClass = getElementClass(element);
                      if (elementClass) {
                        cell.classList.add(elementClass);
                      }
                    }
                  }
                  
                  previewGrid.appendChild(cell);
                }
              }
              
              previewContainer.appendChild(previewGrid);
            } catch (err) {
              console.error('Error creating preview:', err);
              previewContainer.innerHTML = '<div class="preview-error">Preview not available</div>';
            }
            
            // Create the info section
            const infoContainer = document.createElement('div');
            infoContainer.className = 'save-info';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'save-title';
            title.textContent = save.title || 'Untitled Save';
            infoContainer.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'save-description';
            description.textContent = save.description || 'No description';
            infoContainer.appendChild(description);
            
            // Add metadata (publisher and date)
            const metadata = document.createElement('div');
            metadata.className = 'save-metadata';
            
            // Add publisher
            const publisher = document.createElement('div');
            publisher.className = 'save-publisher';
            publisher.textContent = `Publisher: ${save.publisher || 'Unknown'}`;
            metadata.appendChild(publisher);
            
            // Add date
            const date = document.createElement('div');
            date.className = 'save-date';
            date.textContent = `Date: ${new Date(save.timestamp).toLocaleDateString()}`;
            metadata.appendChild(date);
            
            // Add file size
            const size = document.createElement('div');
            size.className = 'save-size';
            size.textContent = `Size: ${formatFileSize(save.size)}`;
            metadata.appendChild(size);
            
            infoContainer.appendChild(metadata);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.className = 'load-save-button';
            loadButton.textContent = 'Load';
            loadButton.addEventListener('click', function() {
              loadCommunitySave(save.filename);
              communityModal.style.display = 'none';
            });
            infoContainer.appendChild(loadButton);
            
            // Assemble the card
            card.appendChild(previewContainer);
            card.appendChild(infoContainer);
            
            // Add the card to the container
            container.appendChild(card);
          });
        })
        .catch(error => {
          console.error('Error loading community saves:', error);
          container.innerHTML = `<div class="error">Error loading community saves: ${error.message}</div>`;
        });
    }
    
    // Function to fetch community saves from the ./communitysaves directory
    async function fetchCommunitySaves() {
      // In a real implementation, this would fetch from the server or local directory
      // For now, we'll simulate reading from a directory
      
      try {
        // Simulate reading from the ./communitysaves directory
        // In a real implementation, this would use fetch or another method to get the files
        const response = await fetch('./communitysaves/index.json');
        
        // If the directory doesn't exist or there's an error, return an empty array
        if (!response.ok) {
          return [];
        }
        
        // Parse the index file that contains metadata about all community saves
        const index = await response.json();
        
        // For each save in the index, fetch the actual save data
        const saves = await Promise.all(index.map(async (save) => {
          try {
            const saveResponse = await fetch(`./communitysaves/${save.filename}`);
            if (!saveResponse.ok) {
              throw new Error(`Failed to load save: ${save.filename}`);
            }
            
            const saveData = await saveResponse.json();
            
            return {
              ...save,
              saveData
            };
          } catch (error) {
            console.error(`Error loading save ${save.filename}:`, error);
            return save; // Return just the metadata if we can't load the save data
          }
        }));
        
        return saves;
      } catch (error) {
        console.error('Error fetching community saves:', error);
        
        // For demo purposes, return some sample saves if we can't fetch the real ones
        return getSampleCommunitySaves();
      }
    }
    
    // Function to load a community save
    function loadCommunitySave(filename) {
      // In a real implementation, this would fetch the save file from the server or local directory
      // For now, we'll simulate loading from a file
      
      fetch(`./communitysaves/${filename}`)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to load save: ${filename}`);
          }
          return response.json();
        })
        .then(save => {
          // Load the save data into the game
          loadSaveData(save);
        })
        .catch(error => {
          console.error('Error loading community save:', error);
          alert(`Error loading community save: ${error.message}`);
          
          // For demo purposes, load a sample save if we can't load the real one
          const sampleSaves = getSampleCommunitySaves();
          if (sampleSaves.length > 0) {
            loadSaveData(sampleSaves[0].saveData);
          }
        });
    }
    
    // Function to update the community saves list in the UI
    function updateCommunitySavesList() {
      const container = document.getElementById('communitySavesList');
      container.innerHTML = '<div class="loading">Loading community saves...</div>';
      
      // Fetch the list of community saves from the ./communitysaves directory
      fetchCommunitySaves()
        .then(saves => {
          container.innerHTML = '';
          
          if (saves.length === 0) {
            container.innerHTML = '<div class="no-saves">No community saves found.</div>';
            return;
          }
          
          // Sort saves by date (newest first)
          saves.sort((a, b) => b.timestamp - a.timestamp);
          
          // Create a card for each community save
          saves.forEach(save => {
            // Create a card for each saved game
            const card = document.createElement('div');
            card.className = 'save-game-card';
            
            // Create the preview section
            const previewContainer = document.createElement('div');
            previewContainer.className = 'save-preview';
            
            // Create the actual preview grid
            const previewGrid = document.createElement('div');
            previewGrid.className = 'preview-grid';
            
            // Try to load the save data to create a preview
            try {
              // Parse the save data
              const saveData = save.saveData;
              const previewSize = 10; // Small preview grid
              
              // Create a miniature grid for preview
              for (let y = 0; y < previewSize; y++) {
                for (let x = 0; x < previewSize; x++) {
                  const cell = document.createElement('div');
                  cell.className = 'preview-cell';
                  
                  // Sample from the actual grid to create preview
                  const gridX = Math.floor(x * (saveData.GRID_SIZE / previewSize));
                  const gridY = Math.floor(y * (saveData.GRID_SIZE / previewSize));
                  
                  if (saveData.grid && saveData.grid[gridY] && saveData.grid[gridY][gridX] !== undefined) {
                    const element = saveData.grid[gridY][gridX];
                    if (element !== 0) { // Not empty
                      // Get the class name for this element
                      const elementClass = getElementClass(element);
                      if (elementClass) {
                        cell.classList.add(elementClass);
                      }
                    }
                  }
                  
                  previewGrid.appendChild(cell);
                }
              }
              
              previewContainer.appendChild(previewGrid);
            } catch (err) {
              console.error('Error creating preview:', err);
              previewContainer.innerHTML = '<div class="preview-error">Preview not available</div>';
            }
            
            // Create the info section
            const infoContainer = document.createElement('div');
            infoContainer.className = 'save-info';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'save-title';
            title.textContent = save.title || 'Untitled Save';
            infoContainer.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'save-description';
            description.textContent = save.description || 'No description';
            infoContainer.appendChild(description);
            
            // Add metadata (publisher and date)
            const metadata = document.createElement('div');
            metadata.className = 'save-metadata';
            
            // Add publisher
            const publisher = document.createElement('div');
            publisher.className = 'save-publisher';
            publisher.textContent = `Publisher: ${save.publisher || 'Unknown'}`;
            metadata.appendChild(publisher);
            
            // Add date
            const date = document.createElement('div');
            date.className = 'save-date';
            date.textContent = `Date: ${new Date(save.timestamp).toLocaleDateString()}`;
            metadata.appendChild(date);
            
            // Add file size
            const size = document.createElement('div');
            size.className = 'save-size';
            size.textContent = `Size: ${formatFileSize(save.size)}`;
            metadata.appendChild(size);
            
            infoContainer.appendChild(metadata);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.className = 'load-save-button';
            loadButton.textContent = 'Load';
            loadButton.addEventListener('click', function() {
              loadCommunitySave(save.filename);
              communityModal.style.display = 'none';
            });
            infoContainer.appendChild(loadButton);
            
            // Assemble the card
            card.appendChild(previewContainer);
            card.appendChild(infoContainer);
            
            // Add the card to the container
            container.appendChild(card);
          });
        })
        .catch(error => {
          console.error('Error loading community saves:', error);
          container.innerHTML = `<div class="error">Error loading community saves: ${error.message}</div>`;
        });
    }
    
    // Helper function to format file size
    function formatFileSize(bytes) {
      if (bytes < 1024) {
        return bytes + ' B';
      } else if (bytes < 1024 * 1024) {
        return (bytes / 1024).toFixed(1) + ' KB';
      } else {
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }
    }
    
    // Helper function to get sample community saves for demo purposes
    function getSampleCommunitySaves() {
      // Create some sample saves for demonstration
      return [
        {
          filename: 'sample1.dbr',
          title: 'Desert Oasis',
          description: 'A beautiful desert oasis with water and plants',
          publisher: 'SandboxMaster',
          timestamp: Date.now() - 86400000 * 3, // 3 days ago
          size: 15240,
          saveData: createSampleSaveData(50, 'desert')
        },
        {
          filename: 'sample2.dbr',
          title: 'Volcano Eruption',
          description: 'Watch out for the lava!',
          publisher: 'LavaLover',
          timestamp: Date.now() - 86400000 * 7, // 7 days ago
          size: 18360,
          saveData: createSampleSaveData(50, 'volcano')
        },
        {
          filename: 'sample3.dbr',
          title: 'Underwater City',
          description: 'A city built entirely underwater',
          publisher: 'NeptuneKing',
          timestamp: Date.now() - 86400000 * 14, // 14 days ago
          size: 22480,
          saveData: createSampleSaveData(50, 'underwater')
        }
      ];
    }
    
    // Helper function to create sample save data for demo purposes
    function createSampleSaveData(size, theme) {
      // Create a basic grid with the specified theme
      const grid = Array(size).fill().map(() => Array(size).fill(0));
      const temp = Array(size).fill().map(() => Array(size).fill(20));
      const colorVariations = Array(size).fill().map(() => Array(size).fill(null));
      
      // Fill the grid based on the theme
      if (theme === 'desert') {
        // Create a desert landscape with sand and a small oasis
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (y > size / 2) {
              grid[y][x] = 4; // Sand
              temp[y][x] = 30; // Hot temperature
            }
          }
        }
        
        // Add an oasis in the center
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        const oasisRadius = Math.floor(size / 10);
        
        for (let y = centerY - oasisRadius; y <= centerY + oasisRadius; y++) {
          for (let x = centerX - oasisRadius; x <= centerX + oasisRadius; x++) {
            if (y >= 0 && y < size && x >= 0 && x < size) {
              const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
              if (distance < oasisRadius) {
                grid[y][x] = 2; // Water
                temp[y][x] = 20; // Normal temperature
              }
            }
          }
        }
      } else if (theme === 'volcano') {
        // Create a volcano landscape with stone and lava
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (y > size / 2) {
              grid[y][x] = 5; // Stone
              temp[y][x] = 20; // Normal temperature
            }
          }
        }
        
        // Add a volcano in the center
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        const volcanoRadius = Math.floor(size / 8);
        
        for (let y = centerY - volcanoRadius; y <= centerY + volcanoRadius; y++) {
          for (let x = centerX - volcanoRadius; x <= centerX + volcanoRadius; x++) {
            if (y >= 0 && y < size && x >= 0 && x < size) {
              const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
              if (distance < volcanoRadius) {
                grid[y][x] = 3; // Lava
                temp[y][x] = 1200; // Very hot temperature
              }
            }
          }
        }
      } else if (theme === 'underwater') {
        // Create an underwater landscape with water and some structures
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            grid[y][x] = 2; // Water
            temp[y][x] = 10; // Cold temperature
          }
        }
        
        // Add some underwater structures
        for (let i = 0; i < 5; i++) {
          const structX = Math.floor(Math.random() * size);
          const structY = Math.floor(Math.random() * size);
          const structSize = Math.floor(Math.random() * 5) + 3;
          
          for (let y = structY - structSize; y <= structY + structSize; y++) {
            for (let x = structX - structSize; x <= structX + structSize; x++) {
              if (y >= 0 && y < size && x >= 0 && x < size) {
                const distance = Math.sqrt(Math.pow(x - structX, 2) + Math.pow(y - structY, 2));
                if (distance < structSize) {
                  grid[y][x] = 5; // Stone
                  temp[y][x] = 10; // Cold temperature
                }
              }
            }
          }
        }
      }
      
      // Return the sample save data
      return {
        GRID_SIZE: size,
        grid,
        temp,
        colorVariations,
        // Add other necessary properties with default values
        vaporLife: Array(size).fill().map(() => Array(size).fill(0)),
        cloudLife: Array(size).fill().map(() => Array(size).fill(0)),
        fireLife: Array(size).fill().map(() => Array(size).fill(0)),
        smokeLife: Array(size).fill().map(() => Array(size).fill(0)),
        burningWoodTime: Array(size).fill().map(() => Array(size).fill(0)),
        wheatHeight: Array(size).fill().map(() => Array(size).fill(0)),
        wheatMaxHeight: Array(size).fill().map(() => Array(size).fill(3)),
        seedGrowthTime: Array(size).fill().map(() => Array(size).fill(0)),
        rootLife: Array(size).fill().map(() => Array(size).fill(0)),
        sparkLife: Array(size).fill().map(() => Array(size).fill(0)),
        sparkTimer: Array(size).fill().map(() => Array(size).fill(0)),
        smokeMaxLife: Array(size).fill().map(() => Array(size).fill(30)),
        cloudMaxLife: Array(size).fill().map(() => Array(size).fill(100)),
        branchLevel: Array(size).fill().map(() => Array(size).fill(0)),
        branchLen: Array(size).fill().map(() => Array(size).fill(0)),
        branchMaxArr: Array(size).fill().map(() => Array(size).fill(0)),
        branchSubCount: Array(size).fill().map(() => Array(size).fill(0)),
        branchDirX: Array(size).fill().map(() => Array(size).fill(0)),
        branchDirY: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeGrowthTime: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeHeight: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeMaxHeight: Array(size).fill().map(() => Array(size).fill(10)),
        oakTreeRootTimer: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeRootDepth: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeRootMax: Array(size).fill().map(() => Array(size).fill(5)),
        grassStage: Array(size).fill().map(() => Array(size).fill(0)),
        burningGasTime: Array(size).fill().map(() => Array(size).fill(0)),
        chargedStateTime: Array(size).fill().map(() => Array(size).fill(0))
      };
    }
    
    // Show login message
    function showLoginMessage(message, type) {
      communityLoginMessage.textContent = message;
      communityLoginMessage.className = 'message ' + type;
    }
    
    // Login user
    async function loginUser(username, email, password) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful login if username and email are provided
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // For demo purposes, always succeed if both username and email are provided
        if (username && email) {
          return {
            success: true,
            userData: {
              username,
              email,
              id: 'user_' + Date.now()
            }
          };
        } else {
          return {
            success: false,
            message: 'Invalid username or email'
          };
        }
      } catch (error) {
        console.error('Login error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Register user
    async function registerUser(username, email, password) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful registration
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // For demo purposes, always succeed if both username and email are provided
        if (username && email) {
          return {
            success: true,
            userData: {
              username,
              email,
              id: 'user_' + Date.now()
            }
          };
        } else {
          return {
            success: false,
            message: 'Invalid username or email'
          };
        }
      } catch (error) {
        console.error('Registration error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Load community saves
    async function loadCommunitySaves() {
      // Show loading state
      communitySavesList.innerHTML = '<div class="community-loading">Loading community saves...</div>';
      
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate loading community saves
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Generate some sample community saves
        communitySaves = [
          {
            id: 'save1',
            title: 'Amazing Volcano',
            description: 'A huge volcano with lava flowing down into a water lake, creating steam and obsidian.',
            author: 'LavaLover42',
            date: '2025-05-01',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save2',
            title: 'Working Computer',
            description: 'A functional 4-bit computer built using the logic gates. Can perform basic arithmetic!',
            author: 'DigitalGenius',
            date: '2025-04-28',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save3',
            title: 'Ecosystem Simulation',
            description: 'A balanced ecosystem with plants, water cycle, and birds. Can run for hours without intervention!',
            author: 'NatureNerd',
            date: '2025-05-08',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save4',
            title: 'Rube Goldberg Machine',
            description: 'An elaborate chain reaction using sand, water, and explosives. Very satisfying to watch!',
            author: 'MechanicalMaster',
            date: '2025-05-05',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save5',
            title: 'Fireworks Display',
            description: 'A timed sequence of different colored explosions. Perfect for celebrations!',
            author: 'PyroTechnician',
            date: '2025-04-15',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          }
        ];
        
        // Display the saves
        filterAndSortCommunitySaves();
        
        return true;
      } catch (error) {
        console.error('Error loading community saves:', error);
        communitySavesList.innerHTML = '<div class="community-loading">Error loading saves. Please try again later.</div>';
        return false;
      }
    }
    
    // Filter and sort community saves
    function filterAndSortCommunitySaves() {
      const searchTerm = communitySearchFilter.value.toLowerCase();
      const sortOption = communitySortFilter.value;
      
      // Filter saves based on search term
      let filteredSaves = communitySaves.filter(save => {
        return save.title.toLowerCase().includes(searchTerm) || 
               save.author.toLowerCase().includes(searchTerm) || 
               save.description.toLowerCase().includes(searchTerm);
      });
      
      // Sort saves based on selected option
      if (sortOption === 'newest') {
        filteredSaves.sort((a, b) => new Date(b.date) - new Date(a.date));
      } else if (sortOption === 'oldest') {
        filteredSaves.sort((a, b) => new Date(a.date) - new Date(b.date));
      } else if (sortOption === 'name') {
        filteredSaves.sort((a, b) => a.title.localeCompare(b.title));
      }
      
      // Display the filtered and sorted saves
      displayCommunitySaves(filteredSaves);
    }
    
    // Display community saves
    function displayCommunitySaves(saves) {
      if (saves.length === 0) {
        communitySavesList.innerHTML = '<div class="community-loading">No saves found matching your criteria.</div>';
        return;
      }
      
      communitySavesList.innerHTML = '';
      
      saves.forEach(save => {
        const saveCard = document.createElement('div');
        saveCard.className = 'community-save-card';
        
        const savePreview = document.createElement('div');
        savePreview.className = 'community-save-preview';
        
        const previewImg = document.createElement('img');
        previewImg.src = save.preview;
        previewImg.alt = save.title;
        savePreview.appendChild(previewImg);
        
        const saveTitle = document.createElement('div');
        saveTitle.className = 'community-save-title';
        saveTitle.textContent = save.title;
        
        const saveAuthor = document.createElement('div');
        saveAuthor.className = 'community-save-author';
        saveAuthor.textContent = `By: ${save.author}`;
        
        const saveDate = document.createElement('div');
        saveDate.className = 'community-save-date';
        saveDate.textContent = `Uploaded: ${formatDate(save.date)}`;
        
        const saveDescription = document.createElement('div');
        saveDescription.className = 'community-save-description';
        saveDescription.textContent = save.description;
        
        const saveActions = document.createElement('div');
        saveActions.className = 'community-save-actions';
        
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download';
        downloadBtn.addEventListener('click', () => downloadCommunitySave(save.id));
        saveActions.appendChild(downloadBtn);
        
        saveCard.appendChild(savePreview);
        saveCard.appendChild(saveTitle);
        saveCard.appendChild(saveAuthor);
        saveCard.appendChild(saveDate);
        saveCard.appendChild(saveDescription);
        saveCard.appendChild(saveActions);
        
        communitySavesList.appendChild(saveCard);
      });
    }
    
    // Format date for display
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    }
    
    // Load local saves
    function loadLocalSaves() {
      communityLocalSavesList.innerHTML = '';
      selectedLocalSave = null;
      communityUploadBtn.disabled = true;
      
      // Get all save keys from localStorage
      const saveKeys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('sandboxSave_')) {
          saveKeys.push(key);
        }
      }
      
      if (saveKeys.length === 0) {
        communityLocalSavesList.innerHTML = '<div class="local-save-item">No local saves found. Create a save first!</div>';
        return;
      }
      
      // Display each save
      saveKeys.forEach(key => {
        try {
          const saveData = JSON.parse(localStorage.getItem(key));
          const saveItem = document.createElement('div');
          saveItem.className = 'local-save-item';
          saveItem.textContent = saveData.name || 'Unnamed Save';
          saveItem.dataset.key = key;
          
          saveItem.addEventListener('click', function() {
            // Deselect all other saves
            document.querySelectorAll('.local-save-item').forEach(item => {
              item.classList.remove('selected');
            });
            
            // Select this save
            this.classList.add('selected');
            selectedLocalSave = this.dataset.key;
            
            // Enable upload button
            communityUploadBtn.disabled = false;
            
            // Set default title if empty
            if (!communityUploadTitle.value) {
              communityUploadTitle.value = saveData.name || 'My Creation';
            }
          });
          
          communityLocalSavesList.appendChild(saveItem);
        } catch (error) {
          console.error('Error parsing save data:', error);
        }
      });
    }
    
    // Upload save to server
    async function uploadSave(title, description, saveData) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful upload
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // For demo purposes, always succeed
        return {
          success: true,
          message: 'Save uploaded successfully!'
        };
      } catch (error) {
        console.error('Upload error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Download community save
    async function downloadCommunitySave(saveId) {
      try {
        // Find the save in our local array
        const save = communitySaves.find(s => s.id === saveId);
        if (!save) {
          alert('Save not found');
          return;
        }
        
        // In a real implementation, this would fetch the save data from the server
        // For now, we'll simulate a successful download with a placeholder save
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Create a placeholder save
        const placeholderSave = {
          name: save.title,
          description: save.description,
          author: save.author,
          date: save.date,
          grid: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)),
          temp: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(20))
        };
        
        // Save to localStorage
        const saveKey = 'sandboxSave_community_' + Date.now();
        localStorage.setItem(saveKey, JSON.stringify(placeholderSave));
        
        alert(`"${save.title}" has been downloaded and saved to your local saves!`);
        
        return true;
      } catch (error) {
        console.error('Download error:', error);
        alert('Error downloading save. Please try again later.');
        return false;
      }
    }
    
      // Server Communication Module (for a real implementation)
      // This would be replaced with actual server communication code
      
      // Example server communication code (commented out for now):
      /*
      // Function to securely communicate with the server
      async function serverRequest(endpoint, method = 'GET', data = null) {
        try {
          const options = {
            method,
            headers: {
              'Content-Type': 'application/json'
            },
            credentials: 'include' // Include cookies for session management
          };
          
          if (data && (method === 'POST' || method === 'PUT')) {
            options.body = JSON.stringify(data);
          }
          
          const response = await fetch(`${SERVER_URL}/${endpoint}`, options);
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'Server error');
          }
          
          return await response.json();
        } catch (error) {
          console.error(`Error in ${endpoint}:`, error);
          throw error;
        }
      }
      
      // Login user
      async function loginUser(username, email, password) {
        return serverRequest('auth/login', 'POST', { username, email, password });
      }
      
      // Register user
      async function registerUser(username, email, password) {
        return serverRequest('auth/register', 'POST', { username, email, password });
      }
      
      // Load community saves
      async function loadCommunitySaves() {
        return serverRequest('saves');
      }
      
      // Upload save
      async function uploadSave(title, description, saveData) {
        return serverRequest('saves/upload', 'POST', {
          title,
          description,
          saveData,
          date: new Date().toISOString()
        });
      }
      
      // Download save
      async function downloadCommunitySave(saveId) {
        return serverRequest(`saves/${saveId}`);
      }
      */
    }); // Close DOMContentLoaded event handler
  </script>



  <!-- Mod Manager Modal -->
  <div id="modMenu" class="modal">
    <div class="modal-content">
      <span id="closeModMenu" class="close">&times;</span>
      <h2>Mod Manager</h2>
      <div id="modListContainer">
        <!-- Mod cards will be dynamically inserted here -->
      </div>
      <button id="addModButton">+ Add New Mod</button>
    </div>
  </div>

  <!-- Add New Mod Modal (only mod code textarea, forced mod info comes from code) -->
  <div id="addModModal" class="modal">
    <div class="modal-content">
      <span id="closeAddModModal" class="close">&times;</span>
      <h2>Add New Mod</h2>
      <textarea id="newModCode" rows="10" placeholder="Paste your mod JS code here"></textarea>
      <button id="saveNewModButton">Save Mod</button>
    </div>
  </div>
  


  <!-- Options Modal -->
  <div id="optionsModal" class="modal">
    <div class="modal-content">
      <span id="closeOptionsModal" class="close">&times;</span>
      <h2>Options</h2>
      <div class="options-content">
        <div class="options-section">
          <h3>Game Options</h3>
          <div class="option-item">
            <label for="stageSizeSelect">Stage Size (Requires Canvas Clear):</label>
            <select id="stageSizeSelect">
              <option value="25">25x25x25</option>
              <option value="50" selected>50x50x50</option>
              <option value="75">75x75x75</option>
              <option value="100">100x100x100</option>
              <option value="125">125x125x125</option>
            </select>
            <p class="option-description">Larger sizes provide more space and detail, but will require more processing power.</p> <br> <p class="option-description" style="color:red;">WARNING: Changing the stage size will completely clear the current canvas. This action cannot be undone.</p>
          </div>

          <div class="option-item">
            <button id="generateTerrainBtn" class="options-button" onclick="generateTerrain()">Generate Terrain</button>
            <p class="option-description">Creates a procedurally generated world with caves, ores, and surface features.</p>
          </div>


        </div>

        <div class="options-section">
          <h3>Graphics Settings</h3>
          <div class="option-item">
            <label for="variatedColorsToggle">Variated Colors:</label>
            <select id="variatedColorsToggle">
              <option value="1" selected>Enabled</option>
              <option value="0">Disabled</option>
            </select>
            <p class="option-description">When enabled, elements will have slight color variations. When disabled, all elements will have consistent colors.</p>
            <button id="applyVariatedColors" class="options-button">Apply Setting</button>
          </div>
          
          <div class="option-item">
            <label for="dspleToggle">DSPLE (Dabicco Shader-Pixel Lighting Engine):</label>
            <select id="dspleToggle">
              <option value="0" selected>Disabled</option>
              <option value="1">Enabled</option>
            </select>
            <p class="option-description">Adds shader-based dynamic lighting to the simulation, creating realistic light effects from glowing elements. May impact performance on slower devices.</p>
            <button id="applyDsple" class="options-button">Apply Setting</button>
          </div>
        </div>

        <div class="options-section experimental">
          <h3>Experimental Features</h3>
          <div class="option-item">
            <label for="popOutMode">[UNSTABLE] Pop-Out Mode:</label>
            <select id="popOutMode">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Opens the simulation in a separate window that can be resized independently. Currently unstable and WILL cause issues.</p>
          </div>
          <div class="option-item">
            <label for="setting-dabyfps">DabyFPS:</label>
            <select id="setting-dabyfps">
              <option value="false" selected>OFF</option>
              <option value="true">ON</option>
            </select>
            <p class="option-description">DabyFPS's Main Feature, Frame Rate Stabilization (DBFRS), has already been added to the game; enable for MISC optimizations, however these can and probably will slow down the game more than it optimizes it.</p>
          </div>
          <div class="option-item" id="fps-cap-container" style="display:none;">
            <label for="setting-fps-cap">FPS Cap:</label>
            <select id="setting-fps-cap">
              <option value="30">30</option>
              <option value="60" selected>60</option>
              <option value="75">75</option>
              <option value="100">100</option>
              <option value="120">120</option>
              <option value="165">165</option>
              <option value="175">175</option>
              <option value="200">200</option>
              <option value="230">230</option>
              <option value="365">365</option>
              <option value="512">512</option>
            </select>
            <p class="option-description">Sets the FPS for the game (the speed at which the game should run at) and ensures the FPS never goes above.</p>
          </div>
        </div>
      </div>
      <button id="applyOptionsButton" style="display: none !important">Apply Required Clear Settings (WILL CLEAR CANVAS)</button>
    </div>
  </div>

  <!-- Save/Load Modal -->
  <div id="saveLoadModal" class="modal">
    <div class="modal-content">
      <span id="closeSaveLoadModal" class="close">&times;</span>
      <h2>Save / Load</h2>
      <div>
        <h3>Save Current Game</h3>
        <div class="input-group">
          <input type="text" id="saveTitle" placeholder="Save Title" maxlength="20">
          <div id="saveTitleWarning" class="input-warning"></div>
        </div>
        <div class="input-group">
          <input type="text" id="saveDescription" placeholder="Save Description" maxlength="30">
          <div id="saveDescriptionWarning" class="input-warning"></div>
        </div>
        <button id="saveGameButton">Save Game</button>
      </div>
      <hr>
      <div>
        <h3>Saved Games</h3>
        <div id="savedGamesList">
          <!-- List of saved games will appear here -->
        </div>
      </div>
      <hr>
      <div>
        <h3>Import Save File (.dbr)</h3>
        <input type="file" id="importFileInput" accept=".dbr">
        <button id="importSaveButton">Import Save</button>
      </div>
    </div>
  </div>

  <!-- Community Saves Modal -->
  <div id="communityModal" class="modal">
    <div class="modal-content">
      <span id="closeCommunityModal" class="close">&times;</span>
      <h2>Community Saves</h2>
      <div>
        <h3>Browse Community Saves</h3>
        <div id="communitySavesList">
          <!-- List of community saves will appear here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global mods list
    const modsList = [];
    // Function to parse forcedModInfo from mod code using regex
    function parseForcedModInfo(modCode) {
      const regex = /window\.forcedModInfo\s*=\s*(\{[\s\S]*?\});/m;
      const match = modCode.match(regex);
      if (match && match[1]) {
        try {
          return (new Function("return " + match[1]))();
        } catch (e) {
          console.error("Error parsing forcedModInfo:", e);
          return null;
        }
      }
      return null;
    }
    // Add the default mod (Orange Juice mod) to the modsList.
    const orangeJuiceModCode = `(function(){
      // ----------------------------------------------------------------------
      // FORCE MOD IDENTIFICATION
      // ----------------------------------------------------------------------
      window.forcedModInfo = {
        id: 'exampleElementMod',
        title: 'Example Element Mod',
        description: 'Adds a simple example element that deletes anything it touches. Great for learning how to make mods!',
        gameVersion: '0.7.1c'
      };

      // ----------------------------------------------------------------------
      // DEFINE THE NEW ELEMENT CONSTANT
      // ----------------------------------------------------------------------
      if (typeof window.EXAMPLE_ELEMENT === 'undefined') {
        window.EXAMPLE_ELEMENT = 67;
      }

      // ----------------------------------------------------------------------
      // INJECT CSS TO STYLE THE MOD'S TOOL AND CELLS
      // ----------------------------------------------------------------------
      var style = document.createElement('style');
      style.innerHTML = \`
        .tool.example-element { 
          background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
          border: 2px solid white !important;
        }
        .example-element { 
          background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
          border: 2px solid white !important;
        }
      \`;
      document.head.appendChild(style);

      // ----------------------------------------------------------------------
      // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
      // ----------------------------------------------------------------------
      if (!window.exampleElementModOriginals) {
        window.exampleElementModOriginals = {
          selectTool: selectTool,
          placeElementAt: placeElementAt,
          getElementName: getElementName,
          renderCell: renderCell,
          performSimulationStep: performSimulationStep
        };
      }

      // ----------------------------------------------------------------------
      // CREATE THE MOD TOOL BUTTON
      // ----------------------------------------------------------------------
      var exampleTool = document.createElement('div');
      exampleTool.className = 'tool example-element';
      exampleTool.setAttribute('data-tool', 'example-element');
      exampleTool.setAttribute('data-cat', 'special');
      exampleTool.title = 'Example Element';
      var span = document.createElement('span');
      span.textContent = 'EX';
      exampleTool.appendChild(span);
      toolbar.appendChild(exampleTool);
      exampleTool.addEventListener('click', function(){
        selectTool(exampleTool);
      });

      // ----------------------------------------------------------------------
      // PATCH THE selectTool FUNCTION
      // ----------------------------------------------------------------------
      selectTool = function(el) {
        var toolName = el.getAttribute('data-tool');
        if (toolName === 'example-element') {
          currentTool = EXAMPLE_ELEMENT;
          Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
          el.classList.add('selected');
        } else {
          window.exampleElementModOriginals.selectTool(el);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH THE placeElementAt FUNCTION
      // ----------------------------------------------------------------------
      placeElementAt = function(x, y, tool) {
        if (tool === EXAMPLE_ELEMENT) {
          eraseCell(x, y);
          grid[y][x] = EXAMPLE_ELEMENT;
          temp[y][x] = 20;
        } else {
          window.exampleElementModOriginals.placeElementAt(x, y, tool);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH getElementName TO SHOW EXAMPLE ELEMENT
      // ----------------------------------------------------------------------
      getElementName = function(e) {
        if (e === EXAMPLE_ELEMENT) return "Example Element";
        return window.exampleElementModOriginals.getElementName(e);
      };

      // ----------------------------------------------------------------------
      // PATCH renderCell TO RENDER EXAMPLE ELEMENT CELLS
      // ----------------------------------------------------------------------
      renderCell = function(x, y) {
        const cell = cells[y][x];
        cell.className = 'cell';
        cell.style.opacity = "";
        cell.style.backgroundColor = "";
        var e = grid[y][x];
        if (e === EXAMPLE_ELEMENT) {
          cell.classList.add('example-element');
        } else {
          window.exampleElementModOriginals.renderCell(x, y);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH performSimulationStep TO PROCESS EXAMPLE ELEMENT CELLS
      // ----------------------------------------------------------------------
      var origPerformSimStep = window.exampleElementModOriginals.performSimulationStep;
      performSimulationStep = function() {
        // Process Example Element behavior
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            if (grid[y][x] === EXAMPLE_ELEMENT && !moved[y][x]) {
              // Delete adjacent cells
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for (let [dx, dy] of neighbors) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== EXAMPLE_ELEMENT) {
                    eraseCell(nx, ny);
                  }
                }
              }
              
              // Move randomly
              let possibleMoves = [];
              for (let [dx, dy] of neighbors) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] === EMPTY) {
                    possibleMoves.push([nx, ny]);
                  }
                }
              }
              
              if (possibleMoves.length > 0) {
                let [nx, ny] = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                moveCell(x, y, nx, ny, temp[y][x], EXAMPLE_ELEMENT);
              }
            }
          }
        }
        origPerformSimStep();
      };
    })();`;

    const orangeJuiceTerminateCode = `(function(){
      if(window.exampleElementModOriginals) {
        selectTool = window.exampleElementModOriginals.selectTool;
        placeElementAt = window.exampleElementModOriginals.placeElementAt;
        getElementName = window.exampleElementModOriginals.getElementName;
        renderCell = window.exampleElementModOriginals.renderCell;
        performSimulationStep = window.exampleElementModOriginals.performSimulationStep;
      }
    })();`;

    modsList.push({
      id: 'exampleElementMod',
      title: 'Example Element Mod',
      description: 'Adds a simple example element that deletes anything it touches. Great for learning how to make mods!',
      gameVersion: '0.7.1c',
      code: orangeJuiceModCode,
      terminateCode: orangeJuiceTerminateCode,
      enabled: false
    });
    function isModCompatible(mod) {
      // Only allow mods from exact version match
      return mod.gameVersion === currentGameVersion;
    }
    function updateModListUI() {
      const container = document.getElementById('modListContainer');
      container.innerHTML = '';
      modsList.forEach(mod => {
        const card = document.createElement('div');
        card.className = 'modCard';
        const titleEl = document.createElement('h3');
        titleEl.textContent = mod.title;
        const descEl = document.createElement('p');
        descEl.textContent = mod.description;
        const versionEl = document.createElement('small');
        versionEl.textContent = "Version: " + mod.gameVersion;
        if (!isModCompatible(mod)) {
          versionEl.classList.add('incompatible');
          versionEl.title = "Incompatible! Made for version " + mod.gameVersion;
        }
        const statusEl = document.createElement('div');
        statusEl.textContent = 'Status: ' + (mod.enabled ? 'Enabled' : 'Disabled');
        const execButton = document.createElement('button');
        execButton.textContent = 'Execute Code';
        execButton.addEventListener('click', () => {
          if (!mod.enabled) {
            try {
              eval(mod.code);
              mod.enabled = true;
              updateModListUI();
            } catch (e) {
              statusEl.textContent = 'Error: ' + e;
            }
          }
        });
        const termButton = document.createElement('button');
        termButton.textContent = 'Terminate';
        termButton.addEventListener('click', () => {
          if (mod.enabled && mod.terminateCode) {
            try {
              eval(mod.terminateCode);
              mod.enabled = false;
              updateModListUI();
            } catch (e) {
              statusEl.textContent = 'Error: ' + e;
            }
          }
        });
        card.appendChild(titleEl);
        card.appendChild(descEl);
        card.appendChild(versionEl);
        card.appendChild(statusEl);
        card.appendChild(execButton);
        card.appendChild(termButton);
        container.appendChild(card);
      });
    }
    const modButton = document.getElementById('modButton');
    const modMenu = document.getElementById('modMenu');
    const closeModMenu = document.getElementById('closeModMenu');
    modButton.addEventListener('click', function() {
      modMenu.style.display = 'block';
      updateModListUI();
    });
    closeModMenu.addEventListener('click', function() {
      modMenu.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == modMenu) {
        modMenu.style.display = 'none';
      }
    });
    const addModButton = document.getElementById('addModButton');
    const addModModal = document.getElementById('addModModal');
    const closeAddModModal = document.getElementById('closeAddModModal');
    const saveNewModButton = document.getElementById('saveNewModButton');
    addModButton.addEventListener('click', function() {
      addModModal.style.display = 'block';
    });
    closeAddModModal.addEventListener('click', function() {
      addModModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == addModModal) {
        addModModal.style.display = 'none';
      }
    });
    saveNewModButton.addEventListener('click', function() {
      const modCode = document.getElementById('newModCode').value;
      if (modCode.trim() !== '') {
        const forcedInfo = parseForcedModInfo(modCode);
        if (forcedInfo && forcedInfo.id && forcedInfo.title && forcedInfo.description && forcedInfo.gameVersion) {
          const newMod = {
            id: forcedInfo.id,
            title: forcedInfo.title,
            description: forcedInfo.description,
            gameVersion: forcedInfo.gameVersion,
            code: modCode,
            terminateCode: '',
            enabled: false
          };
          modsList.push(newMod);
          updateModListUI();
          document.getElementById('newModCode').value = '';
          addModModal.style.display = 'none';
        }
      }
    });
    const optionsButton = document.getElementById('optionsButton');
    const optionsModal = document.getElementById('optionsModal');
    const closeOptionsModal = document.getElementById('closeOptionsModal');
    optionsButton.addEventListener('click', function() {
      optionsModal.style.display = 'block';
      // Initialize dynamic lighting select with current state
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.value = window.isDynamicLightingEnabled ? '1' : '0';
      }
    });
    closeOptionsModal.addEventListener('click', function() {
      optionsModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == optionsModal) {
        optionsModal.style.display = 'none';
      }
    });
    document.getElementById('applyOptionsButton').addEventListener('click', function() {
      const size = parseInt(document.getElementById('stageSizeSelect').value);
      initGrid(size);
      optionsModal.style.display = 'none';
    });
    const saveLoadButton = document.getElementById('saveLoadButton');
    const saveLoadModal = document.getElementById('saveLoadModal');
    const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');
    saveLoadButton.addEventListener('click', function() {
      saveLoadModal.style.display = 'block';
      updateSavedGamesList();
    });
    closeSaveLoadModal.addEventListener('click', function() {
      saveLoadModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == saveLoadModal) {
        saveLoadModal.style.display = 'none';
      }
    });
    
    // Community menu functionality
    const communityButton = document.getElementById('communityButton');
    const communityModal = document.getElementById('communityModal');
    const closeCommunityModal = document.getElementById('closeCommunityModal');
    communityButton.addEventListener('click', function() {
      communityModal.style.display = 'block';
      updateCommunitySavesList();
    });
    closeCommunityModal.addEventListener('click', function() {
      communityModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == communityModal) {
        communityModal.style.display = 'none';
      }
    });
    function getSaveIndex() {
      const index = localStorage.getItem("dbr_save_index");
      return index ? JSON.parse(index) : [];
    }
    function setSaveIndex(index) {
      localStorage.setItem("dbr_save_index", JSON.stringify(index));
    }
    function saveGame() {
      const title = document.getElementById('saveTitle').value.trim();
      const description = document.getElementById('saveDescription').value.trim();
      if (!title) return;
      const saveData = {
        GRID_SIZE,
        grid, temp, vaporLife, cloudLife, fireLife, smokeLife, burningWoodTime, wheatHeight, wheatMaxHeight,
        seedGrowthTime, rootLife, sparkLife, sparkTimer, smokeMaxLife, cloudMaxLife, branchLevel,
        branchLen, branchMaxArr, branchSubCount, branchDirX, branchDirY, oakTreeGrowthTime, oakTreeHeight,
        oakTreeMaxHeight, oakTreeRootTimer, oakTreeRootDepth, oakTreeRootMax, grassStage, burningGasTime,
        chargedStateTime, colorVariations
      };
      const key = "dbr_save_" + Date.now();
      localStorage.setItem(key, JSON.stringify(saveData));
      let index = getSaveIndex();
      index.push({ key, title, description, timestamp: Date.now() });
      setSaveIndex(index);
      updateSavedGamesList();
      document.getElementById('saveTitle').value = '';
      document.getElementById('saveDescription').value = '';
    }
    document.getElementById('saveGameButton').addEventListener('click', saveGame);
    function updateSavedGamesList() {
    const container = document.getElementById('savedGamesList');
    container.innerHTML = "";
    const index = getSaveIndex();
    
    index.forEach(item => {
      // Create a card for each saved game
      const card = document.createElement('div');
      card.className = 'save-game-card';
      
      // Create the preview section
      const previewContainer = document.createElement('div');
      previewContainer.className = 'save-preview';
      
      // Create the actual preview grid
      const previewGrid = document.createElement('div');
      previewGrid.className = 'preview-grid';
      
      // Try to load the save data to create a preview
      const saveData = localStorage.getItem(item.key);
      if (saveData) {
        try {
          const save = JSON.parse(saveData);
          
          // We'll show a smaller version of the grid (20x20)
          const previewSize = 20;
          previewGrid.style.gridTemplateColumns = `repeat(${previewSize}, 1fr)`;
          previewGrid.style.gridTemplateRows = `repeat(${previewSize}, 1fr)`;
          
          // Figure out how to scale down the full grid to our preview size
          const scaleFactor = save.GRID_SIZE / previewSize;
          
          // Create the tiny preview cells
          for (let y = 0; y < previewSize; y++) {
            for (let x = 0; x < previewSize; x++) {
              // Map preview coordinates to the actual saved grid
              const gridX = Math.floor(x * scaleFactor);
              const gridY = Math.floor(y * scaleFactor);
              
              // Create a cell
              const cell = document.createElement('div');
              
              // Color the cell based on what's in the saved grid
              if (gridX < save.GRID_SIZE && gridY < save.GRID_SIZE) {
                const element = save.grid[gridY][gridX];
                cell.style.backgroundColor = getElementColor(element);
              } else {
                cell.style.backgroundColor = '#000'; // Default black
              }
              
              previewGrid.appendChild(cell);
            }
          }
        } catch (e) {
          console.error("Error creating preview:", e);
        }
      }
      
      // Add the preview grid to the container
      previewContainer.appendChild(previewGrid);
      card.appendChild(previewContainer);
      
      // Create the info section with title and description
      const infoDiv = document.createElement('div');
      infoDiv.className = 'save-info';
      
      const titleDiv = document.createElement('div');
      titleDiv.className = 'save-title';
      titleDiv.textContent = item.title;
      
      const descDiv = document.createElement('div');
      descDiv.className = 'save-description';
      descDiv.textContent = item.description;
      
      infoDiv.appendChild(titleDiv);
      infoDiv.appendChild(descDiv);
      card.appendChild(infoDiv);
      
      // Create the buttons
      const buttonsDiv = document.createElement('div');
      buttonsDiv.className = 'save-buttons';
      
      const loadBtn = document.createElement('button');
      loadBtn.className = 'load-button';
      loadBtn.textContent = "Load";
      loadBtn.addEventListener('click', () => {
        // Use the existing load functionality
        const data = localStorage.getItem(item.key);
        if (data) {
          const save = JSON.parse(data);
          GRID_SIZE = save.GRID_SIZE;
          initGrid(GRID_SIZE);
          grid = save.grid;
          temp = save.temp;
          vaporLife = save.vaporLife;
          cloudLife = save.cloudLife;
          fireLife = save.fireLife;
          smokeLife = save.smokeLife;
          burningWoodTime = save.burningWoodTime;
          wheatHeight = save.wheatHeight;
          wheatMaxHeight = save.wheatMaxHeight;
          seedGrowthTime = save.seedGrowthTime;
          rootLife = save.rootLife;
          sparkLife = save.sparkLife;
          sparkTimer = save.sparkTimer;
          smokeMaxLife = save.smokeMaxLife;
          cloudMaxLife = save.cloudMaxLife;
          branchLevel = save.branchLevel;
          branchLen = save.branchLen;
          branchMaxArr = save.branchMaxArr;
          branchSubCount = save.branchSubCount;
          branchDirX = save.branchDirX;
          branchDirY = save.branchDirY;
          oakTreeGrowthTime = save.oakTreeGrowthTime;
          oakTreeHeight = save.oakTreeHeight;
          oakTreeMaxHeight = save.oakTreeMaxHeight;
          oakTreeRootTimer = save.oakTreeRootTimer;
          oakTreeRootDepth = save.oakTreeRootDepth;
          oakTreeRootMax = save.oakTreeRootMax;
          grassStage = save.grassStage;
          burningGasTime = save.burningGasTime;
          chargedStateTime = save.chargedStateTime;
          
          // Load color variations if they exist in the save data
          if (save.colorVariations) {
            colorVariations = save.colorVariations;
          } else {
            // Initialize color variations for existing elements if loading an old save
            colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            
            // Generate variations for existing elements
            const variation = 0.05;
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                if (grid[y][x] !== EMPTY) {
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                }
              }
            }
          }
          
          renderGrid();
        }
      });
      
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener('click', () => {
        // Use the existing delete functionality
        let index = getSaveIndex();
        index = index.filter(i => i.key !== item.key);
        setSaveIndex(index);
        localStorage.removeItem(item.key);
        updateSavedGamesList();
      });
      
      const exportBtn = document.createElement('button');
      exportBtn.textContent = "Export";
      exportBtn.addEventListener('click', () => {
        // Use the existing export functionality
        const data = localStorage.getItem(item.key);
        if (data) {
          const blob = new Blob([data], {type: "application/json"});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = item.title + ".dbr";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      });
      
      buttonsDiv.appendChild(loadBtn);
      buttonsDiv.appendChild(deleteBtn);
      buttonsDiv.appendChild(exportBtn);
      card.appendChild(buttonsDiv);
      
      // Add the complete card to the container
      container.appendChild(card);
    });
  }
    document.getElementById('importSaveButton').addEventListener('click', () => {
      const fileInput = document.getElementById('importFileInput');
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const save = JSON.parse(e.target.result);
          const key = "dbr_save_" + Date.now();
          localStorage.setItem(key, JSON.stringify(save));
          let index = getSaveIndex();
          index.push({ key, title: file.name, description: "Imported Save", timestamp: Date.now() });
          setSaveIndex(index);
          updateSavedGamesList();
        } catch (err) {
          console.error("Import error", err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById('stageSizeSelect').addEventListener('change', function() {
      const newSize = parseInt(this.value);
      if (newSize !== GRID_SIZE) {
        pendingStageSize = newSize;
        confirmationModal.style.display = 'block';
      } else {
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        document.getElementById('applyOptionsButton').style.display = 'none';
      }
    });

    confirmYes.addEventListener('click', function() {
      if (pendingStageSize !== null) {
        initGrid(pendingStageSize);
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        optionsModal.style.display = 'none';
      }
    });

    confirmNo.addEventListener('click', function() {
      pendingStageSize = null;
      confirmationModal.style.display = 'none';
      document.getElementById('stageSizeSelect').value = GRID_SIZE.toString();
      document.getElementById('applyOptionsButton').style.display = 'none';
    });

    // DabyFPS setting
    document.getElementById('setting-dabyfps').value = localStorage.getItem('setting-dabyfps') || 'false';
    document.getElementById('setting-dabyfps').addEventListener('change', function() {
      localStorage.setItem('setting-dabyfps', this.value);
      // Show or hide the FPS cap setting based on DabyFPS being enabled
      document.getElementById('fps-cap-container').style.display = 
        this.value === 'true' ? 'block' : 'none';
    });
    
    // FPS Cap setting
    document.getElementById('setting-fps-cap').value = localStorage.getItem('setting-fps-cap') || '60';
    document.getElementById('setting-fps-cap').addEventListener('change', function() {
      localStorage.setItem('setting-fps-cap', this.value);
    });
    
    // Show/hide FPS cap based on saved DabyFPS setting
    document.getElementById('fps-cap-container').style.display = 
      document.getElementById('setting-dabyfps').value === 'true' ? 'block' : 'none';

    // This function returns the color for each element type; I used to implement it during debugging, however it's now used for the Save/Load functionality.
    function getElementColor(element) {
    // This matches the game's element colors! Modders should use this for new elements.
    switch(element) {
      case 0: return '#000000'; // EMPTY
      case 1: return '#e6c88e'; // SAND
      case 2: return '#4286f4'; // WATER
      case 3: return '#ff4500'; // LAVA
      case 4: return '#808080'; // STONE
      case 5: return '#ffb6c1'; // ERASER
      case 6: return '#b3e6ff'; // WATER_VAPOR
      case 7: return '#ffffff'; // CLOUD
      case 8: return '#555555'; // BASALT
      case 9: return '#333333'; // OBSIDIAN
      case 10: return '#a52a2a'; // MOLTEN_SLAG
      case 11: return '#b87333'; // COPPER
      case 12: return '#aaaaaa'; // STEEL
      case 13: return '#cceeff'; // ICE
      case 14: return '#8b4513'; // WOOD
      case 15: return '#ff6600'; // FIRE
      case 16: return '#777777'; // SMOKE
      case 17: return '#a52a2a'; // BURNING_WOOD
      case 18: return '#555555'; // ASH
      case 19: return '#d3d3d3'; // GLASS
      case 20: return '#ff0000'; // BOMB
      case 21: return '#8b4513'; // DIRT
      case 22: return '#a0522d'; // WET_DIRT
      case 23: return '#f5deb3'; // WHEAT_SEEDS
      case 24: return '#f0e68c'; // WHEAT
      case 25: return '#fff8dc'; // FLOUR
      case 26: return '#f5deb3'; // DOUGH
      case 27: return '#d2b48c'; // BREAD
      case 28: return '#8b4513'; // ROOT
      case 29: return '#a52a2a'; // BURNING_ORGANIC
      case 30: return '#ffff00'; // SPARK
      case 31: return '#ffa500'; // CHARGED_COPPER
      case 32: return '#556b2f'; // OAK_SEEDS
      case 33: return '#228b22'; // OAK_LEAVES
      case 34: return '#32cd32'; // OAK_BABY_LEAVES
      case 35: return '#8b4513'; // DEAD_OAK
      case 36: return '#d2b48c'; // WET_SAND
      case 37: return '#7cfc00'; // GRASS
      case 38: return '#8b4513'; // DEAD_PLANT
      case 39: return '#a52a2a'; // BURNING_LEAVES
      case 40: return '#a52a2a'; // BURNING_ROOT
      case 41: return '#8b4513'; // DEAD_ROOT
      case 42: return '#e6e6fa'; // GAS
      case 43: return '#ff6347'; // BURNING_GAS
      case 44: return '#696969'; // WALL
      case 45: return '#cd853f'; // CHARGED_DOWN_COPPER
      case 46: return '#00bfff'; // COOLER
      case 47: return '#ff4500'; // HEATER
      case 48: return '#ffd700'; // HEAT_SEPARATOR
      case 49: return '#ffa500'; // CHARGED_HEAT_SEPARATOR
      case 50: return '#cd853f'; // CHARGED_DOWN_HEAT_SEPARATOR
      case 51: return '#00ff00'; // INPUT
      case 52: return '#7fff00'; // CHARGED_INPUT
      case 53: return '#0000ff'; // OUTPUT
      case 54: return '#1e90ff'; // CHARGED_OUTPUT
      case 55: return '#ff00ff'; // NOT_GATE
      case 56: return '#9932cc'; // AND_GATE
      case 57: return '#800080'; // BLOCKER
      case 60: return '#00ffff'; // CLONER
      case 61: return '#9370db'; // CHARGED_BLOCKER
      case 62: return '#2f4f4f'; // COAL
      case 63: return '#2f4f4f'; // COAL_LUMP
      case 64: return '#8b0000'; // BURNING_COAL
      case 65: return '#8b0000'; // BURNING_COAL_LUMP
      case 68: return '#a9a9a9'; // THERMITE
      case 69: return '#ff4500'; // BURNING_THERMITE
      case 70: return '#32cd32'; // ACID
      case 71: return '#98fb98'; // ACID_STEAM
      case 72: return '#90ee90'; // ACID_CLOUD
      case 73: return '#00ff7f'; // SLIME
      case 74: return '#d3d3d3'; // CARBON_DIOXIDE
      case 75: return '#e0ffff'; // OXYGEN
      case 76: return '#000000'; // BIRD
      case 77: return '#cd5c5c'; // MEAT
      case 78: return '#8b4513'; // COOKED_MEAT
      case 79: return '#a9a9a9'; // COBBLESTONE
      case 80: return '#000000'; // OIL
      case 81: return '#ff0000'; // BIG_BOMB
      case 82: return '#4169e1'; // WATER_BOMB
      case 83: return '#ff4500'; // FIRE_BOMB
      case 84: return '#00ffff'; // CRYO_BOMB
      case 85: return '#ff00ff'; // NUKE_BOMB
      case 86: return '#e6f7ff'; // HELIUM
      case 87: return '#ff1493'; // BOUNCY_BALL
      default: return '#333333'; // Default dark gray
    }
  }
  </script>

  <!-- Initialize all event handlers after DOM is loaded -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Debug elements
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });


      // DabyFPS handler
      const dabyFpsSelect = document.getElementById('dabyFps');
      if (dabyFpsSelect) {
        dabyFpsSelect.addEventListener('change', function(e) {
          targetFps = parseInt(e.target.value);
        });
      }

      // Pop out mode handler
      const popOutModeSelect = document.getElementById('popOutMode');
      if (popOutModeSelect) {
        popOutModeSelect.addEventListener('change', function(e) {
          if (parseInt(e.target.value) === 1) {
            if (!popOutWindow || popOutWindow.closed) {
              popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
              const popOutDoc = popOutWindow.document;
              
              // Create pop-out window content
              popOutDoc.write(`
                <!DOCTYPE html>
                <html>
                <head>
                  <style>
                    body { margin: 0; background: #222; overflow: hidden; }
                    #popOutGrid { width: 100%; height: 100%; }
                  </style>
                </head>
                <body>
                  <div id="popOutGrid"></div>
                </body>
                </html>
              `);
              
              // Move grid to pop-out window
              const originalGrid = document.getElementById('grid');
              popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
              
              // Handle window resize
              popOutWindow.addEventListener('resize', function() {
                const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
                originalGrid.style.width = size + 'px';
                originalGrid.style.height = size + 'px';
              });
              
              // Handle window close
              popOutWindow.addEventListener('unload', function() {
                if (!popOutWindow.closed) {
                  document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
                  originalGrid.style.width = '500px';
                  originalGrid.style.height = '500px';
                  document.getElementById('popOutMode').value = "0";
                }
              });
            }
          } else {
            if (popOutWindow && !popOutWindow.closed) {
              popOutWindow.close();
            }
          }
        });
      }

      // Store the current stage size
      let currentStageSize = GRID_SIZE;
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      const applyButton = document.getElementById('applyOptionsButton');

      // Update stage size select to show current size
      stageSizeSelect.value = currentStageSize.toString();

      // Handle stage size change
      stageSizeSelect.addEventListener('change', function(e) {
        const newSize = parseInt(e.target.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
      });

      // Modify applyOptionsButton click handler
      applyButton.addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          currentStageSize = newSize;
          initGrid(newSize);
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'none';
      });

      // When options modal is opened, check if size is different
      document.getElementById('optionsButton').addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'block';
      });
    });

    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>

  <script>
    // Terrain Generation - moved to global scope
    window.generateTerrain = function() {
      // Clear the grid first
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          eraseCell(x, y);
        }
      }

      // Generate surface level (about 30% down from top)
      const surfaceLevel = Math.floor(GRID_SIZE * 0.3);
      
      // Generate perlin noise for surface variation
      const surfaceNoise = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        surfaceNoise[x] = Math.sin(x * 0.1) * 3 + Math.random() * 2;
      }

      // Generate caves using a simple cellular automata approach
      let caves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
      
      // Initialize random cave seeds (increased frequency)
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (Math.random() < 0.2) { // Increased from 0.1 to 0.2
            caves[y][x] = true;
          }
        }
      }

      // Smooth caves
      for (let i = 0; i < 3; i++) {
        const newCaves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            let neighbors = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (caves[ny][nx]) neighbors++;
                }
              }
            }
            newCaves[y][x] = neighbors >= 4 || (caves[y][x] && neighbors >= 3);
          }
        }
        caves = newCaves;
      }

      // Generate terrain
      for (let x = 0; x < GRID_SIZE; x++) {
        const localSurface = Math.floor(surfaceLevel + surfaceNoise[x]);
        
        // Generate seeds and plants first
        if (Math.random() < 0.15) {
          grid[localSurface][x-1] = OAK_SEEDS;
          temp[localSurface][x-1] = 20;
        } else if (Math.random() < 0.15) {
          grid[localSurface][x-1] = WHEAT_SEEDS;
          temp[localSurface][x-1] = 20;
        }
        
        // Generate grass layer
        grid[localSurface + 1][x] = GRASS;
        temp[localSurface + 1][x] = 20;
        
        // Add atmospheric gasses
        if (Math.random() < 0.1 && localSurface > 0) {
          grid[localSurface - 1][x] = Math.random() < 0.5 ? CARBON_DIOXIDE : OXYGEN;
          temp[localSurface - 1][x] = 20;
        }
        
        // Generate dirt and occasional cobblestone layer
        for (let y = localSurface + 2; y < localSurface + 7; y++) {
          if (y >= GRID_SIZE) continue;
          if (!caves[y][x]) {
            if (Math.random() < 0.1) {
              grid[y][x] = COBBLESTONE;
            } else {
              grid[y][x] = DIRT;
            }
            temp[y][x] = 20;
          }
        }
        
        // Generate stone layer with ores
        for (let y = localSurface + 7; y < GRID_SIZE; y++) {
          if (!caves[y][x]) {
            if (Math.random() < 0.05) { // Ore generation
              const depth = y / GRID_SIZE; // 0 to 1, deeper = higher
              if (depth > 0.8 && Math.random() < 0.3) { // Deep ores
                grid[y][x] = STEEL;
              } else if (depth > 0.6 && Math.random() < 0.3) { // Mid-deep ores
                grid[y][x] = COPPER;
              } else if (Math.random() < 0.4) { // Common ore
                grid[y][x] = COAL;
              } else {
                grid[y][x] = STONE;
              }
            } else {
              grid[y][x] = STONE;
            }
            temp[y][x] = 20;
          }
        }
      }

      // Add water/lava to caves
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.02) { // Increased from 0.01 to 0.02
            const isLava = y > GRID_SIZE * 0.7 && Math.random() < 0.3;
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 50;

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = isLava ? LAVA : WATER;
                temp[cy][cx] = isLava ? 1200 : 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add oil deposits near bottom
      for (let y = Math.floor(GRID_SIZE * 0.8); y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.03) {
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 30; // Smaller oil deposits

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = OIL;
                temp[cy][cx] = 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add random birds near surface
      for (let y = 0; y < surfaceLevel; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === EMPTY && Math.random() < 0.01) {
            grid[y][x] = BIRD;
            temp[y][x] = 20;
          }
        }
      }
    };
  </script>
</body>
</html>