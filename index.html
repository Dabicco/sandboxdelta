
<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    // Global error handler to catch unhandled exceptions
    window.onerror = function(message, source, lineno, colno, error) {
      // List of errors to ignore (using message content for identification)
      const ignoredErrors = [
        { text: "Cannot read properties of null (reading 'addEventListener')", line: 11994 },
        { text: "WebAssembly.compile(): invalid value type", line: null },
        { text: "confirmationModal is not defined", line: 14618 },
        { text: "Cannot read properties of undefined (reading '0')", line: 12979 }
      ];
      
      // Check if this is an error we should ignore
      for (const ignored of ignoredErrors) {
        if (message.includes(ignored.text) && (ignored.line === null || lineno === ignored.line)) {
          console.warn(`Ignoring known error: ${message}`);
          return true; // Prevent the error from showing
        }
      }
      
      // Additional safeguard - ignore any errors related to these components
      if (message.includes("addEventListener") || 
          message.includes("WebAssembly") || 
          message.includes("confirmationModal")) {
        console.warn(`Ignoring error with known keywords: ${message}`);
        return true;
      }
      
      // Only handle serious errors, not just warnings
      if (error) {
        // Log the error details to console
        console.error('Sandbox Delta crashed:', error);
        console.error('Error details:', { message, source, lineno, colno });
        
        // Create error overlay
        const errorOverlay = document.createElement('div');
        errorOverlay.style.position = 'fixed';
        errorOverlay.style.top = '0';
        errorOverlay.style.left = '0';
        errorOverlay.style.width = '100%';
        errorOverlay.style.height = '100%';
        errorOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
        errorOverlay.style.color = '#ff5555';
        errorOverlay.style.fontFamily = '"Courier New", monospace';
        errorOverlay.style.fontSize = '24px';
        errorOverlay.style.textAlign = 'center';
        errorOverlay.style.padding = '50px';
        errorOverlay.style.boxSizing = 'border-box';
        errorOverlay.style.zIndex = '999999';
        errorOverlay.style.display = 'flex';
        errorOverlay.style.flexDirection = 'column';
        errorOverlay.style.alignItems = 'center';
        errorOverlay.style.justifyContent = 'center';
        
        // Error content
        errorOverlay.innerHTML = `
          <div style="font-size: 48px; color: #ff0000; margin-bottom: 30px; text-shadow: 0 0 10px #ff0000;">Uh oh! I friggin' died!</div>
          <div style="margin-bottom: 20px; color: #cccccc; max-width: 800px;">A crash report has been logged to the console. This information has been sent to the developer who will probably fix it.</div>
          <div style="background-color: #333; padding: 20px; border-radius: 5px; margin-top: 20px; text-align: left; max-width: 800px; overflow: auto;">
            <div style="color: #ff9999; margin-bottom: 10px;">Error: ${message}</div>
            <div style="color: #aaaaaa;">Location: ${source}:${lineno}:${colno}</div>
            <div style="color: #aaaaaa; margin-top: 10px;">${error ? error.stack.replace(/\n/g, '<br>') : 'No stack trace available'}</div>
          </div>
          <button id="reloadButton" style="margin-top: 30px; padding: 10px 20px; background-color: #ff5555; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">Reload Page</button>
        `;
        
        // Add to body and attach reload listener
        document.body.appendChild(errorOverlay);
        const reloadButton = document.getElementById('reloadButton');
        if (reloadButton) {
          reloadButton.addEventListener('click', function() {
            location.reload();
          });
        }
        
        // Clear any running game loops or timeouts
        if (window.gameLoopInterval) clearInterval(window.gameLoopInterval);
        if (window.renderInterval) clearInterval(window.renderInterval);
        
        // Prevent default error handling
        return true;
      }
      return false;
    };
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=0.5, user-scalable=yes">
  <title>Sandbox Delta 0.7.1c</title>
  <!-- Webapp metadata -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Sandbox Delta">
  <meta name="application-name" content="Sandbox Delta">
  <!-- Pixelated fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans&family=Dogica&family=Silkscreen&family=VT323&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2300b4d8'/%3E%3Cstop offset='50%25' style='stop-color:%230077b6'/%3E%3Cstop offset='100%25' style='stop-color:%2390e0ef'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='16' cy='16' r='14' fill='url(%23g)' opacity='0.2'/%3E%3Cpath d='M 16 6 L 24 22 L 8 22 Z' fill='none' stroke='url(%23g)' stroke-width='2'/%3E%3Cpath d='M 16 8 L 22 20 L 10 20 Z' fill='url(%23g)' opacity='0.8'/%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Cdefs%3E%3ClinearGradient id='ag' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2300b4d8'/%3E%3Cstop offset='50%25' style='stop-color:%230077b6'/%3E%3Cstop offset='100%25' style='stop-color:%2390e0ef'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='180' height='180' fill='%231a1a2e'/%3E%3Ccircle cx='90' cy='90' r='80' fill='url(%23ag)' opacity='0.2'/%3E%3Cpath d='M 90 30 L 140 130 L 40 130 Z' fill='none' stroke='url(%23ag)' stroke-width='8'/%3E%3Cpath d='M 90 40 L 130 120 L 50 120 Z' fill='url(%23ag)' opacity='0.8'/%3E%3C/svg%3E">

  <style>
    /* Basic layout: center the page content, side panel on the right */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    /* Volume slider styles */
    .volume-slider {
      width: 200px;
      margin: 0 10px;
      vertical-align: middle;
    }
    
    .element-volume-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .element-volume-item {
      display: flex;
      align-items: center;
      padding: 5px;
      border: 1px solid #444;
      border-radius: 4px;
    }
    
    .element-color-box {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border-radius: 3px;
    }

    #game-container {
      overflow: auto;
    }

    .playing #game-container {
      overflow: hidden;
    }

    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --accent: #00b4d8;
      --text-primary: #e6e6e6;
      --text-secondary: #a8a8a8;
      --border-color: #2a3a5f;
      --hover-bg: rgba(0, 180, 216, 0.1);
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Dogica', monospace;
      box-sizing: border-box;
      line-height: 1.5;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    /* The main container: grid + side panel horizontally */
    #mainContainer {
      display: flex;
      flex-direction: row;
      justify-content: center;
      margin: 0 auto;
      padding: 10px;
      box-sizing: border-box;
      width: 100%;
      height: 100vh;
      gap: 20px;
      position: relative;
      overflow: hidden;
    }
    
    /* Custom scrollbar for the entire document */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: #777;
    }
    
    /* Apply pixelated font to all UI elements */
    button, select, option, input, textarea, .modal-content, h1, h2, h3, h4, h5, h6, p, label, .tool {
      font-family: inherit;
    }
    
    /* Pixel mode styles */
    body.pixel-mode * {
      image-rendering: pixelated !important;
      image-rendering: -moz-crisp-edges !important;
      image-rendering: crisp-edges !important;
      border-radius: 0 !important;
      transition: none !important;
    }
    
    body.pixel-mode button, 
    body.pixel-mode .modal-content,
    body.pixel-mode #sidePanel,
    body.pixel-mode .tool,
    body.pixel-mode input,
    body.pixel-mode select,
    body.pixel-mode option,
    body.pixel-mode textarea,
    body.pixel-mode .tab,
    body.pixel-mode #toolSearch,
    body.pixel-mode #sortTools,
    body.pixel-mode #elementInfoBox,
    body.pixel-mode #selectedElementNotification,
    body.pixel-mode .dropdown-content,
    body.pixel-mode #saveLoadButton,
    body.pixel-mode #optionsButton,
    body.pixel-mode #modsButton,
    body.pixel-mode #communityButton,
    body.pixel-mode .dropdown {
      border-radius: 0 !important;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5) !important;
    }
    
    /* Ensure no UI elements have curved corners */
    body.pixel-mode div,
    body.pixel-mode span,
    body.pixel-mode a,
    body.pixel-mode li,
    body.pixel-mode .modal,
    body.pixel-mode .tab-content,
    body.pixel-mode #sideTools,
    body.pixel-mode #toolContainer,
    body.pixel-mode #toolCategories,
    body.pixel-mode #toolPanel,
    body.pixel-mode .toolcategory-button,
    body.pixel-mode #toolCategoriesContainer {
      border-radius: 0 !important;
    }
    
    body.pixel-mode button:active,
    body.pixel-mode .tool:active {
      transform: scale(0.98);
    }
    
    /* Mobile layout */
    @media (max-width: 1024px) {
      
      #mainContainer {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
        padding: 5px;
        gap: 10px;
        overflow-x: hidden;
      }
      
      #grid {
        max-width: 100% !important;
        height: 70vh !important;
        margin: 35px auto 0 auto; /* Added top margin to avoid overlap with menu button */
        touch-action: none; /* Prevent default touch behavior */
        user-select: none;
      }
      
      #sidePanel {
        width: 100% !important;
        height: auto !important;
        min-height: 30vh;
        max-height: 40vh;
        overflow-y: hidden; /* Prevent outer container from scrolling */
        -webkit-overflow-scrolling: touch;
      }

      /* Tool buttons on mobile */
      .tool {
        padding: 10px;
        margin: 5px;
        font-size: 14px;
        border-radius: 6px;
        cursor: pointer;
        touch-action: manipulation;
      }

      .tool.selected {
        background-color: var(--hover-bg);
      }

      /* Hover overlay for touch */
      #hoverOverlay {
        pointer-events: none;
        touch-action: none;
      }
      
      /* Hide HUD on mobile */
      #hud {
        display: none;
      }
      
      /* Hide bottom controls on mobile */
      #bottomControls,
      #optionsButtonContainer,
      #saveLoadButtonContainer,
      #modButtonContainer {
        display: none;
      }
      
      /* Mobile menu button */
      #mobileMenuButton {
        display: block;
        position: fixed;
        top: 5px;
        left: 5px;
        background-color: var(--accent);
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        z-index: 1000;
        font-size: 18px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        transition: all 0.2s ease;
      }
      
      #mobileMenuButton:active {
        transform: scale(0.95);
        background-color: #0099b8;
      }
      
      /* Mobile side menu */
      #mobileSideMenu {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 80%;
        max-width: 300px;
        height: 100%;
        background-color: var(--bg-secondary);
        z-index: 2000;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }
      
      #mobileSideMenu.open {
        transform: translateX(0);
      }
      
      #mobileSideMenuOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1999;
      }
      
      #mobileSideMenuOverlay.open {
        display: block;
      }
      
      #mobileSideMenu .mobile-menu-button {
        width: 100%;
        padding: 16px 15px;
        margin: 15px 0;
        background-color: var(--bg-primary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        font-size: 18px;
        text-align: center;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      
      #mobileSideMenu .mobile-menu-button:active {
        background-color: var(--border-color);
        color: var(--accent);
        transform: scale(0.98);
      }
      
      #mobileSpeedContainer {
        margin: 20px 0;
      }
      
      #mobileSpeedContainer label {
        display: block;
        margin-bottom: 10px;
      }
      
      #mobileSpeedContainer input[type="range"] {
        width: 100%;
        margin-bottom: 5px;
      }
      
      #mobileBrushSizeContainer {
        margin: 20px 0;
      }
      
      #mobileBrushSizeContainer label {
        display: block;
        margin-bottom: 10px;
      }
      
      #mobileBrushSizeContainer input[type="range"] {
        width: 100%;
        margin-bottom: 5px;
      }
      
      #brushSizeValue {
        display: inline-block;
        text-align: center;
        width: 100%;
        font-weight: bold;
        margin-top: 5px;
      }
      
      #mobileSideMenu .menu-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
      }
      
      #mobileSideMenu .menu-title {
        font-size: 18px;
        font-weight: bold;
      }
      
      #mobileMenuCloseBtn {
        background: none;
        border: none;
        color: var(--text-primary);
        font-size: 22px;
        cursor: pointer;
      }
      
      #selectedElementNotification {
        bottom: 10px;
        left: 10px;
        font-size: 14px;
        padding: 8px 15px;
      }
      
      #selectedElementNotification .element-color {
        width: 20px;
        height: 20px;
      }
    }
    /* The game grid; its size will be determined by GRID_SIZE */
    #grid {
      flex: 1;
      max-width: calc(100vh - 20px);
      aspect-ratio: 1;
      background-color: #555;
      user-select: none;
      cursor: crosshair;
      display: grid;
      grid-template-columns: repeat(50, 1fr);
      grid-template-rows: repeat(50, 1fr);
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .cell {
      width: 100%;
      height: 100%;
      background-color: #000;
      box-sizing: border-box;
    }
    /* Hover overlay for stroke highlighting */
    #hoverOverlay {
      position: absolute;
      pointer-events: none;
      border: 2px dashed yellow;
      background-color: rgba(255, 255, 0, 0.2);
      display: none;
      box-sizing: border-box;
    }
    
    /* Selected element notification */
    #selectedElementNotification {
      position: fixed;
      bottom: 30px;
      left: 30px;
      color: #fff;
      font-family: 'Dogica', monospace;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background-color: rgba(40, 40, 45, 0.95);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      transform: translateY(30px) scale(0.98);
      min-width: 180px;
    }
    
    #selectedElementNotification.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }
    
    #selectedElementNotification .element-color {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3),
                  inset 0 1px 2px rgba(255, 255, 255, 0.2);
      flex-shrink: 0;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    #selectedElementNotification.visible .element-color {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    }
    /* Side panel: now wider */
    #sidePanel {
      display: flex;
      flex-direction: column;
      width: 380px;
      min-width: 380px;
      height: calc(100vh - 20px);
      background: var(--bg-secondary);
      border-radius: 8px;
      box-shadow: var(--shadow);
      overflow: hidden; /* Prevent any scrolling on the main container */
      border: 1px solid var(--border-color);
      box-sizing: border-box;
      transition: all 0.3s ease;
      position: relative;
    }
    /* Container for the two scrollable areas side-by-side */
    #sideContent {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
      min-height: 0; /* Important for flex children to shrink properly */
    }
    
    @media (max-width: 1024px) {
      #sideContent {
        flex-direction: column;
        height: 100%; /* Ensure it fills the parent */
      }
      
      #elementScroll {
        flex: 1; /* Take up all available space */
        min-height: 0; /* Allow it to shrink if needed */
        overflow-y: auto;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      }
    }
    /* Element list scroll area */
    #elementScroll {
      flex: 1;
      min-height: 0; /* Important for proper flex shrinking */
      overflow-y: auto;
      overflow-x: hidden; /* Prevent horizontal scrolling */
      padding: 15px;
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
    }
    
    #elementScroll::-webkit-scrollbar {
      width: 6px;
    }
    
    #elementScroll::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #elementScroll::-webkit-scrollbar-thumb {
      background-color: var(--border-color);
      border-radius: 3px;
    }
    /* Custom scrollbar for element list */
    #elementScroll::-webkit-scrollbar {
      width: 8px;
    }
    #elementScroll::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Search and Sort Container */
    #toolSearchContainer {
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      padding: 0 5px;
      width: 100%;
      box-sizing: border-box;
      gap: 8px;
    }
    
    #toolSearch {
      flex: 1;
      min-width: 0; /* Allows the input to shrink below its default minimum width */
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 12px;
      box-sizing: border-box;
      font-size: 14px;
      transition: all 0.2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    #toolSearch:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.2);
    }
    #toolSearch::placeholder {
      color: #bbb;
    }
    
    /* Sort dropdown styling */
    #sortOrder {
      flex: 0 0 auto;
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 25px 8px 10px;
      font-size: 12px;
      cursor: pointer;
      outline: none;
      transition: all 0.2s ease;
      width: 100px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,<svg width='12' height='12' viewBox='0 0 12 12' fill='white' xmlns='http://www.w3.org/2000/svg'><path d='M6 9L2 5h8l-4 4z' fill='%23e6e6e6'/></svg>");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    #sortOrder:hover {
      background-color: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
    }
    
    #sortOrder:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.3);
    }
    
    #sortOrder option {
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      padding: 8px 12px;
      font-size: 12px;
    }
    
    /* Hide the default dropdown arrow in IE11 */
    select::-ms-expand {
      display: none;
    }
    /* Toolbar (element icons) */
    #toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 5px;
      /* Remove overflow and max-height to prevent nested scrolling */
      /* Scrolling is handled by the parent #elementScroll container */
    }
    
    @media (max-width: 768px) {
      #toolbar {
        gap: 4px;
      }
      
      .tool {
        width: 50px !important;
        height: 36px !important;
      }
      
      .tool span {
        font-size: 9px !important;
      }
    }
    .tool {
      position: relative;
      width: 58px;
      height: 38px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      background-color: rgba(255, 255, 255, 0.05);
      transition: all 0.15s ease;
      overflow: hidden;
    }
    /* HUD (not scrollable) */
    #hud {
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 12px;
      color: #fff;
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      border-radius: 6px;
      pointer-events: none; /* Make HUD non-interactive */
      opacity: 0.5; /* Make it semi-transparent by default */
      transition: opacity 0.3s ease;
      width: auto; /* Let content determine width */
      max-width: 140px; /* Limit maximum width */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #hud:hover {
      opacity: 1; /* Full opacity on hover */
    }
    
    /* Style for individual HUD elements */
    #hudTemp, #hudElem, #hudFPS {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: right;
    }
    
    .tool:hover {
      background-color: var(--hover-bg);
      transform: translateY(-2px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      border-color: var(--accent);
    }
    .tool span {
      position: absolute;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-primary);
      bottom: 3px;
      right: 3px;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      padding: 1px 3px;
      border-radius: 3px;
      background-color: rgba(0, 0, 0, 0.4);
    }
    .tool.selected {
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.3);
      background-color: rgba(0, 180, 216, 0.15);
    }
    /* Category menu (tabs) placed to the right in its own scroll area */
    #categoryMenu {
      display: flex;
      flex-direction: column;
      width: 120px;
      min-width: 120px;
      overflow-y: auto;
      padding: 8px 4px;
      background-color: var(--bg-primary);
      border-right: 1px solid var(--border-color);
      scrollbar-width: thin;
    }
    
    @media (max-width: 1024px) {
      #categoryMenu {
        flex-direction: row;
        width: 100%;
        min-width: 100%;
        height: auto;
        max-height: 50px;
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }
      
      #categoryMenu button {
        margin: 0 2px;
        padding: 4px 8px;
        white-space: nowrap;
      }
    }
    
    #categoryMenu button {
      width: 100%;
      padding: 6px 8px;
      margin: 2px 0;
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      border: 1px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      text-align: left;
      transition: all 0.15s ease;
      text-transform: capitalize;
    }
    
    #categoryMenu button:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    
    #categoryMenu button.active {
      background-color: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    /* Custom scrollbar for category menu - match elementScroll styling */
    #categoryMenu::-webkit-scrollbar {
      width: 8px;
      height: 8px; /* Add height for horizontal scrollbar */
    }
    #categoryMenu::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    
    /* Mobile specific scrollbar styling - ensure consistency */
    @media (max-width: 1024px) {
      #categoryMenu {
        scrollbar-width: thin;
        scrollbar-color: #888 #444;
      }
      
      #categoryMenu::-webkit-scrollbar {
        width: 8px; /* Keep width for consistency */
        height: 8px; /* Height for horizontal scrollbar on mobile */
      }
      
      #categoryMenu::-webkit-scrollbar-track {
        background: #444;
        border-radius: 4px;
      }
      
      #categoryMenu::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      
      #categoryMenu::-webkit-scrollbar-thumb:hover {
        background: #aaa;
      }
    }
    /* Element color classes */
    .sand         { background-color: #f4a460; }
    .wall         { background-color: #666666; }
    .water        { background-color: #1e7fdf; }
    .snow         { background-color: #ffffff; }
    .salt-water   { background-color: #3aafff; }
    .lava         { background-color: #ff4500; }
    .stone        { background-color: #808080; }
    .water-vapor  { background-color: #e0e0e0; }
    .cloud        { background-color: #ffffff; }
    .helium       { background-color: #e6f7ff; }
    .eraser       { background-color: pink; border: 2px solid #fff; }
    .copper       { background-color: #b87333; }
    .steel        { background-color: #aaaaaa; }
    .ice          { background-color: #cceeff; }
    .wood         { background-color: #3B220E; }
    .fire         { background-color: #ffcc00; }
    .smoke        { background-color: #666666; }
    .burning-wood { background-color: #5a3310; }
    .ash          { background-color: #444444; }
    .glass        { background-color: #c2e9fb; }
    .bomb         { background-color: #006400; border: 2px solid #000; }
    .dirt         { background-color: #7B5E42; }
    .wet-dirt     { background-color: #4d2e12; }
    .wheat-seeds  { background-color: #bca136; }
    .wheat        { background-color: #c2b280; }
    .flour        { background-color: #f5f5dc; }
    .dough        { background-color: #d2b48c; }
    .bread        { background-color: #f4c986; }
    .burning-organic { background-color: #6a3400; }
    .root         { background-color: #4a3a2f; }
    .spark        { background-color: #ffdd00; border: 1px solid #ffbb00; }
    .charged-copper { background-color: #ff8c00; }
    .charged-down-copper { background-color: #cc6600; }
    .oak-seeds       { background-color: #32CD32; }
    .oak-leaves      { background-color: #228B22; }
    .oak-baby-leaves { background-color: #66bb6a; }
    .dead-oak        { background-color: #777777; }
    .wet-sand        { background-color: #d2a679; }
    .grass           { background-color: #00aa00; }
    .dead-plant      { background-color: #555555; }
    .burning-leaves  { background-color: #a0522d; }
    .burning-root    { background-color: #ff4500; }
    .dead-root       { background-color: #555555; }
    .gas             { background-color: rgba(200,200,200,0.2); }
    .burning-gas     { background-color: #ff6666; opacity: 0.75; }
    .acid            { background-color: #90EE90; }
    .acid-steam      { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud      { background-color: #98FB98; }
    .slime         { background-color: #006400; }

    .carbon-dioxide  { background-color: rgba(128,128,128,0.2); }
    .oxygen          { background-color: rgba(200,230,255,0.2); }
    .bird            { background-color: #B8860B; }
    .meat            { background-color: #FF6B6B; }
    .cooked-meat     { background-color: #8B4513; }
    .cobblestone     { background-color: #808080; }
    .oil             { background-color: #2F4F4F; }
    /* cooler & heater */
    .cooler { background-color: #3399ff; }
    .heater { background-color: #ff3333; }
    /* Heat Separator, Input, Output, Not Gate, And Gate, Blocker */
    .heat-separator          { background-color: #ffef96; }
    .charged-heat-separator  { background-color: #ffe033; }
    .charged-down-heat-separator { background-color: #ffd700; }
    .input            { background-color: #646464; }
    .charged-input    { background-color: #ffff77; }
    .output           { background-color: #3636ff; }
    .charged-output   { background-color: #8888ff; }
    .not-gate         { background-color: #a15050; }
    .and-gate         { background-color: #405050; }
    .blocker          { background-color: #856fa8; }
    .charged-blocker  { background-color: #9b50a3; }

    .cloner { background-color: #cc00cc; }

    .coal         { background-color: #202020; }
    .coal-lump    { background-color: #303030; }
    .burning-coal         { background-color: #520f0f; }
    .burning-coal-lump    { background-color: #812626; }
    /* New element: Thermite â€“ tool styling */
    .thermite     { background-color: #AA4444; }
    .bomb         { background-color: #ff0000; }
    .big-bomb     { background-color: #ff3333; }
    .water-bomb   { background-color: #3366ff; }
    .fire-bomb    { background-color: #ff6600; }
    .cryo-bomb    { background-color: #00ccff; }
    .nuke-bomb    { background-color: #33cc33; } 
    .helium       { background-color: #e6f7ff; }
    .bouncy-ball  { background-color: #ff5599; } 
    .birch-seeds   { background-color: #8cff9b; }
    .tool.cell    { background-color: #00ff99; }
    .blood         { background-color: #cc0000; }
    .glass-shard   { background-color: #aaddff; }
    .sawdust      { background-color: #d9c29e; }
    .salt         { background-color: #ffffff; }

    .grind        { background-color: #777777; }
    
    /* New elements: Cell, Dead Cell, Blood, Glass Shard, and Sawdust */
    .cell-element { background-color: #00ff99 !important; }
    .dead-cell    { background-color: #666666; }
    .blood        { background-color: #cc0000; }
    .glass-shard  { background-color: #aaddff; }
    .sawdust      { background-color: #d9c29e; }
    
    /* New elements: Glue, Sugar, Sugar Water, Plant, Diamond and variants, Confetti, Oxidized Copper */
    .glue          { background-color: #dfdfdf; }
    .sugar         { background-color: #ffffff; }
    .sugar-water   { background-color: #add8e6; }
    .plant         { background-color: #2e8b57; }
    .diamond       { background-color: #b9f2ff; }
    .diamond-shards { background-color: #a7e0ed; border: 1px dotted #77bbdd; }
    .molten-diamond { background-color: #ff93a8; }
    .confetti      { background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet); }
    .dabicco       { background: linear-gradient(135deg, #ff0000, #0000ff); }
    
    /* Animations for special elements in toolbar */
    @keyframes confettiAnimation {
      0% { transform: translateY(0); filter: hue-rotate(0deg); }
      25% { transform: translateY(-2px); filter: hue-rotate(90deg); }
      50% { transform: translateY(0); filter: hue-rotate(180deg); }
      75% { transform: translateY(2px); filter: hue-rotate(270deg); }
      100% { transform: translateY(0); filter: hue-rotate(360deg); }
    }
    
    @keyframes dabiccoAnimation {
      0% { transform: scale(1); filter: hue-rotate(0deg); }
      25% { transform: scale(1.1); filter: hue-rotate(90deg); }
      50% { transform: scale(1); filter: hue-rotate(180deg); }
      75% { transform: scale(0.9); filter: hue-rotate(270deg); }
      100% { transform: scale(1); filter: hue-rotate(360deg); }
    }
    
    /* Special animated elements in toolbar */
    #toolbar .confetti {
      animation: confettiAnimation 2s infinite;
    }
    
    #toolbar .dabicco {
      animation: dabiccoAnimation 3s infinite;
    }
    
    /* Tool versions of the elements for better visibility in the toolbar */
    .tool.diamond       { background-color: #b9f2ff; }
    .tool.diamond-shards { background-color: #a7e0ed; border: 1px dotted #0088cc; }
    .tool.molten-diamond { background-color: #ff93a8; }
    .tool.confetti      { background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet); }
    .tool.dabicco       { background: linear-gradient(135deg, #ff0000, #0000ff); animation: dabicco-pulse 3s infinite; }
    .tool.plant         { background-color: #2e8b57; }
    
    @keyframes dabicco-pulse {
      0% { background: linear-gradient(135deg, #ff0000, #0000ff); }
      50% { background: linear-gradient(135deg, #0000ff, #ff0000); }
      100% { background: linear-gradient(135deg, #ff0000, #0000ff); }
    }
    .tool.sugar         { background-color: #ffffff; border: 1px solid #dddddd; }
    .tool.sugar-water   { background-color: #add8e6; }
    .tool.glue          { background-color: #dfdfdf; }
    .tool.oxidized-copper { background-color: #4fa889; }
    .oxidized-copper { background-color: #4fa889; }
    .molten-copper  { background-color: #ff7f00; }
    .molten-salt    { background-color: #ffbbaa; }
    .molten-steel   { background-color: #ff6666; }
    .molten-sugar   { background-color: #884411; } /* Caramelized sugar */
    .molten-glass   { background-color: #ffaa77; }
    
    /* New physics elements */
    .insulator      { background-color: #ffe4b5; }
    .photon         { background-color: #ffffff; border: 1px solid #dddddd; }
    .lightning      { background-color: #ffd700; }
    .lightning-trail { background-color: #ffd700; }
    .dense-cloud    { background-color: #d3d3d3; }
    
    /* Tool versions for better visibility */
    .tool.insulator { background-color: #ffe4b5; border: 1px solid #ddd0a0; }
    .tool.photon    { background-color: #ffffff; border: 1px solid #cccccc; box-shadow: 0 0 5px rgba(255,255,255,0.5); }
    .tool.lightning { background-color: #ffd700; border: 1px solid #daa520; }
.tool.dense-cloud { background-color: #d3d3d3; border: 1px solid #a9a9a9; }
.tool.snow { background-color: #ffffff; border: 1px solid #cccccc; }
    

    /* HUD area for temp, element info, and FPS */
    #hud {
      position: fixed;
      top: 15px;
      left: 15px;
      background-color: rgba(0, 0, 0, 0.65);
      padding: 8px 12px;
      border-radius: 6px;
      font-family: inherit; /* Use the same font as the rest of the interface */
      font-size: 12px;
      color: var(--text-primary);
      backdrop-filter: blur(5px);
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow);
      z-index: 100;
    }
    #hud div { margin: 5px 0; }
    /* Bottom controls */
    #bottomControls {
      position: sticky;
      bottom: 0;
      padding: 10px 15px;
      background-color: var(--bg-secondary);
      border-top: 1px solid var(--border-color);
      box-sizing: border-box;
      margin-top: 10px;
    }
    
    /* Speed slider styling */
    #speedContainer {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      width: 90%;
      margin: 0 auto 15px auto;
    }
    
    #speedContainer label {
      font-size: 14px;
      color: var(--text-primary);
      white-space: nowrap;
      font-weight: 500;
    }
    
    #speed {
      flex-grow: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: var(--bg-primary);
      outline: none;
      border-radius: 3px;
      border: 1px solid var(--border-color);
      cursor: pointer;
    }
    
    #speed::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 1px solid var(--text-primary);
    }
    
    #speed::-webkit-slider-thumb:hover {
      background: #33c5e5; /* Lighter accent color */
    }
    
    #speed::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 1px solid var(--text-primary);
    }
    
    #speed::-moz-range-thumb:hover {
      background: #33c5e5; /* Lighter accent color */
    }
    
    #speedValue {
      min-width: 25px;
      text-align: center;
      font-size: 14px;
      color: var(--accent);
      font-weight: bold;
    }
    
    /* Clear All button */
    #clearAllBtn {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px 15px;
      cursor: pointer;
      width: 90%;
      margin: 0 auto;
      display: block;
      transition: all 0.2s ease;
      font-size: 14px;
    }
    
    #clearAllBtn:hover { 
      background-color: var(--border-color);
      color: var(--accent);
    }
    /* Sidebar buttons (options, save/load, etc.) */
    #optionsButtonContainer,
    #saveLoadButtonContainer,
    #modButtonContainer {
      margin-bottom: 10px;
      width: 90%;
      margin-left: auto;
      margin-right: auto;
    }
    
    #optionsButton,
    #saveLoadButton,
    #modButton {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px 15px;
      cursor: pointer;
      width: 90%;
      margin: 0 auto;
      display: block;
      transition: all 0.2s ease;
      font-size: 14px;
    }
    
    #optionsButton:hover,
    #saveLoadButton:hover,
    #modButton:hover {
      background-color: var(--border-color);
      color: var(--accent);
    }
    
    #optionsButton:active,
    #saveLoadButton:active,
    #modButton:active {
      background-color: var(--bg-secondary);
      transform: translateY(1px);
    }
    /* Extra Sidebar Buttons */
    #communityButtonContainer {
      text-align: center;
    }
    #communityButton {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      margin: 5px;
    }
    #communityButton:hover {
      background-color: #555;
    }
    /* Modal styles - updated to match blue modern UI scheme */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: rgba(0,0,0,0.8);
    }
    .modal .modal-content {
      background-color: var(--bg-primary);
      margin: 5% auto;
      padding: 20px 20px;
      border: 1px solid var(--border-color);
      width: calc(100% - 40px);
      max-width: 600px;
      max-height: 90vh;
      bottom: 0;
      position: sticky;
      display: flex !important;
      flex-direction: column;
      overflow: auto;
      border-radius: 8px;
      box-shadow: var(--shadow);
      z-index: 5;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) var(--bg-secondary);
      box-sizing: border-box;
      color: var(--text-primary);
    }
    
    /* Responsive modal styles for mobile */
    @media (max-width: 768px) {
      .modal .modal-content {
        width: 95%;
        margin: 5% auto;
        padding: 15px;
        max-height: 85vh;
      }
      
      .modal .close {
        top: 5px;
        right: 10px;
      }
      
      .modal button {
        padding: 10px 12px;
        margin: 5px 0;
        font-size: 16px;
      }
      
      .modal input[type="text"],
      .modal textarea,
      .modal select {
        font-size: 16px;
        padding: 10px 8px;
      }
    }
    .modal .close {
      color: var(--text-secondary);
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
    }
    .modal .close:hover,
    .modal .close:focus {
      color: var(--accent);
      text-decoration: none;
      cursor: pointer;
    }
    .modal input[type="text"],
    .modal textarea,
    .modal select {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      box-sizing: border-box;
    }
    .modal button {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      color: var(--text-primary);
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .modal button:hover {
      background-color: var(--hover-bg);
      border-color: var(--accent);
      color: var(--accent);
    }
    
    /* Community saves styles */
    #communitySavesList {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 15px;
    }
    
    #communitySavesList .loading,
    #communitySavesList .no-saves,
    #communitySavesList .error {
      padding: 10px;
      text-align: center;
      color: #ddd;
    }
    
    #communitySavesList .error {
      color: #ff6b6b;
    }
    
    .save-metadata {
      display: flex;
      flex-wrap: wrap;
      font-size: 0.8em;
      color: #aaa;
      margin-top: 5px;
    }
    
    .save-metadata > div {
      margin-right: 10px;
    }
    
    .save-publisher {
      font-style: italic;
    }
    
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      width: 100px;
      height: 100px;
      background-color: #222;
      border: 1px solid #444;
    }
    
    .preview-cell {
      width: 100%;
      height: 100%;
      background-color: #000;
    }
    
    .preview-error {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100px;
      height: 100px;
      background-color: #333;
      color: #ff6b6b;
      font-size: 0.8em;
      text-align: center;
    }
    
    .save-game-card {
      display: flex;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 5px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    
    .save-preview {
      flex: 0 0 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #222;
    }
    
    .save-info {
      flex: 1;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    
    .save-title {
      font-weight: bold;
      font-size: 1.1em;
      margin-bottom: 5px;
    }
    
    .save-description {
      color: #ccc;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    
    .load-save-button {
      align-self: flex-end;
      margin-top: auto;
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 5px 10px;
      cursor: pointer;
    }
    
    .load-save-button:hover {
      background-color: #555;
    }
    /* Modern Mod Manager Styles */
    .mod-manager-modal .modal-content {
      max-width: 1200px;
      width: 95vw;
      max-height: 90vh;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      border: 2px solid var(--accent);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: modalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .mod-manager-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 25px;
      background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
      border-bottom: 3px solid var(--accent);
      color: var(--text-primary);
      position: relative;
    }

    .mod-manager-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
    }

    .mod-manager-title {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      flex-direction: column;
      align-items: flex-start;
    }

    .mod-manager-title:hover {
      transform: translateX(5px);
    }

    .mod-manager-title:hover .mod-manager-icon {
      transform: rotate(180deg);
    }

    .mod-manager-icon {
      width: 28px;
      height: 28px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
      transition: transform 0.5s ease;
    }

    .mod-manager-subtitle {
      font-size: 14px;
      font-weight: 400;
      opacity: 0.8;
      margin-top: 2px;
    }

    .mod-manager-tabs {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 2px solid var(--border-color);
      padding: 0 20px;
      position: relative;
      overflow-x: auto;
    }

    .mod-manager-tabs::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent 0%, var(--accent) 50%, transparent 100%);
    }

    .mod-tab-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      background: none;
      border: none;
      padding: 15px 20px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
      position: relative;
      border-radius: 8px 8px 0 0;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .mod-tab-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, transparent 0%, rgba(var(--accent-rgb), 0.05) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 8px 8px 0 0;
    }

    .mod-tab-btn:hover {
      color: var(--text-primary);
      background: var(--bg-primary);
      transform: translateY(-2px);
    }

    .mod-tab-btn:hover::before {
      opacity: 1;
    }

    .mod-tab-btn.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
      background: var(--bg-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
    }

    .mod-tab-btn.active::before {
      opacity: 0.7;
    }

    .mod-tab-btn svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    .mod-count {
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 4px;
    }

    .mod-manager-body {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
      background: var(--bg-primary);
    }

    .mod-tab-content {
      display: none;
    }

    .mod-tab-content.active {
      display: block;
    }

    /* Mod Controls */
    .mod-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .mod-search-container {
      position: relative;
      flex: 1;
      min-width: 250px;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      color: var(--text-secondary);
      pointer-events: none;
    }

    .mod-search-input {
      width: 100%;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 12px 12px 12px 40px;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .mod-search-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.1);
    }

    .mod-filter-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* Mod Grid */
    .mod-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .mod-card {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .mod-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #0099b8);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .mod-card:hover {
      border-color: var(--accent);
      transform: translateY(-4px);
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
    }

    .mod-card:hover::before {
      opacity: 1;
    }

    .mod-card-header {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 15px;
    }

    .mod-card-icon {
      width: 40px;
      height: 40px;
      background: var(--accent);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 18px;
      flex-shrink: 0;
    }

    .mod-card-info h3 {
      margin: 0 0 4px 0;
      color: var(--text-primary);
      font-size: 16px;
      font-weight: 600;
    }

    .mod-card-info p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 13px;
      line-height: 1.4;
    }

    .mod-card-meta {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      font-size: 12px;
    }

    .mod-meta-item {
      background: var(--bg-primary);
      padding: 4px 8px;
      border-radius: 4px;
      color: var(--text-secondary);
    }

    .mod-card-actions {
      display: flex;
      gap: 8px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .mod-action-btn {
      background: var(--accent);
      border: none;
      border-radius: 6px;
      color: white;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .mod-action-btn:hover {
      background: #0099b8;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 180, 216, 0.3);
    }

    .mod-action-btn.secondary {
      background: var(--bg-primary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
    }

    .mod-action-btn.secondary:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .mod-action-btn.danger {
      background: #f44336;
    }

    .mod-action-btn.danger:hover {
      background: #d32f2f;
    }

    .mod-action-btn svg {
      width: 14px;
      height: 14px;
    }

    /* No Mods Message */
    .no-mods-message {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }

    .no-mods-message svg {
      width: 64px;
      height: 64px;
      opacity: 0.5;
      margin-bottom: 20px;
    }

    .no-mods-message h3 {
      margin: 0 0 10px 0;
      color: var(--text-primary);
      font-size: 20px;
    }

    .no-mods-message p {
      margin: 0 0 20px 0;
      font-size: 14px;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Browse Tab Styles */
    .browse-header,
    .create-mod-header,
    .settings-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 25px;
      padding: 20px;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 2px solid var(--border-color);
    }

    .browse-header svg,
    .create-mod-header svg,
    .settings-header svg {
      width: 32px;
      height: 32px;
      color: var(--accent);
    }

    .browse-header-text h3,
    .create-mod-header-text h3,
    .settings-header-text h3 {
      margin: 0 0 5px 0;
      color: var(--text-primary);
      font-size: 18px;
    }

    .browse-header-text p,
    .create-mod-header-text p,
    .settings-header-text p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 14px;
    }

    .browse-notice {
      display: flex;
      gap: 15px;
      padding: 20px;
      background: var(--bg-secondary);
      border: 2px solid #ff9800;
      border-radius: 12px;
      color: var(--text-primary);
    }

    .browse-notice svg {
      width: 24px;
      height: 24px;
      color: #ff9800;
      flex-shrink: 0;
    }

    .browse-notice h4 {
      margin: 0 0 8px 0;
      color: #ff9800;
    }

    .browse-notice p {
      margin: 0;
      font-size: 14px;
      line-height: 1.5;
    }

    /* Create Mod Form Styles */
    .mod-creation-form {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 25px;
      border: 2px solid var(--border-color);
    }

    .form-section {
      margin-bottom: 25px;
    }

    .form-section:last-child {
      margin-bottom: 0;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-primary);
      font-weight: 500;
      font-size: 14px;
    }

    .mod-input {
      width: 100%;
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 12px;
      font-size: 14px;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }

    .mod-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.1);
    }

    .code-editor-container {
      position: relative;
    }

    .mod-code-textarea {
      width: 100%;
      min-height: 300px;
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      resize: vertical;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }

    .mod-code-textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.1);
    }

    .code-editor-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
      padding: 10px;
      background: var(--bg-primary);
      border-radius: 6px;
      border: 1px solid var(--border-color);
    }

    .code-stats {
      display: flex;
      gap: 15px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .code-actions {
      display: flex;
      gap: 8px;
    }

    .form-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 25px;
      flex-wrap: wrap;
    }

    .primary-btn,
    .secondary-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      border: none;
    }

    .primary-btn {
      background: var(--accent);
      color: white;
    }

    .primary-btn:hover {
      background: #0099b8;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 180, 216, 0.3);
    }

    .secondary-btn {
      background: var(--bg-primary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
    }

    .secondary-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      transform: translateY(-1px);
    }

    .primary-btn svg,
    .secondary-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Settings Grid */
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }

    .setting-card {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .setting-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #0099b8);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .setting-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .setting-card:hover::before {
      opacity: 1;
    }

    .setting-header {
      display: flex;
      align-items: flex-start;
      gap: 15px;
      margin-bottom: 15px;
    }

    .setting-header svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
      flex-shrink: 0;
      margin-top: 2px;
    }

    .setting-text h4 {
      margin: 0 0 5px 0;
      color: var(--text-primary);
      font-size: 16px;
      font-weight: 600;
    }

    .setting-text p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 13px;
      line-height: 1.4;
    }

    .setting-control {
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }
    .acid          { background-color: #90EE90; }
    .acid-steam    { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud    { background-color: #98FB98; }
    .slime         { background-color: #006400; }
    /* Tool styles */
    .tool.heat { background: linear-gradient(45deg, #ff4500, #ffd700); }
    .tool.cool { background: linear-gradient(45deg, #00bfff, #87ceeb); }
    .tool.cook { background-color: #deb887; }
    .tool.mix { background: repeating-linear-gradient(45deg, #444, #666 10px); }
    .tool.move { background-color: #4169e1; }
    .tool.sponge { background-color: #ffa07a; }
    .tool.extinguish { background-color: #4682b4; }
    /* Modern Options Modal Styles */
    .options-modal .modal-content {
      max-width: 1000px;
      width: 90vw;
      max-height: 85vh;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      border: 2px solid var(--accent);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: modalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes modalSlideIn {
      0% {
        opacity: 0;
        transform: translateY(-30px) scale(0.95);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .options-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 25px;
      background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
      border-bottom: 3px solid var(--accent);
      color: var(--text-primary);
      position: relative;
    }

    .options-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
    }

    .options-title {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }

    .options-title:hover {
      transform: translateX(5px);
    }

    .options-title:hover .options-icon {
      transform: rotate(180deg);
    }

    .options-icon {
      width: 28px;
      height: 28px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
      transition: transform 0.5s ease;
    }

    .close-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-primary);
    }

    .close-btn:hover {
      background: rgba(244, 67, 54, 0.2);
      border-color: #f44336;
      color: #f44336;
      transform: scale(1.1) rotate(90deg);
    }

    .close-btn svg {
      width: 20px;
      height: 20px;
    }

    .options-tabs {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 2px solid var(--border-color);
      padding: 0 20px;
      position: relative;
    }

    .options-tabs::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent 0%, var(--accent) 50%, transparent 100%);
    }

    .options-tab-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      background: none;
      border: none;
      padding: 15px 20px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
      position: relative;
      border-radius: 8px 8px 0 0;
    }

    .options-tab-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, transparent 0%, rgba(var(--accent-rgb), 0.05) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 8px 8px 0 0;
    }

    .options-tab-btn:hover {
      color: var(--text-primary);
      background: var(--bg-primary);
      transform: translateY(-2px);
    }

    .options-tab-btn:hover::before {
      opacity: 1;
    }

    .options-tab-btn.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
      background: var(--bg-primary);
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
    }

    .options-tab-btn.active::before {
      opacity: 0.7;
    }

    .options-tab-btn svg {
      width: 18px;
      height: 18px;
    }

    .options-body {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
      background: var(--bg-primary);
    }

    .options-tab-content {
      display: none;
    }

    .options-tab-content.active {
      display: block;
    }

    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
    }

    .option-card {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .option-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #0099b8);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .option-card:hover {
      border-color: var(--accent);
      transform: translateY(-4px);
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
    }

    .option-card:hover::before {
      opacity: 1;
    }

    .option-card.wide-card {
      grid-column: 1 / -1;
    }

    .option-card.action-card {
      border-color: var(--accent);
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(0, 180, 216, 0.05) 100%);
    }

    .option-card.experimental-card {
      border-color: #ff9800;
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(255, 152, 0, 0.05) 100%);
      position: relative;
    }

    .option-card.experimental-card::before {
      background: linear-gradient(90deg, #ff9800, #ffc107) !important;
    }

    .option-card.experimental-card::after {
      content: 'âš ï¸';
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 18px;
      opacity: 0.6;
    }

    .option-header {
      display: flex;
      align-items: flex-start;
      gap: 15px;
      margin-bottom: 15px;
    }

    .option-icon {
      width: 24px;
      height: 24px;
      color: var(--accent);
      flex-shrink: 0;
      margin-top: 2px;
    }

    .experimental-card .option-icon {
      color: #ff9800;
    }

    .option-text h4 {
      margin: 0 0 5px 0;
      color: var(--text-primary);
      font-size: 16px;
      font-weight: 600;
    }

    .option-text p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 13px;
      line-height: 1.4;
    }

    .experimental-label {
      display: inline-block;
      background: var(--bg-primary);
      color: #ff9800;
      border: 2px solid #ff9800;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      margin-bottom: 5px !important;
      box-shadow: 0 2px 4px rgba(255, 152, 0, 0.2);
    }

    .danger-label {
      color: #f44336 !important;
      border-color: #f44336 !important;
      box-shadow: 0 2px 4px rgba(244, 67, 54, 0.2) !important;
    }

    .danger-card {
      border-color: rgba(244, 67, 54, 0.3) !important;
      background: rgba(244, 67, 54, 0.05) !important;
    }

    .danger-btn {
      background: #f44336 !important;
      border: none;
      border-radius: 8px;
      color: white;
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .danger-btn:hover {
      background: #d32f2f !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
    }

    .danger-btn svg {
      width: 16px;
      height: 16px;
    }

    .option-control {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .volume-control {
      width: 100%;
      gap: 15px;
    }

    /* Modern Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border-color);
      transition: all 0.3s ease;
      border-radius: 26px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: all 0.3s ease;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    input:checked + .toggle-slider {
      background-color: var(--accent);
      box-shadow: inset 0 2px 4px rgba(0, 180, 216, 0.3);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    /* Modern Select */
    .modern-select {
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 160px;
    }

    .modern-select:hover,
    .modern-select:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.1);
    }

    /* Modern Buttons */
    .apply-btn,
    .action-btn {
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .apply-btn:hover,
    .action-btn:hover {
      background: #0099b8;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 180, 216, 0.3);
    }

    .action-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Volume Slider */
    .volume-slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: var(--border-color);
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .volume-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 4px 8px rgba(0, 180, 216, 0.4);
    }

    .volume-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .volume-display {
      color: var(--accent);
      font-weight: 600;
      font-size: 14px;
      min-width: 40px;
      text-align: center;
    }

    /* Warning and Info Messages */
    .option-warning,
    .option-info {
      grid-column: 1 / -1;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      margin-top: 8px;
    }

    .option-warning {
      background: rgba(255, 152, 0, 0.1);
      border: 1px solid #ff9800;
      color: #ff9800;
      display: none;
    }

    .option-warning.show {
      display: block;
    }

    .option-info.clear-warning {
      background: rgba(244, 67, 54, 0.1);
      border: 1px solid #f44336;
      color: #f44336;
    }

    /* Experimental Notice */
    .experimental-notice {
      background: var(--bg-secondary);
      border: 2px solid #ff9800;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
      display: flex;
      align-items: flex-start;
      gap: 15px;
      position: relative;
      overflow: hidden;
    }

    .experimental-notice::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #ff9800, #ffc107);
    }

    .experimental-notice svg {
      width: 24px;
      height: 24px;
      color: #ff9800;
      flex-shrink: 0;
      margin-top: 2px;
    }

    .experimental-notice h3 {
      margin: 0 0 8px 0;
      color: #ff9800;
      font-size: 18px;
      font-weight: 600;
    }

    .experimental-notice p {
      margin: 0;
      color: var(--text-primary);
      font-size: 14px;
      line-height: 1.4;
    }

    /* Element Volume Section */
    .element-volume-section {
      grid-column: 1 / -1;
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      margin-top: 10px;
    }

    /* Audio Tab Specific Styles */
    .audio-header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 24px;
      background: linear-gradient(135deg, rgba(74, 144, 226, 0.1) 0%, rgba(80, 227, 194, 0.1) 100%);
      border-radius: 16px;
      margin-bottom: 24px;
      border: 1px solid rgba(74, 144, 226, 0.2);
    }

    .audio-header svg {
      width: 40px;
      height: 40px;
      color: var(--accent);
      flex-shrink: 0;
    }

    .audio-header-text h3 {
      margin: 0 0 4px 0;
      color: var(--text-primary);
      font-size: 1.5rem;
      font-weight: 600;
    }

    .audio-header-text p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .audio-sections {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .audio-section {
      background: var(--bg-primary);
      border-radius: 16px;
      padding: 24px;
      border: 2px solid var(--border-color);
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .section-header svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
      flex-shrink: 0;
    }

    .section-header h4 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1.2rem;
      font-weight: 500;
    }

    .audio-controls {
      width: 100%;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .control-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-item label {
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.9rem;
    }

    .sound-categories {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }

    .category-card {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid var(--border-color);
      transition: all 0.2s ease;
    }

    .category-card:hover {
      background: var(--hover-bg);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .category-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }

    .category-header svg {
      width: 20px;
      height: 20px;
      color: var(--accent);
      flex-shrink: 0;
    }

    .category-header h5 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1rem;
      font-weight: 500;
    }

    .category-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .test-btn {
      padding: 6px 12px;
      background: rgba(74, 144, 226, 0.2);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .test-btn:hover {
      background: var(--accent);
      color: white;
      transform: translateY(-1px);
    }

    .test-btn:active {
      transform: translateY(0);
    }

    .element-controls-header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }

    .element-controls-header p {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .toggle-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      color: var(--accent);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      align-self: flex-start;
    }

    .toggle-btn:hover {
      background: var(--hover-bg);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .toggle-btn svg {
      width: 16px;
      height: 16px;
      transition: transform 0.2s ease;
    }

    .toggle-btn.expanded svg {
      transform: rotate(180deg);
    }

    .element-search {
      margin-bottom: 16px;
    }

    .search-input {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--hover-bg);
    }

    .search-input::placeholder {
      color: var(--text-secondary);
    }

    .advanced-settings {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .setting-group {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .setting-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .setting-item label {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .setting-item input[type="checkbox"] {
      display: none;
    }

    .checkmark {
      width: 20px;
      height: 20px;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 4px;
      position: relative;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .setting-item input[type="checkbox"]:checked + .checkmark {
      background: var(--accent);
      border-color: var(--accent);
    }

    .setting-item input[type="checkbox"]:checked + .checkmark::after {
      content: 'âœ“';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 12px;
      font-weight: bold;
    }

    .setting-desc {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.8rem;
      margin-left: 30px;
    }

    /* Footer */
    .options-footer {
      padding: 20px 25px;
      border-top: 2px solid var(--border-color);
      background: var(--bg-secondary);
      display: flex;
      justify-content: center;
    }

    .danger-btn {
      background: linear-gradient(135deg, #f44336, #d32f2f);
      border: none;
      border-radius: 8px;
      color: white;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: pulse-warning 2s infinite;
    }

    .danger-btn:hover {
      background: linear-gradient(135deg, #e53935, #c62828);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
    }

    .danger-btn svg {
      width: 18px;
      height: 18px;
    }

    /* Pixel Mode Compatibility */
    body.pixel-mode .options-modal .modal-content,
    body.pixel-mode .options-modal .option-card,
    body.pixel-mode .options-modal .modern-select,
    body.pixel-mode .options-modal .apply-btn,
    body.pixel-mode .options-modal .action-btn,
    body.pixel-mode .options-modal .danger-btn,
    body.pixel-mode .options-modal .experimental-notice,
    body.pixel-mode .options-modal .element-volume-section,
    body.pixel-mode .options-modal .experimental-label {
      border-radius: 0 !important;
      image-rendering: pixelated;
    }

    body.pixel-mode .options-modal .options-header,
    body.pixel-mode .options-modal .options-footer {
      border-radius: 0 !important;
    }

    /* Pixel mode sliders - make them more retro */
    body.pixel-mode .options-modal .toggle-slider {
      border-radius: 0 !important;
      background: var(--bg-primary) !important;
      border: 2px solid var(--border-color) !important;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.2), inset -2px -2px 0 rgba(255,255,255,0.1) !important;
    }

    body.pixel-mode .options-modal .toggle-slider:before {
      border-radius: 0 !important;
      background: var(--text-primary) !important;
      box-shadow: 2px 2px 0 rgba(0,0,0,0.3), -1px -1px 0 rgba(255,255,255,0.2) !important;
      width: 18px !important;
      height: 18px !important;
      left: 2px !important;
      bottom: 2px !important;
    }

    body.pixel-mode .options-modal input:checked + .toggle-slider {
      background: var(--accent) !important;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.3), inset -2px -2px 0 rgba(255,255,255,0.2) !important;
    }

    body.pixel-mode .options-modal input:checked + .toggle-slider:before {
      transform: translateX(20px) !important;
      background: white !important;
    }

    /* Pixel mode volume sliders */
    body.pixel-mode .options-modal .volume-slider {
      height: 8px !important;
      border-radius: 0 !important;
      background: var(--bg-primary) !important;
      border: 2px solid var(--border-color) !important;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.2), inset -2px -2px 0 rgba(255,255,255,0.1) !important;
    }

    body.pixel-mode .options-modal .volume-slider::-webkit-slider-thumb {
      border-radius: 0 !important;
      width: 16px !important;
      height: 16px !important;
      background: var(--text-primary) !important;
      border: 2px solid var(--border-color) !important;
      box-shadow: 2px 2px 0 rgba(0,0,0,0.3), -1px -1px 0 rgba(255,255,255,0.2) !important;
    }

    body.pixel-mode .options-modal .volume-slider::-moz-range-thumb {
      border-radius: 0 !important;
      width: 16px !important;
      height: 16px !important;
      background: var(--text-primary) !important;
      border: 2px solid var(--border-color) !important;
      box-shadow: 2px 2px 0 rgba(0,0,0,0.3), -1px -1px 0 rgba(255,255,255,0.2) !important;
    }

    body.pixel-mode .options-modal svg {
      image-rendering: pixelated;
    }

    /* Pixel Mode Styles for Mod Manager */
    body.pixel-mode .mod-manager-modal .modal-content,
    body.pixel-mode .mod-card,
    body.pixel-mode .setting-card,
    body.pixel-mode .mod-creation-form,
    body.pixel-mode .browse-header,
    body.pixel-mode .create-mod-header,
    body.pixel-mode .settings-header,
    body.pixel-mode .browse-notice,
    body.pixel-mode .mod-input,
    body.pixel-mode .mod-search-input,
    body.pixel-mode .mod-code-textarea,
    body.pixel-mode .code-editor-footer,
    body.pixel-mode .mod-card-icon,
    body.pixel-mode .mod-count,
    body.pixel-mode .mod-meta-item {
      border-radius: 0 !important;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    body.pixel-mode .mod-manager-header,
    body.pixel-mode .mod-manager-tabs {
      border-radius: 0 !important;
    }

    body.pixel-mode .mod-manager-header::after,
    body.pixel-mode .mod-manager-tabs::after {
      display: none;
    }

    body.pixel-mode .mod-tab-btn,
    body.pixel-mode .close-btn,
    body.pixel-mode .primary-btn,
    body.pixel-mode .secondary-btn,
    body.pixel-mode .action-btn,
    body.pixel-mode .mod-action-btn,
    body.pixel-mode .danger-btn,
    body.pixel-mode .modern-select {
      border-radius: 0 !important;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    body.pixel-mode .mod-card::before,
    body.pixel-mode .setting-card::before,
    body.pixel-mode .mod-tab-btn::before {
      display: none !important;
    }

    body.pixel-mode .mod-manager-modal svg,
    body.pixel-mode .search-icon,
    body.pixel-mode .mod-action-btn svg,
    body.pixel-mode .primary-btn svg,
    body.pixel-mode .secondary-btn svg,
    body.pixel-mode .browse-notice svg,
    body.pixel-mode .no-mods-message svg {
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    body.pixel-mode .mod-manager-title:hover {
      transform: none !important;
    }

    body.pixel-mode .mod-manager-title:hover .mod-manager-icon {
      transform: none !important;
    }

    body.pixel-mode .mod-card:hover,
    body.pixel-mode .setting-card:hover,
    body.pixel-mode .mod-tab-btn:hover {
      transform: none !important;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .options-modal .modal-content {
        width: 95vw;
        max-height: 90vh;
      }

      .options-tabs {
        padding: 0 10px;
      }

      .options-tab-btn {
        padding: 12px 15px;
        font-size: 12px;
      }

      .options-tab-btn svg {
        width: 16px;
        height: 16px;
      }

      .options-body {
        padding: 15px;
      }

      .options-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .option-card {
        padding: 15px;
      }

      .option-control {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .volume-control {
        flex-direction: row;
        align-items: center;
      }
    }

    /* Custom Elements System Styles */
    #customElementsInterface {
      display: none;
      padding: 15px;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin: 10px 0;
      border: 2px solid var(--border-color);
    }

    #customElementsInterface.active {
      display: block;
    }

    .custom-elements-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
    }

    .custom-elements-header h3 {
      margin: 0;
      color: var(--accent);
      font-size: 16px;
    }

    .custom-elements-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-bottom: 15px;
    }

    .custom-element-item {
      position: relative;
      padding: 8px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      background: var(--bg-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .custom-element-item:hover {
      border-color: var(--accent);
      background: var(--hover-bg);
    }

    .custom-element-item.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.3);
      background: rgba(0, 180, 216, 0.15);
    }

    .custom-element-item.create-new {
      border-style: dashed;
      color: var(--text-secondary);
      border-color: var(--text-secondary);
    }

    .custom-element-item.create-new:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .custom-element-preview {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      margin-bottom: 4px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .custom-element-name {
      font-size: 10px;
      text-align: center;
      font-weight: bold;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .create-new-icon {
      font-size: 24px;
      margin-bottom: 4px;
    }

    .custom-element-delete {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #f44336;
      border: none;
      border-radius: 50%;
      color: white;
      width: 20px;
      height: 20px;
      font-size: 12px;
      cursor: pointer;
      display: none;
    }

    .custom-element-item:hover .custom-element-delete {
      display: block;
    }

    /* Custom Element Creator Modal */
    .custom-element-creator {
      display: none;
      background: var(--bg-primary);
      border: 2px solid var(--accent);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
      max-width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }

    .custom-element-creator.active {
      display: block;
    }

    .creator-header {
      text-align: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }

    .creator-header h3 {
      margin: 0 0 8px 0;
      color: var(--accent);
      font-size: 16px;
    }

    .creator-color-name {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .color-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .color-input-container label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .creator-color-input {
      width: 40px;
      height: 40px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      background: transparent;
    }

    .creator-color-input:hover {
      border-color: var(--accent);
    }

    .name-input-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .name-input-container label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .creator-name-input {
      padding: 6px 10px;
      border: 2px solid var(--border-color);
      border-radius: 4px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 13px;
      width: 120px;
      box-sizing: border-box;
    }

    .creator-name-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .creator-properties {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 100%;
    }

    .property-group {
      background: var(--bg-secondary);
      border-radius: 4px;
      padding: 12px;
      width: 100%;
      box-sizing: border-box;
    }

    .property-group h4 {
      margin: 0 0 8px 0;
      color: var(--text-primary);
      font-size: 13px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
    }

    .property-item {
      margin-bottom: 10px;
    }

    .property-item label {
      display: block;
      margin-bottom: 4px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .property-item select,
    .property-item input[type="range"],
    .property-item input[type="number"] {
      width: 100%;
      padding: 4px;
      border: 1px solid var(--border-color);
      border-radius: 3px;
      background: var(--bg-primary);
      color: var(--text-primary);
      box-sizing: border-box;
      font-size: 12px;
    }

    .range-value {
      display: inline-block;
      margin-left: 8px;
      font-weight: bold;
      color: var(--accent);
      font-size: 11px;
    }

    .creator-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 15px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
      flex-wrap: wrap;
    }

    .creator-btn {
      padding: 8px 16px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .creator-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .creator-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .creator-btn.primary:hover {
      background: #0099b8;
      border-color: #0099b8;
      color: white;
    }

    /* Responsive adjustments for custom element creator */
    @media (max-width: 768px) {
      .custom-element-creator {
        padding: 10px;
        margin-top: 10px;
      }
      
      .creator-color-name {
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }
      
      .creator-name-input {
        width: 100%;
      }
      
      .property-group {
        padding: 8px;
      }
      
      .creator-actions {
        gap: 6px;
        margin-top: 12px;
        padding-top: 8px;
      }
      
      .creator-btn {
        padding: 6px 12px;
        font-size: 12px;
      }
    }

    /* Additional adjustments for narrow sidebars */
    #sidePanel .custom-element-creator {
      font-size: 90%;
    }
    
    #sidePanel .property-group {
      padding: 8px;
    }
    
    #sidePanel .creator-header h3 {
      font-size: 14px;
    }
    
    #sidePanel .creator-color-name {
      gap: 8px;
    }

    /* Enhanced styling for descriptions and property organization */
    .property-item .desc {
      color: var(--text-muted);
      font-size: 0.85em;
      font-style: italic;
      margin-left: 5px;
    }

    .property-item small {
      display: block;
      color: var(--text-muted);
      font-size: 0.75em;
      margin-top: 2px;
      line-height: 1.2;
    }

    .property-group h4 {
      margin-bottom: 12px;
      padding-bottom: 5px;
      border-bottom: 1px solid var(--border-color);
      font-size: 0.9em;
    }

    /* Conditional visibility for fire and explosion properties */
    #ignitionTempContainer,
    #fireResistanceContainer,
    #explosionTempContainer,
    #explosionRadiusContainer,
    #explosionPowerContainer,
    #explosionTypeContainer {
      display: none;
    }

    /* Better spacing for range inputs */
    .property-item input[type="range"] {
      margin: 3px 0;
    }

    .range-value {
      font-weight: bold;
      color: var(--accent);
    }

    .custom-element-warning {
      background: rgba(255, 152, 0, 0.1);
      border: 1px solid #ff9800;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 15px;
      font-size: 12px;
      color: #ff9800;
    }

    /* Make the saved games display in a grid */
    #savedGamesList {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      max-height: 280px;
      overflow-y: auto;
      padding: 10px 0;
    }

    /* Style for each save game card */
    .save-game-card {
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 10px;
      background-color: var(--bg-secondary);
      display: flex;
      flex-direction: column;
    }

    /* Container for the preview image */
    .save-preview {
      width: 100%;
      height: 120px;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }

    /* The actual preview grid */
    .preview-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: grid;
    }

    /* Info section with title and description */
    .save-info {
      margin-bottom: 10px;
    }

    .save-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
      color: var(--text-primary);
    }

    .save-description {
      font-size: 12px;
      color: var(--text-secondary);
      height: 30px;
      overflow: hidden;
    }

    /* Buttons at the bottom of each card */
    .save-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: auto;
    }

    .save-buttons button {
      padding: 5px 8px;
      font-size: 12px;
      background-color: var(--bg-secondary);
      border: none;
      color: var(--text-primary);
      cursor: pointer;
    }

    .save-buttons button:hover {
      background-color: var(--hover-bg);
      border-color: var(--accent);
      color: var(--accent);
    }

    .save-buttons .load-button {
      background-color: var(--accent);
    }

    .save-buttons .load-button:hover {
      background-color: var(--hover-bg);
    }

    /* Input groups and warnings */
    .input-group {
      margin-bottom: 10px;
      position: relative;
    }

    .input-group input {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      margin-bottom: 2px;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    .input-warning {
      color: #ff6b6b;
      font-size: 12px;
      height: 15px;
      margin-top: 2px;
    }

    .save-message {
      padding: 12px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      margin: 10px 0;
      display: none;
      animation: slideIn 0.3s ease;
    }

    .save-message.success {
      background: linear-gradient(135deg, #4caf50, #45a049);
      color: white;
      border: 1px solid #4caf50;
    }

    .save-message.error {
      background: linear-gradient(135deg, #f44336, #d32f2f);
      color: white;
      border: 1px solid #f44336;
    }

    .save-message.warning {
      background: linear-gradient(135deg, #ff9800, #f57c00);
      color: white;
      border: 1px solid #ff9800;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Info icon next to save title */
    .save-title-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }

    .save-title {
      font-weight: bold;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
      color: var(--text-primary);
    }

    .info-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: var(--accent);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-left: 8px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .info-icon:hover {
      background-color: var(--hover-bg);
    }

    /* Popup for save information */
    .save-info-popup {
      position: absolute;
      right: -250px;
      top: 0;
      width: 240px;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 10px;
      z-index: 10;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      display: none;
    }

    .save-info-popup.active {
      display: block;
    }

    .save-game-card {
      position: relative;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
    }

    .info-label {
      color: var(--text-secondary);
    }

    .info-value {
      color: var(--text-primary);
      font-weight: bold;
    }

    .close-info {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-secondary);
    }

    .close-info:hover {
      color: var(--text-primary);
    }

    #popOutWindow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      padding: 10px;
      border: 2px solid var(--border-color);
      border-radius: 5px;
      display: none;
      z-index: 2000;
    }

    /* Mobile touch support */
    @media (max-width: 1024px) {
      #mainContainer {
        flex-direction: column;
        height: auto;
      }
      #sidePanel {
        width: 100%;
        min-width: 0;
        height: auto;
      }
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      #mainContainer {
        flex-direction: column;
        align-items: center;
        padding: 15px;
      }
      #sidePanel {
        width: 100%;
        max-width: 600px;
        margin-top: 20px;
        height: auto;
        max-height: 50vh;
      }
      #grid {
        max-width: 90vw;
        max-height: 90vw;
      }
    }
    
    @media (max-width: 768px) {
      #toolbar {
        justify-content: center;
      }
      #categoryMenu {
        justify-content: center;
      }
      #hud {
        font-size: 11px;
        padding: 6px 10px;
      }
    }

    /* Add dynamic lighting styles */
    .cell.lit {
      transition: background-color 0.1s ease;
    }

    .cell.glass.lit {
      transition: background-color 0.2s ease;
      mix-blend-mode: screen;
    }

    /* Add to existing styles */
    .option-item {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      transition: border-color 0.2s ease;
      background-color: var(--bg-secondary);
    }

    .option-item:hover {
      border-color: var(--accent);
    }

    .option-description {
      color: var(--text-secondary);
      font-size: 0.9em;
      margin: 5px 0 0 0;
      font-style: italic;
    }

    /* Main menu specific styling */
    .main-menu {
      background: linear-gradient(135deg, #0a0f1c 0%, #1a1f2e 50%, #2a2f3e 100%);
      border: none;
      border-radius: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      box-shadow: none;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      z-index: 10;
    }

    /* Animated background particles */
    .menu-background {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(99, 102, 241, 0.6);
      border-radius: 50%;
      animation: float 6s ease-in-out infinite;
      box-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
    }

    .particle:nth-child(1) { top: 20%; left: 10%; animation-delay: 0s; }
    .particle:nth-child(2) { top: 80%; left: 20%; animation-delay: 1s; }
    .particle:nth-child(3) { top: 40%; left: 80%; animation-delay: 2s; }
    .particle:nth-child(4) { top: 60%; left: 70%; animation-delay: 3s; }
    .particle:nth-child(5) { top: 30%; left: 50%; animation-delay: 4s; }
    .particle:nth-child(6) { top: 70%; left: 90%; animation-delay: 5s; }
    .particle:nth-child(7) { top: 10%; left: 60%; animation-delay: 1.5s; }
    .particle:nth-child(8) { top: 90%; left: 40%; animation-delay: 3.5s; }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
      50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
    }

    .main-menu-container {
      display: flex;
      flex: 1;
      position: relative;
      z-index: 1;
      height: 100%;
      overflow: hidden;
    }

    .main-menu-left {
      flex: 1;
      padding: 40px 50px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .main-menu-right {
      flex: 0 0 30%;
      min-width: 450px;
      background: rgba(0,0,0,0.4);
      border-left: 1px solid rgba(255,255,255,0.2);
      padding: 40px 30px;
      overflow-y: auto;
      overflow-x: hidden;
      height: 100%;
    }

    /* Game logo section */
    .game-logo {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }

    .logo-icon {
      font-size: 3.5em;
      margin-right: 15px;
      text-shadow: 0 0 20px rgba(99, 102, 241, 0.6);
    }

    .logo-text h1 {
      color: #fff;
      margin: 0;
      font-size: 2.8em;
      font-weight: 900;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #ec4899 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .logo-text .subtitle {
      color: rgba(255,255,255,0.8);
      font-size: 1.2em;
      margin: 5px 0 0 0;
      font-weight: 400;
    }

    /* Feature highlights */
    .feature-highlights {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }

    .highlight-item {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.05);
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.9);
      font-size: 14px;
      font-weight: 500;
    }

    .highlight-icon {
      font-size: 18px;
      margin-right: 10px;
    }

    /* Tips section */
    .tips-section {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 16px 20px;
      margin-bottom: 25px;
      position: relative;
      overflow: hidden;
    }

    .tips-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #fbbf24, transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .tips-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .tips-header h3 {
      margin: 0;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
    }

    .tips-icon {
      font-size: 20px;
      margin-right: 10px;
      color: #fbbf24;
    }

    .tips-refresh {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 14px;
      color: rgba(255,255,255,0.8);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .tips-refresh:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
      transform: rotate(180deg);
    }

    .tip-display {
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-radius: 12px;
      padding: 12px 16px;
    }

    .tip-content {
      color: rgba(255,255,255,0.9);
      font-size: 14px;
      line-height: 1.4;
      font-weight: 500;
      text-align: center;
      animation: fadeIn 0.5s ease-in-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* New Game Modal - Match Other Modal Styles */
    #newGameModal .modal-content {
      max-width: 600px;
      width: 90vw;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      border: 2px solid var(--accent);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: modalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
    }

    #newGameModal .modal-content::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
    }

    #newGameModal h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px 25px;
      background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
      border-bottom: 3px solid var(--accent);
      color: var(--text-primary);
      position: relative;
    }

    #newGameModal h2::before {
      content: 'ðŸš€';
      font-size: 28px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
    }

    #newGameModal h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
    }

    #newGameModal .close {
      position: absolute;
      top: 20px;
      right: 25px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-primary);
      font-size: 20px;
      z-index: 10;
    }

    #newGameModal .close:hover {
      background: rgba(244, 67, 54, 0.2);
      border-color: #f44336;
      color: #f44336;
      transform: scale(1.1) rotate(90deg);
    }

    #newGameModal .options-section {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
      background: var(--bg-primary);
    }

    #newGameModal .option-item {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    #newGameModal .option-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #0099b8);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #newGameModal .option-item:hover {
      border-color: var(--accent);
      transform: translateY(-4px);
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
    }

    #newGameModal .option-item:hover::before {
      opacity: 1;
    }

    #newGameModal label {
      color: var(--text-primary);
      font-weight: 600;
      font-size: 16px;
      display: block;
      margin-bottom: 10px;
    }

    #newGameModal select {
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 10px 12px;
      font-size: 14px;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #newGameModal select:hover,
    #newGameModal select:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.1);
    }

    #newGameModal select option {
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 8px;
    }

    #newGameModal .option-description {
      color: var(--text-secondary);
      font-size: 13px;
      margin: 12px 0 0 0;
      line-height: 1.4;
    }

    #newGameModal #createCanvasBtn {
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      padding: 16px 32px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      margin-top: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    #newGameModal #createCanvasBtn:hover {
      background: #0099b8;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 180, 216, 0.3);
    }

    /* Hide options with smooth animation */
    #newGameOptions {
      transition: all 0.3s ease;
      overflow: hidden;
    }

    #newGameOptions[style*="display: none"] {
      opacity: 0;
      max-height: 0;
      margin-bottom: 0;
    }

    /* Main menu buttons */
    .main-menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }

    .main-menu-button {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 24px 30px;
      border-radius: 20px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      position: relative;
      overflow: hidden;
    }

    .button-glow {
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.6s ease;
    }

    .main-menu-button:hover .button-glow {
      left: 100%;
    }

    .main-menu-button:hover {
      background: rgba(255,255,255,0.15);
      border-color: rgba(255,255,255,0.3);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 15px 40px rgba(0,0,0,0.3);
    }

    .main-menu-button:active {
      transform: translateY(-1px) scale(1.01);
    }

    .main-menu-button.primary {
      background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
      border-color: rgba(255,255,255,0.3);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
    }

    .main-menu-button.primary:hover {
      background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
      box-shadow: 0 15px 40px rgba(59, 130, 246, 0.5);
    }

    .button-icon {
      font-size: 28px;
      margin-right: 20px;
      flex-shrink: 0;
    }

    .button-content {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      flex: 1;
    }

    .button-title {
      font-weight: 700;
      font-size: 18px;
      margin-bottom: 4px;
    }

    .button-desc {
      font-size: 14px;
      opacity: 0.8;
      font-weight: 400;
    }

    .button-arrow {
      font-size: 20px;
      opacity: 0.6;
      transition: all 0.3s ease;
    }

    .main-menu-button:hover .button-arrow {
      opacity: 1;
      transform: translateX(5px);
    }

    /* Footer */
    .main-menu-footer {
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 20px;
    }

    .version-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 15px;
    }

    .game-version {
      color: #fff;
      font-weight: 600;
      font-size: 16px;
    }

    .engine-version {
      color: rgba(255,255,255,0.6);
      font-size: 13px;
    }

    .quick-links {
      display: flex;
      gap: 20px;
    }

    .quick-links .link {
      color: rgba(255,255,255,0.7);
      text-decoration: none;
      font-size: 14px;
      transition: all 0.2s ease;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
    }

    .quick-links .link:hover {
      color: #fff;
      background: rgba(255,255,255,0.1);
    }

    /* Update log styles */
    .update-log {
      height: 100%;
    }

    .update-log-header {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .update-icon {
      font-size: 24px;
      margin-right: 12px;
    }

    .update-log-header h3 {
      color: #fff;
      margin: 0;
      font-size: 20px;
      font-weight: 700;
    }

    .update-list {
      margin-bottom: 30px;
    }

    .update-item {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.2s ease;
    }

    .update-item:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.2);
    }

    .update-item.latest {
      border-color: rgba(99, 102, 241, 0.5);
      background: rgba(99, 102, 241, 0.1);
    }

    .update-version {
      color: #6366f1;
      font-weight: 700;
      font-size: 14px;
    }

    .update-date {
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      margin-bottom: 8px;
    }

    .update-title {
      color: #fff;
      font-weight: 600;
      font-size: 15px;
      margin-bottom: 10px;
    }

    .update-features {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .update-features li {
      color: rgba(255,255,255,0.8);
      font-size: 13px;
      margin-bottom: 4px;
      padding-left: 8px;
    }

    .coming-soon {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 16px;
    }

    .coming-soon-header {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      color: #fff;
      font-weight: 600;
    }

    .coming-icon {
      margin-right: 8px;
      font-size: 18px;
    }

    .coming-features {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .coming-item {
      color: rgba(255,255,255,0.7);
      font-size: 13px;
      padding: 6px 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
    }

    /* Main Menu Modal */
    #mainMenuModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: none;
      z-index: 1000;
      overflow: hidden;
    }
    

    
    #mainMenuModal .modal-content.main-menu {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      max-height: none !important;
      margin: 0 !important;
      background: linear-gradient(135deg, #0a0f1c 0%, #1a1f2e 50%, #2a2f3e 100%) !important;
      border: none !important;
      padding: 0 !important;
      position: static !important;
      border-radius: 0 !important;
      box-shadow: none !important;
    }
    
    @media (max-width: 1024px) {
      .main-menu-container {
        flex-direction: column;
      }
      
      .main-menu-right {
        flex: none;
        border-left: none;
        border-top: 1px solid rgba(255,255,255,0.1);
        max-height: 300px;
      }
      
      .feature-highlights {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .main-menu {
        width: 99vw;
        height: 95vh;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      
      .main-menu-container {
        height: 100%;
      }
      
      .main-menu-left {
        padding: 20px;
      }
      
      .main-menu-right {
        padding: 20px;
        flex: 0 0 40%;
      }
      
      .game-logo {
        flex-direction: column;
        text-align: center;
        margin-bottom: 20px;
      }
      
      .logo-icon {
        font-size: 3em;
        margin-right: 0;
        margin-bottom: 10px;
      }
      
      .logo-text h1 {
        font-size: 2.5em;
      }
      
      .logo-text .subtitle {
        font-size: 1em;
      }
      
      .feature-highlights {
        margin-bottom: 20px;
      }
      
      .highlight-item {
        padding: 10px 12px;
        font-size: 13px;
      }
      
      .main-menu-buttons {
        gap: 12px;
        margin-bottom: 20px;
      }
      
      .main-menu-button {
        padding: 18px 20px;
      }
      
      .button-icon {
        font-size: 24px;
        margin-right: 16px;
      }
      
      .button-title {
        font-size: 16px;
      }
      
      .button-desc {
        font-size: 13px;
      }
      
      .quick-links {
        flex-direction: column;
        gap: 10px;
      }
      
      .quick-links .link {
        text-align: center;
      }
      
      .update-log-header h3 {
        font-size: 18px;
      }
      
      .update-item {
        padding: 12px;
      }
    }

    /* Help Menu Styling */
    .help-menu {
      display: none;
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .help-content {
      background-color: var(--bg-secondary);
      margin: 5% auto;
      padding: 30px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      border-radius: 15px;
      position: relative;
      display: flex;
      flex-direction: column;
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .help-page {
      display: none;
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .help-page.active {
      display: block;
    }
    
    .help-navigation {
      display: flex;
      justify-content: space-between;
      margin-top: 30px;
      padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    
    .help-navigation button {
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px 15px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .help-navigation button:hover {
      background-color: var(--bg-primary);
      color: var(--accent);
    }

    .help-nav-button {
      background: var(--bg-secondary);
      border: none;
      padding: 10px 20px;
      color: var(--text-primary);
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .help-nav-button:hover {
      background: var(--hover-bg);
    }

    .help-nav-button:disabled {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      cursor: not-allowed;
    }

    .help-close {
      position: absolute;
      right: 20px;
      top: 20px;
      font-size: 24px;
      color: var(--text-primary);
      cursor: pointer;
      background: none;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
    }

    .help-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Options modal height fix */
    .modal-content {
      margin: 2vh auto;
      flex-direction: column;
      max-height: 96vh;
      background-color: var(--bg-primary);
      border-color: var(--border-color);
      color: var(--text-primary);
    }
    
    /* Hint popup styles */
    .hint-popup {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-left: 4px solid var(--accent);
      border-radius: 4px;
      padding: 0;
      width: 300px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      transform: translateX(350px);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .hint-popup.hint-visible {
      transform: translateX(0);
      opacity: 1;
    }
    
    .hint-content {
      padding: 15px;
      position: relative;
    }
    
    .hint-message {
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .hint-close {
      display: block;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 13px;
      float: right;
      transition: all 0.2s ease;
    }
    
    .hint-close:hover {
      background-color: var(--accent);
      color: white;
    }
    
    /* Options content scrollable styles */
    .options-content {
      overflow-y: auto;
      padding-right: 10px;
      margin-right: -10px;
      flex: 1;
      max-height: calc(80vh - 120px);
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) var(--bg-secondary);
    }
    
    .options-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .options-content::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb {
      background-color: var(--border-color);
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb:hover {
      background-color: var(--accent);
    }
    
    #optionsModal h2 {
      position: sticky;
      top: 0;
      background-color: var(--bg-primary);
      margin-top: 0;
      padding-top: 10px;
      z-index: 5;
      color: var(--accent);
      text-align: center;
      font-size: 1.6em;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #optionsModal #applyOptionsButton #saveLoadModal {
      display: none !important;
      margin-top: 15px;
      background: linear-gradient(to bottom, var(--bg-secondary), var(--bg-primary));
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: var(--text-primary);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      position: sticky;
      bottom: 0;
      width: calc(100% - 20px);
      margin-left: auto;
      margin-right: auto;
      border-top: 1px solid var(--border-color);
      padding-top: 15px;
      z-index: 5;
      background-color: var(--bg-secondary);
    }
    
    #optionsModal #applyOptionsButton.show-clear-warning {
      display: block !important;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Modal footer style */
    .modal-footer {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--border-color);
      text-align: center;
    }

    /* Add to existing styles */
    .options-section.disabled {
      opacity: 0.5;
      pointer-events: none;
      position: relative;
    }

    .options-section.disabled::after {
      content: "Coming Soon";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
    }

    /* Confirmation Modal */
    .confirmation-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .confirmation-content {
      background-color: #333;
      margin: 15% auto;
      padding: 20px;
      width: 300px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      text-align: center;
      color: #fff;
    }

    .confirmation-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .confirmation-buttons button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .confirmation-yes {
      background-color: #4CAF50;
      color: white;
    }

    .confirmation-no {
      background-color: #f44336;
      color: white;
    }

    .confirmation-buttons button:hover {
      transform: scale(1.05);
    }

    /* Add styles for the apply button states */
    #applyOptionsButton {
      display: none;
    }

    #applyOptionsButton.show-clear-warning {
      display: block;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Community Button and Modal Styling */
    #communityButtonContainer {
      margin-top: 10px;
      text-align: center;
    }
    
    #communityButton {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    
    #communityButton:hover {
      background-color: #3a5a80;
    }
    
    /* Community Modal Styling */
    .login-form, .upload-form {
      margin: 15px 0;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input, .form-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
    }
    
    .form-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .message {
      margin-top: 10px;
      padding: 8px;
      border-radius: 4px;
    }
    
    .message.error {
      background-color: #ffebee;
      color: #c62828;
    }
    
    .message.success {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    
    .community-tabs {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 20px;
    }
    
    .community-tab-btn {
      background: none;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      font-size: 16px;
      border-bottom: 3px solid transparent;
      color: #fff;
    }
    
    .community-tab-btn.active {
      border-bottom: 3px solid #4a6fa5;
      font-weight: bold;
    }
    
    .community-tab-content {
      display: none;
    }
    
    .community-tab-content.active {
      display: block;
    }
    
    .community-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .community-filters select, .community-filters input {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
    }
    
    .community-filters input {
      flex-grow: 1;
    }
    
    .community-saves-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      max-height: 500px;
      overflow-y: auto;
    }
    
    .community-save-card {
      border: 1px solid #444;
      border-radius: 4px;
      padding: 15px;
      background-color: #333;
      position: relative;
    }
    
    .community-save-preview {
      width: 100%;
      height: 150px;
      background-color: #222;
      margin-bottom: 10px;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .community-save-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .community-save-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 5px;
      color: #fff;
    }
    
    .community-save-author, .community-save-date {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .community-save-description {
      font-size: 14px;
      margin-bottom: 10px;
      max-height: 60px;
      overflow: hidden;
      color: #ddd;
    }
    
    .community-save-actions {
      display: flex;
      justify-content: flex-end;
    }
    
    .community-save-actions button {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .community-save-actions button:hover {
      background-color: #3a5a80;
    }
    
    .local-saves-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #444;
      border-radius: 4px;
      margin-bottom: 15px;
      background-color: #222;
    }
    
    .local-save-item {
      padding: 10px;
      border-bottom: 1px solid #333;
      cursor: pointer;
      color: #ddd;
    }
    
    .local-save-item:last-child {
      border-bottom: none;
    }
    
    .local-save-item.selected {
      background-color: #2a4a70;
    }
    
    .local-save-item:hover {
      background-color: #444;
    }
    
    .community-loading {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }

    /* Advanced Save/Load Modal Styles */
    .save-load-modal .modal-content {
      max-width: 900px;
      width: 90vw;
      max-height: 80vh;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      border: 2px solid var(--accent);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      overflow: hidden;
    }

    .save-load-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 25px;
      background: linear-gradient(90deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: white;
      position: relative;
    }

    .save-load-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
    }

    .save-load-title {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 0;
      font-size: 1.5em;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .save-icon {
      width: 28px;
      height: 28px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .close-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: white;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .close-btn svg {
      width: 20px;
      height: 20px;
    }

    .save-load-tabs {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    .tab-btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 15px 20px;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      font-weight: 500;
      position: relative;
    }

    .tab-btn::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .tab-btn:hover {
      background: rgba(var(--accent-rgb), 0.1);
      color: var(--text-primary);
    }

    .tab-btn.active {
      color: var(--accent);
      background: rgba(var(--accent-rgb), 0.1);
    }

    .tab-btn.active::after {
      transform: scaleX(1);
    }

    .tab-btn svg {
      width: 18px;
      height: 18px;
    }

    .save-load-body {
      padding: 25px;
      max-height: 60vh;
      overflow-y: auto;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Save Tab Styles */
    .save-section {
      display: flex;
      gap: 25px;
      align-items: flex-start;
    }

    .canvas-preview {
      position: relative;
      min-width: 200px;
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid var(--border-color);
      background: var(--bg-tertiary);
    }

    .canvas-preview canvas {
      display: block;
      width: 100%;
      height: auto;
    }

    .preview-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      color: white;
      padding: 10px;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
    }

    .save-form {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .form-group label {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
    }

    .form-group input,
    .form-group textarea {
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 15px;
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.3s ease;
      resize: vertical;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(var(--accent-rgb), 0.1);
    }

    .save-info {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid var(--border-color);
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
    }

    .info-item:not(:last-child) {
      border-bottom: 1px solid var(--border-color);
    }

    .info-label {
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .info-value {
      font-weight: 600;
      color: var(--accent);
      font-size: 13px;
    }

    .primary-btn,
    .secondary-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid;
    }

    .primary-btn {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: white;
      border-color: var(--accent);
    }

    .primary-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(var(--accent-rgb), 0.3);
    }

    .secondary-btn {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border-color: var(--border-color);
    }

    .secondary-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    .primary-btn svg,
    .secondary-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Load Tab Styles */
    .saves-section {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .saves-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .saves-header h3 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1.2em;
    }

    .saves-actions {
      display: flex;
      gap: 10px;
    }

    .icon-btn {
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
      transform: scale(1.05);
    }

    .icon-btn.danger:hover {
      border-color: #ff4444;
      color: #ff4444;
    }

    .icon-btn svg {
      width: 18px;
      height: 18px;
    }

    .saves-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 20px;
      max-height: 450px;
      overflow-y: auto;
      padding: 15px 10px;
    }

    .save-card {
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.3s ease;
      cursor: pointer;
      min-height: 300px;
      display: flex;
      flex-direction: column;
    }

    .save-card:hover {
      border-color: var(--accent);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .save-preview {
      width: 100%;
      height: 140px;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
      padding: 10px;
      box-sizing: border-box;
      flex-shrink: 0;
    }

    .save-preview canvas {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      border: 1px solid var(--border-color);
      background: #000;
    }

    .save-preview-placeholder {
      color: var(--text-secondary);
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 120px;
      height: 120px;
      border: 1px solid var(--border-color);
      background: #000;
      border-radius: 4px;
    }

    .save-details {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1;
      min-height: 0;
    }

    .save-title {
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
      font-size: 16px;
      line-height: 1.3;
    }

    .save-description {
      color: var(--text-secondary);
      font-size: 13px;
      margin: 0;
      line-height: 1.4;
      flex-grow: 1;
    }

    .save-meta {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: auto;
    }

    .save-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .save-date {
      font-weight: 500;
      color: var(--text-secondary);
    }

    .save-version {
      background: rgba(0, 0, 0, 0.3);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: bold;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .save-version[style*="color: #f44336"] {
      background: rgba(244, 67, 54, 0.1);
      border-color: #f44336;
      animation: pulse-warning 2s infinite;
    }

    .save-version[style*="color: #ff9800"] {
      background: rgba(255, 152, 0, 0.1);
      border-color: #ff9800;
    }

    .save-version[style*="color: #4caf50"] {
      background: rgba(76, 175, 80, 0.1);
      border-color: #4caf50;
    }

    @keyframes pulse-warning {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .save-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .save-action-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .save-action-btn:hover {
      background: var(--bg-primary);
      transform: translateY(-1px);
    }

    .save-action-btn.load {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .save-action-btn.load:hover {
      background: #0099b8;
      border-color: #0099b8;
    }

    .save-action-btn.delete:hover {
      background: #ff4444;
      border-color: #ff4444;
      color: white;
    }

    .no-saves-message {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }

    .no-saves-message svg {
      width: 48px;
      height: 48px;
      margin-bottom: 15px;
      opacity: 0.5;
    }

    .no-saves-message h4 {
      margin: 0 0 10px 0;
      color: var(--text-primary);
      font-size: 18px;
    }

    .no-saves-message p {
      margin: 0;
      font-size: 14px;
    }

    /* Import Tab Styles */
    .import-section {
      display: flex;
      flex-direction: column;
      gap: 25px;
    }

    .import-area {
      border: 3px dashed var(--border-color);
      border-radius: 12px;
      background: var(--bg-tertiary);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .import-area:hover,
    .import-area.dragover {
      border-color: var(--accent);
      background: rgba(var(--accent-rgb), 0.05);
    }

    .import-content {
      padding: 40px;
      text-align: center;
    }

    .import-icon {
      width: 60px;
      height: 60px;
      color: var(--accent);
      margin-bottom: 20px;
    }

    .import-area h3 {
      margin: 0 0 10px 0;
      color: var(--text-primary);
      font-size: 20px;
    }

    .import-area p {
      margin: 0 0 20px 0;
      color: var(--text-secondary);
      font-size: 14px;
    }

    .import-info {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid var(--border-color);
    }

    .import-info h4 {
      margin: 0 0 15px 0;
      color: var(--text-primary);
      font-size: 16px;
    }

    .import-info ul {
      margin: 0;
      padding-left: 20px;
      color: var(--text-secondary);
    }

    .import-info li {
      margin-bottom: 8px;
      font-size: 14px;
    }

    /* Pixel mode compatibility */
    body.pixel-mode .save-load-modal .modal-content,
    body.pixel-mode .save-load-modal .close-btn,
    body.pixel-mode .save-load-modal .tab-btn,
    body.pixel-mode .save-load-modal .primary-btn,
    body.pixel-mode .save-load-modal .secondary-btn,
    body.pixel-mode .save-load-modal .icon-btn,
    body.pixel-mode .save-load-modal .save-card,
    body.pixel-mode .save-load-modal .import-area,
    body.pixel-mode .save-load-modal .canvas-preview,
    body.pixel-mode .save-load-modal .save-info,
    body.pixel-mode .save-load-modal .import-info,
    body.pixel-mode .save-load-modal input,
    body.pixel-mode .save-load-modal textarea {
      image-rendering: pixelated;
      border-radius: 0;
    }

    body.pixel-mode .save-load-modal .close-btn svg,
    body.pixel-mode .save-load-modal .tab-btn svg,
    body.pixel-mode .save-load-modal .primary-btn svg,
    body.pixel-mode .save-load-modal .secondary-btn svg,
    body.pixel-mode .save-load-modal .icon-btn svg,
    body.pixel-mode .save-load-modal .save-icon,
    body.pixel-mode .save-load-modal .import-icon,
    body.pixel-mode .save-load-modal .no-saves-message svg {
      image-rendering: pixelated;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .save-load-modal .modal-content {
        width: 95vw;
        max-height: 90vh;
      }

      .save-section {
        flex-direction: column;
        gap: 20px;
      }

      .canvas-preview {
        min-width: auto;
        max-width: 200px;
        align-self: center;
      }

      .saves-grid {
        grid-template-columns: 1fr;
      }

      .tab-btn {
        font-size: 12px;
        padding: 12px 10px;
      }

      .tab-btn svg {
        width: 16px;
        height: 16px;
      }
    }

    /* Mod Info Section Styles */
    .mod-info-section {
      background: linear-gradient(135deg, var(--accent-dark), var(--accent));
      color: white;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .mod-info-section h4 {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: 600;
    }

    .mod-info-section p {
      margin: 0 0 15px 0;
      opacity: 0.9;
      line-height: 1.4;
    }

    .mod-format-example {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid rgba(255, 255, 255, 0.3);
    }

    .mod-format-example h5 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 600;
    }

    .mod-format-example p {
      margin: 0 0 10px 0;
      font-size: 13px;
    }

    .mod-format-example code {
      display: block;
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.4;
      color: #fff;
      overflow-x: auto;
    }

    /* Pixel mode compatibility for mod info section */
    body.pixel-mode .mod-info-section,
    body.pixel-mode .mod-format-example,
    body.pixel-mode .mod-format-example code {
      border-radius: 0 !important;
    }
    

  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f172a 100%);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    font-family: 'Pixelify Sans', monospace;
    transition: opacity 0.5s ease-out;
  ">
    <div id="loadingContent" style="text-align: center; max-width: 500px; padding: 20px;">
      <!-- Loading Icon -->
      <div id="loadingIcon" style="
        width: 80px;
        height: 80px;
        margin: 0 auto 30px auto;
        position: relative;
        animation: loadingPulse 2s ease-in-out infinite;
      ">
        <svg width="80" height="80" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
          <!-- Delta symbol with particle effects -->
          <defs>
            <linearGradient id="loadingDeltaGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#00b4d8;stop-opacity:1" />
              <stop offset="50%" style="stop-color:#0077b6;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#90e0ef;stop-opacity:1" />
            </linearGradient>
            <radialGradient id="loadingParticleGradient">
              <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#90e0ef;stop-opacity:0.3" />
            </radialGradient>
          </defs>
          
          <!-- Background circle -->
          <circle cx="40" cy="40" r="38" fill="url(#loadingDeltaGradient)" opacity="0.2"/>
          
          <!-- Delta symbol -->
          <path d="M 40 12 L 60 52 L 20 52 Z" fill="none" stroke="url(#loadingDeltaGradient)" stroke-width="4" stroke-linejoin="round"/>
          <path d="M 40 18 L 56 48 L 24 48 Z" fill="url(#loadingDeltaGradient)" opacity="0.8"/>
          
          <!-- Animated particles -->
          <circle cx="25" cy="32" r="3" fill="url(#loadingParticleGradient)">
            <animate attributeName="cy" values="32;28;32" dur="2s" repeatCount="indefinite"/>
            <animate attributeName="opacity" values="1;0.5;1" dur="2s" repeatCount="indefinite"/>
          </circle>
          <circle cx="55" cy="38" r="2.5" fill="url(#loadingParticleGradient)">
            <animate attributeName="cx" values="55;58;55" dur="1.5s" repeatCount="indefinite"/>
            <animate attributeName="opacity" values="0.8;0.3;0.8" dur="1.5s" repeatCount="indefinite"/>
          </circle>
          <circle cx="40" cy="45" r="2" fill="url(#loadingParticleGradient)">
            <animate attributeName="r" values="2;3;2" dur="1s" repeatCount="indefinite"/>
          </circle>
          <circle cx="32" cy="25" r="2.2" fill="url(#loadingParticleGradient)">
            <animate attributeName="opacity" values="0.6;1;0.6" dur="1.8s" repeatCount="indefinite"/>
          </circle>
          <circle cx="48" cy="28" r="1.8" fill="url(#loadingParticleGradient)">
            <animate attributeName="cy" values="28;25;28" dur="2.2s" repeatCount="indefinite"/>
          </circle>
        </svg>
      </div>
      
      <!-- Title -->
      <h1 id="loadingTitle" style="
        font-size: 48px;
        margin: 0 0 10px 0;
        background: linear-gradient(45deg, #00b4d8, #90e0ef);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 0 20px rgba(0, 180, 216, 0.3);
      ">Sandbox Delta</h1>
      
      <!-- Version -->
      <p id="loadingVersion" style="
        font-size: 16px;
        color: #a8a8a8;
        margin: 0 0 30px 0;
      ">Version 0.7.1c</p>
      
      <!-- Loading Bar -->
      <div id="loadingBarContainer" style="
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 20px;
      ">
        <div id="loadingBar" style="
          height: 100%;
          background: linear-gradient(90deg, #00b4d8, #90e0ef);
          width: 0%;
          transition: width 0.3s ease;
          border-radius: 4px;
        "></div>
      </div>
      
      <!-- Loading Text -->
      <p id="loadingText" style="
        font-size: 14px;
        color: #e6e6e6;
        margin: 0;
        min-height: 20px;
      ">Initializing physics engine...</p>
      
      <!-- Tip -->
      <p id="loadingTip" style="
        font-size: 12px;
        color: #8a8a8a;
        margin-top: 30px;
        font-style: italic;
      "></p>
    </div>
  </div>

  <style>
    @keyframes loadingPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    @keyframes loadingInner {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
      50% { transform: translate(-50%, -50%) rotate(180deg); }
    }
    
    /* Retro pixel mode loading screen */
    body.pixel-mode #loadingScreen {
      background: #0a0a0a !important;
      font-family: 'Dogica', monospace !important;
    }
    
    body.pixel-mode #loadingIcon {
      animation: pixelBlink 1s linear infinite !important;
    }
    
    body.pixel-mode #loadingIcon svg {
      filter: hue-rotate(100deg) saturate(2) brightness(1.5) !important;
    }
    
    body.pixel-mode #loadingTitle {
      color: #00ff00 !important;
      text-shadow: 2px 2px 0 #008800 !important;
      background: none !important;
      -webkit-text-fill-color: #00ff00 !important;
    }
    
    body.pixel-mode #loadingBarContainer {
      border-radius: 0 !important;
      background: #333333 !important;
      border: 2px solid #00ff00 !important;
    }
    
    body.pixel-mode #loadingBar {
      border-radius: 0 !important;
      background: #00ff00 !important;
    }
    
    @keyframes pixelBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
  </style>

  <!-- Selected element notification (moved here to ensure it's available when scripts run) -->
  <div id="selectedElementNotification">
    <div class="element-color" id="selectedElementColor"></div>
    <span id="selectedElementName">Element</span>
  </div>

  <!-- Main Menu Modal -->
  <div id="mainMenuModal" class="modal" style="display: block;">
    <div class="modal-content main-menu">
      <!-- Animated background particles -->
      <div class="menu-background">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
      </div>
      
      <div class="main-menu-container">
        <!-- Left side - Main content -->
        <div class="main-menu-left">
          <div class="main-menu-header">
            <div class="game-logo">
              <div class="logo-icon">
                <svg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                  <!-- Delta symbol with particle effects -->
                  <defs>
                    <linearGradient id="deltaGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                      <stop offset="0%" style="stop-color:#00b4d8;stop-opacity:1" />
                      <stop offset="50%" style="stop-color:#0077b6;stop-opacity:1" />
                      <stop offset="100%" style="stop-color:#90e0ef;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="particleGradient">
                      <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
                      <stop offset="100%" style="stop-color:#90e0ef;stop-opacity:0.3" />
                    </radialGradient>
                  </defs>
                  
                  <!-- Background circle -->
                  <circle cx="30" cy="30" r="28" fill="url(#deltaGradient)" opacity="0.2"/>
                  
                  <!-- Delta symbol -->
                  <path d="M 30 10 L 45 40 L 15 40 Z" fill="none" stroke="url(#deltaGradient)" stroke-width="3" stroke-linejoin="round"/>
                  <path d="M 30 15 L 42 37 L 18 37 Z" fill="url(#deltaGradient)" opacity="0.8"/>
                  
                  <!-- Particles -->
                  <circle cx="20" cy="25" r="2" fill="url(#particleGradient)">
                    <animate attributeName="cy" values="25;22;25" dur="2s" repeatCount="indefinite"/>
                    <animate attributeName="opacity" values="1;0.5;1" dur="2s" repeatCount="indefinite"/>
                  </circle>
                  <circle cx="40" cy="30" r="1.5" fill="url(#particleGradient)">
                    <animate attributeName="cx" values="40;42;40" dur="1.5s" repeatCount="indefinite"/>
                    <animate attributeName="opacity" values="0.8;0.3;0.8" dur="1.5s" repeatCount="indefinite"/>
                  </circle>
                  <circle cx="30" cy="35" r="1" fill="url(#particleGradient)">
                    <animate attributeName="r" values="1;1.5;1" dur="1s" repeatCount="indefinite"/>
                  </circle>
                  <circle cx="25" cy="20" r="1.2" fill="url(#particleGradient)">
                    <animate attributeName="opacity" values="0.6;1;0.6" dur="1.8s" repeatCount="indefinite"/>
                  </circle>
                  <circle cx="35" cy="22" r="0.8" fill="url(#particleGradient)">
                    <animate attributeName="cy" values="22;20;22" dur="2.2s" repeatCount="indefinite"/>
                  </circle>
                </svg>
              </div>
              <div class="logo-text">
                <h1>Sandbox Delta</h1>
                <p class="subtitle">Physics-Based Particle Simulation</p>
              </div>
            </div>
            
            <div class="feature-highlights">
              <div class="highlight-item">
                <span class="highlight-icon">âš›ï¸</span>
                <span>Realistic Physics</span>
              </div>
              <div class="highlight-item">
                <span class="highlight-icon">ðŸ”¥</span>
                <span>Dynamic Elements</span>
              </div>
              <div class="highlight-item">
                <span class="highlight-icon">ðŸŽ¨</span>
                <span>Custom Creation</span>
              </div>
              <div class="highlight-item">
                <span class="highlight-icon">ðŸ§ª</span>
                <span>Chemical Reactions</span>
              </div>
            </div>
            
            <!-- Tips Section -->
            <div class="tips-section">
              <div class="tips-header">
                <span class="tips-icon">ðŸ’¡</span>
                <h3>Quick Tips</h3>
                <button class="tips-refresh" onclick="rotateTip()">ðŸ”„</button>
              </div>
              <div class="tip-display">
                <div class="tip-content" id="currentTip">Hold Alt while placing to create square patterns</div>
              </div>
            </div>
          </div>
          
          <div class="main-menu-buttons">
            <button id="beginGameBtn" class="main-menu-button primary">
              <div class="button-glow"></div>
              <div class="button-icon">ðŸš€</div>
              <div class="button-content">
                <span class="button-title">Start Playing</span>
                <span class="button-desc">Create and experiment with physics</span>
              </div>
              <div class="button-arrow">â†’</div>
            </button>
            
            <button id="helpBtn" class="main-menu-button">
              <div class="button-glow"></div>
              <div class="button-icon">ðŸ“–</div>
              <div class="button-content">
                <span class="button-title">Help & Tutorial</span>
                <span class="button-desc">Learn the basics and advanced features</span>
              </div>
              <div class="button-arrow">â†’</div>
            </button>
          </div>
          
          <div class="main-menu-footer">
            <div class="version-info">
              <span class="game-version">Sandbox Delta v0.7.1c</span>
              <span class="engine-version">Powered by Dabicco Engine 8.7.4</span>
            </div>

          </div>
        </div>
        
        <!-- Right side - Update log -->
        <div class="main-menu-right">
          <div class="update-log">
            <div class="update-log-header">
              <div class="update-icon">ðŸ“‹</div>
              <h3>Recent Updates</h3>
            </div>
            
            <div class="update-list">
              <div class="update-item latest" style="background: rgba(99, 102, 241, 0.15); border-color: rgba(99, 102, 241, 0.5);">
                <div class="update-version">ðŸ“ Update Tracking</div>
                <div class="update-date">Starting Now</div>
                <div class="update-title">ðŸš€ Future Updates Will Be Tracked Here</div>
                <div style="color: rgba(255,255,255,0.8); font-size: 14px; line-height: 1.6; padding: 10px 0;">
                  Welcome to Sandbox Delta! From this point forward, all game updates, new features, and improvements will be documented in this update log. Stay tuned for exciting developments!
                </div>
              </div>
            </div>
            
            <div class="coming-soon">
              <div class="coming-soon-header">
                <span class="coming-icon">ðŸ”®</span>
                <span>Coming Soon</span>
              </div>
              <div class="coming-features">
                <div class="coming-item">ðŸŒ Multiplayer Mode</div>
                <div class="coming-item">ðŸ† Achievement System</div>
                <div class="coming-item">ðŸŽµ Audio & Sound Effects</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Menu -->
  <div id="helpModal" class="modal">
    <div class="help-content">
      <button class="help-close">&times;</button>
      <div class="help-page active" data-page="1">
        <h2>Welcome to Sandbox Delta</h2>
        <p>Sandbox Delta is a physics-based particle simulation game where you can experiment with various elements and their interactions. Create complex systems, generate reactions, and explore the possibilities!<br>The game is compiled on Dabicco Engine 8.7.4</p>
        
        <h3>Basic Controls</h3>
        <ul>
          <li><strong>Left Click/Touch:</strong> Place selected element</li>
          <li><strong>Right Click:</strong> Erase elements</li>
          <li><strong>Mouse Wheel:</strong> Adjust brush size</li>
          <li><strong>Alt + Left Click:</strong> Place elements in a square pattern instead of circle</li>
          <li><strong>Shift + Left Click:</strong> Draw straight lines</li>
  
          <li><strong>Spacebar:</strong> Pause/resume simulation</li>
        </ul>

        <h3>Interface Overview</h3>
        <ul>
          <li><strong>Main Grid:</strong> The simulation area where elements interact</li>
          <li><strong>Side Panel:</strong> Contains element selection and categories</li>
          <li><strong>Speed Slider:</strong> Controls simulation speed (0.0x to 4.0x)</li>
          <li><strong>Element Search:</strong> Quick-find elements by name</li>
          <li><strong>Sort Order:</strong> Change how elements are organized in the toolbar</li>
          <li><strong>HUD:</strong> Shows temperature, selected element, and FPS</li>
        </ul>
        
        <div class="help-navigation">
          <button class="help-next">Next: Elements & Categories â†’</button>
        </div>
      </div>

      <div class="help-page" data-page="2">
        <h2>Elements & Categories</h2>
        
        <h3>Basic Elements</h3>
        <ul>
          <li><strong>Sand:</strong> Basic powder that falls and piles up</li>
          <li><strong>Water:</strong> Flows and interacts with other elements, can evaporate when heated</li>
          <li><strong>Fire:</strong> Burns flammable materials and spreads, requires fuel to continue</li>
          <li><strong>Wood:</strong> Can be burned and supports plant growth</li>
          <li><strong>Stone/Wall:</strong> Solid structures that don't easily break down</li>
          <li><strong>Dirt:</strong> Foundation for plants, can become wet dirt when watered</li>
          <li><strong>Lava:</strong> Melts materials and ignites flammable elements, cools into stone</li>
        </ul>
        
        <h3>Element Categories</h3>
        <ul>
          <li><strong>Solids:</strong> Static elements that don't move unless acted upon</li>
          <li><strong>Powders:</strong> Granular materials that fall and form piles</li>
          <li><strong>Liquids:</strong> Flow and take the shape of their container</li>
          <li><strong>Gases:</strong> Rise upward and disperse throughout open spaces</li>
          <li><strong>Life:</strong> Plants, seeds, and living organisms that grow and evolve</li>
          <li><strong>Explosives:</strong> Elements that create powerful reactions</li>
          <li><strong>Electricity:</strong> Conductors, insulators, and electrical components</li>
          <li><strong>Special:</strong> Unique elements with specialized behaviors</li>
        </ul>
        
        <div class="help-navigation">
          <button class="help-prev">â† Previous</button>
          <button class="help-next">Next: Advanced Mechanics â†’</button>
        </div>
      </div>
      
      <div class="help-page" data-page="3">
        <h2>Advanced Mechanics</h2>
        
        <h3>Temperature System</h3>
        <p>Every element has a temperature that affects its behavior and interactions:</p>
        <ul>
          <li><strong>Heat Transfer:</strong> Elements exchange heat with neighboring elements</li>
          <li><strong>State Changes:</strong> Materials can melt, freeze, evaporate, or condense based on temperature</li>
          <li><strong>Heat Tool:</strong> Increases temperature of targeted area</li>
          <li><strong>Cool Tool:</strong> Decreases temperature of targeted area</li>
          <li><strong>Temperature Visualization:</strong> Enable in options menu to see heat distribution</li>
        </ul>
        
        <h3>Chemical Reactions</h3>
        <ul>
          <li><strong>Water + Fire:</strong> Creates steam and extinguishes fire</li>
          <li><strong>Acid + Materials:</strong> Dissolves most elements on contact</li>
          <li><strong>Salt + Water:</strong> Creates salt water, which can evaporate to form salt crystals</li>
          <li><strong>Oil + Fire:</strong> Creates longer-lasting flames</li>
          <li><strong>Sugar + Water:</strong> Creates sugar water solution</li>
        </ul>
        
        <h3>Plant Growth</h3>
        <ul>
          <li><strong>Seeds:</strong> Planted in dirt/wet dirt, grow into plants with adequate conditions</li>
          <li><strong>Trees:</strong> Oak and birch trees grow from their respective saplings</li>
          <li><strong>Grass:</strong> Spreads across dirt surfaces and can be burned</li>
          <li><strong>Roots:</strong> Absorb water to sustain plant growth</li>
        </ul>
        
        <div class="help-navigation">
          <button class="help-prev">â† Previous</button>
          <button class="help-next">Next: Special Tools â†’</button>
        </div>
      </div>
      
      <div class="help-page" data-page="4">
        <h2>Special Tools & Features</h2>
        
        <h3>Specialized Tools</h3>
        <ul>
          <li><strong>Eraser:</strong> Removes elements from the grid</li>
          <li><strong>Move Tool:</strong> Shifts elements without changing their properties</li>
          <li><strong>Sponge Tool:</strong> Absorbs liquids in the target area</li>
          <li><strong>Extinguish Tool:</strong> Puts out fires without adding water</li>
          <li><strong>Grind Tool:</strong> Breaks solid materials into powder form</li>
          <li><strong>Mix Tool:</strong> Blends compatible elements together</li>
          <li><strong>Cook Tool:</strong> Applies heat to food items, creating cooked versions</li>
        </ul>
        
        <h3>Electrical Elements</h3>
        <ul>
          <li><strong>Copper:</strong> Conducts electricity and can oxidize over time</li>
          <li><strong>Wire:</strong> Transmits electrical signals through circuits</li>
          <li><strong>Battery:</strong> Provides power source for electrical components</li>
          <li><strong>Spark:</strong> Initiates electrical flow and can ignite flammable materials</li>
          <li><strong>Heater/Cooler:</strong> Electrical components that modify temperature</li>
          <li><strong>Input/Output:</strong> Create logic gates and control systems</li>
        </ul>
        
        <h3>Save/Load System</h3>
        <p>Preserve your creations for later use:</p>
        <ul>
          <li><strong>Quick Save:</strong> Stores current state temporarily</li>
          <li><strong>Named Saves:</strong> Create multiple saved states with custom names</li>
          <li><strong>Export/Import:</strong> Share your creations with others via files</li>
          <li><strong>Download Offline:</strong> Save the game as a standalone HTML file</li>
        </ul>
        
        <div class="help-navigation">
          <button class="help-prev">â† Previous</button>
          <button class="help-next">Next: Advanced Tips â†’</button>
        </div>
      </div>
      
      <div class="help-page" data-page="5">
        <h2>Advanced Tips & Techniques</h2>
        
        <h3>Building Effective Structures</h3>
        <ul>
          <li><strong>Reinforced Walls:</strong> Use steel or stone for heat-resistant barriers</li>
          <li><strong>Water Reservoirs:</strong> Create contained areas to store liquids</li>
          <li><strong>Pressure Systems:</strong> Use gravity and liquid flow to create machines</li>
          <li><strong>Heat Management:</strong> Insulate explosive or volatile materials</li>
        </ul>
        
        <h3>Performance Optimization</h3>
        <ul>
          <li><strong>Grid Size:</strong> Smaller grids perform better on slower devices</li>
          <li><strong>Element Quantity:</strong> Large amounts of liquids/gases impact performance most</li>
          <li><strong>Lighting Effects:</strong> Disable DSPLE lighting for improved performance</li>
          <li><strong>Simulation Speed:</strong> Lower speeds are easier for the physics engine to process</li>
        </ul>
        
        <h3>Keyboard Shortcuts</h3>
        <ul>
          <li><strong>1-9 Keys:</strong> Quick select first 9 elements in toolbar</li>
          <li><strong>E:</strong> Select eraser tool</li>
          <li><strong>Q:</strong> Increase brush size</li>
          <li><strong>A:</strong> Decrease brush size</li>
          <li><strong>P:</strong> Pause/Resume simulation</li>
          <li><strong>C:</strong> Clear entire grid</li>
          <li><strong>F:</strong> Toggle FPS display</li>
        </ul>
        
        <h3>Mod Support</h3>
        <p>Extend Sandbox Delta with community-created modifications:</p>
        <ul>
          <li><strong>Custom Elements:</strong> Add new materials with unique properties</li>
          <li><strong>Behavior Scripts:</strong> Modify how elements interact</li>
          <li><strong>Visual Themes:</strong> Change the appearance of the simulation</li>
          <li><strong>Import/Export:</strong> Share mods with the community</li>
        </ul>
        
        <div class="help-navigation">
          <button class="help-prev">â† Previous</button>
        </div>
      </div>
      </div>

      <div class="help-page" data-page="3">
        <h2>Advanced Mechanics</h2>
        
        <h3>Temperature System</h3>
        <p>Elements have temperature properties that affect their behavior:</p>
        <ul>
          <li>Heat Transfer: Elements conduct heat between each other</li>
          <li>State Changes: Water boils to steam, lava cools to stone</li>
          <li>Reactions: High temperatures can cause burning, melting, or explosions</li>
          <li>Tools: Use Heat and Cool tools to manipulate temperature</li>
        </ul>

        <h3>Plant Growth</h3>
        <ul>
          <li>Wheat: Grows from seeds, produces flour</li>
          <li>Oak Trees: Complex growth with branches and leaves</li>
          <li>Grass: Spreads naturally on dirt</li>
          <li>Roots: Absorb water from wet soil</li>
        </ul>

        <h3>Special Tools</h3>
        <ul>
          <li>Mix Tool: Stirs elements together</li>
          <li>Move Tool: Precisely position elements</li>
          <li>Sponge: Removes burning materials</li>
          <li>Cook Tool: Process food items</li>
        </ul>
      </div>

      <div class="help-page" data-page="4">
        <h2>Advanced Features</h2>
        
        <h3>Electrical System</h3>
        <p>Create complex circuits and logic systems:</p>
        <ul>
          <li>Copper: Conducts electricity and heat</li>
          <li>Spark: Initiates electrical current</li>
          <li>Logic Gates: NOT, AND gates for circuits</li>
          <li>Input/Output: Control signal flow</li>
          <li>Heat Separator: Manages heat distribution</li>
        </ul>

        <h3>Chemical Reactions</h3>
        <ul>
          <li>Sand + Heat = Glass</li>
          <li>Water + Lava = Stone/Obsidian</li>
          <li>Flour + Water = Dough</li>
          <li>Dough + Heat = Bread</li>
          <li>Coal + Heat = Long-burning fuel</li>
        </ul>
      </div>

      <div class="help-page" data-page="5">
        <h2>Game Features</h2>
        
        <h3>Save System</h3>
        <ul>
          <li>Save/Load: Store and retrieve your creations</li>
          <li>Export: Share save files with other players</li>
          <li>Import: Load shared save files</li>
        </ul>

        <h3>World Generation</h3>
        <ul>
          <li>Terrain Generation: Create natural landscapes</li>
          <li>Cave Systems: Underground networks</li>
          <li>Ore Deposits: Find valuable materials</li>
          <li>Ecosystems: Plants and wildlife</li>
        </ul>

        <h3>Mod Support</h3>
        <ul>
          <li>Custom Elements: Add new materials</li>
          <li>New Behaviors: Modify element interactions</li>
          <li>Visual Effects: Change appearance</li>
          <li>Game Extensions: Add new features</li>
        </ul>

        <h3>Tips & Tricks</h3>
        <ul>
          <li>Use the search function to quickly find elements</li>
          <li>Adjust brush size for precise or broad placement</li>
          <li>Experiment with element combinations</li>
          <li>Watch temperature changes in the HUD</li>
          <li>Try the terrain generator for inspiration</li>
        </ul>
      </div>

      <div class="help-navigation">
        <button class="help-nav-button" id="prevPage" disabled>Previous Page</button>
        <span id="pageIndicator">Page 1 of 5</span>
        <button class="help-nav-button" id="nextPage">Next Page</button>
      </div>
    </div>
  </div>

  <script>
    // Help menu functionality
    document.addEventListener('DOMContentLoaded', function() {
      const helpModal = document.getElementById('helpModal');
      const helpBtn = document.getElementById('helpBtn');
      const closeHelpBtn = document.querySelector('.help-close');
      const helpPages = document.querySelectorAll('.help-page');
      let currentHelpPage = 1;
      
      helpBtn.addEventListener('click', () => {
        helpModal.style.display = 'block';
        showHelpPage(1);
      });

      closeHelpBtn.addEventListener('click', () => {
        helpModal.style.display = 'none';
      });

      // Initialize help navigation buttons
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('help-next')) {
          // Find current page and show next
          const nextPage = currentHelpPage + 1;
          if (nextPage <= helpPages.length) {
            showHelpPage(nextPage);
          }
        } else if (e.target.classList.contains('help-prev')) {
          // Find current page and show previous
          const prevPage = currentHelpPage - 1;
          if (prevPage >= 1) {
            showHelpPage(prevPage);
          }
        }
      });
      
      function showHelpPage(pageNum) {
        // Hide all pages
        helpPages.forEach(page => page.classList.remove('active'));
        
        // Show the requested page
        const pageToShow = document.querySelector(`.help-page[data-page="${pageNum}"]`);
        if (pageToShow) {
          pageToShow.classList.add('active');
          currentHelpPage = pageNum;
        }
      }

      // Fix for load save functionality
      document.getElementById('createCanvasBtn').addEventListener('click', function() {
        const creationMode = document.getElementById('gameCreationMode').value;
        
        if (creationMode === 'load') {
          // Initialize with default settings
          initGrid(75);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Show load menu
          const saveLoadModal = document.getElementById('saveLoadModal');
          saveLoadModal.style.display = 'block';
          saveLoadModal.querySelector('h2').textContent = 'Load';
          const saveSection = saveLoadModal.querySelector('div:first-of-type');
          if (saveSection) saveSection.style.display = 'none';
          updateSavedGamesList();
        } else {
          // Normal new game creation
          const size = parseInt(document.getElementById('newGameSizeSelect').value);
          const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
          
          initGrid(size);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Add terrain generation function if it doesn't exist
          if (typeof generateTerrain !== 'function') {
            window.generateTerrain = function() {
              // Simple terrain generation - create ground at the bottom half
              const groundLevel = Math.floor(GRID_SIZE * 0.7);
              
              for (let y = groundLevel; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                  // Mostly dirt with some sand and stone
                  const rand = Math.random();
                  if (rand < 0.7) {
                    grid[y][x] = DIRT;
                    temp[y][x] = 20;
                  } else if (rand < 0.9) {
                    grid[y][x] = SAND;
                    temp[y][x] = 20;
                  } else {
                    grid[y][x] = STONE;
                    temp[y][x] = 20;
                  }
                }
              }
              
              // Add some underground features
              for (let i = 0; i < Math.floor(GRID_SIZE/5); i++) {
                const caveX = Math.floor(Math.random() * GRID_SIZE);
                const caveY = Math.floor(groundLevel + Math.random() * (GRID_SIZE - groundLevel));
                const caveSize = 3 + Math.floor(Math.random() * 4);
                
                for (let dy = -caveSize; dy <= caveSize; dy++) {
                  for (let dx = -caveSize; dx <= caveSize; dx++) {
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance <= caveSize) {
                      const nx = caveX + dx;
                      const ny = caveY + dy;
                      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && ny >= groundLevel) {
                        grid[ny][nx] = EMPTY;
                        temp[ny][nx] = null;
                      }
                    }
                  }
                }
              }
              
              renderGrid();
            };
          }
          
          if (shouldGenerateTerrain) {
            generateTerrain();
          }
        }
      });
    });

    // Tips rotation functionality
    const mainMenuTips = [
      "Hold Alt while placing to create square patterns",
      "Use the mouse wheel to change brush size",
      "Right-click to erase elements quickly",
      "Try mixing fire and water to create steam",
      "Plants need water and dirt to grow properly",
      "Lava cools into stone when it touches water",
      "Electricity flows through copper wires efficiently",
      "Use the space bar to pause the simulation",
      
      "The Heat tool increases element temperatures",
      "The Cool tool can freeze water into ice",
      "Salt dissolves in water to create salt water",
      "Oil burns longer and hotter than other materials",
      "Acid dissolves most elements on contact",
      "Trees grow from seeds planted in dirt",
      "Coal burns very hot and lasts a long time",
      "Glass can be made by heating sand to high temperatures",
      "Birds fly around and avoid dangerous areas",
      "Use the Terrain Generator for instant landscapes",
      "Custom elements let you create your own materials",
      "The HUD shows temperature and element information",
      "Mods can add new elements and change game behavior",
      "Use the Search function to quickly find specific elements",
      "Mix Tool stirs elements together for interesting effects",
      "Diamond is extremely hard and heat-resistant",
      "Water and lava create obsidian at high temperatures",
      "Wood burns to create ash when ignited",
      "Steel is resistant to most forms of damage"
    ];

    let currentTipIndex = 0;

    function rotateTip() {
      const tipElement = document.getElementById('currentTip');
      if (tipElement) {
        // Add fade out effect
        tipElement.style.opacity = '0';
        tipElement.style.transform = 'translateY(-10px)';
        
        setTimeout(() => {
          currentTipIndex = (currentTipIndex + 1) % mainMenuTips.length;
          tipElement.textContent = mainMenuTips[currentTipIndex];
          
          // Reset animation
          tipElement.style.animation = 'none';
          tipElement.offsetHeight; // Force reflow
          tipElement.style.animation = 'fadeIn 0.5s ease-in-out';
          tipElement.style.opacity = '1';
          tipElement.style.transform = 'translateY(0)';
        }, 250);
      }
    }

    // Auto-rotate tips every 5 seconds
    setInterval(rotateTip, 5000);
  </script>

  <!-- New Game Modal -->
  <div id="newGameModal" class="modal">
    <div class="modal-content">
      <span id="closeNewGameModal" class="close">&times;</span>
      <h2>New Game</h2>
      <div class="options-section">
        <div class="option-item">
          <label for="gameCreationMode">Game Creation Mode:</label>
          <select id="gameCreationMode">
            <option value="new">New Game</option>
            <option value="load">Load Save</option>
          </select>
          <p class="option-description">Choose between creating a new game or loading an existing save.</p>
        </div>

        <div id="newGameOptions">
          <div class="option-item">
            <label for="newGameSizeSelect">Stage Size:</label>
            <select id="newGameSizeSelect">
              <option value="25">25x25</option>
              <option value="50">50x50</option>
              <option value="75" selected>75x75</option>
              <option value="100">100x100</option>
              <option value="125">125x125</option>
              <option value="150">150x150</option>
              <option value="175">175x175</option>
              <option value="200">200x200</option>
            </select>
            <p class="option-description">Changes the size of the simulation grid. Larger sizes may impact performance.</p>
          </div>

          <div class="option-item">
            <label for="generateTerrainToggle">Generate Terrain:</label>
            <select id="generateTerrainToggle">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Start with a procedurally generated world containing caves, ores, and surface features.</p>
          </div>
        </div>
      </div>
      <button id="createCanvasBtn" class="main-menu-button">Create Canvas</button>
    </div>
  </div>

  <script>
    // Game version updated to 0.7.1c
    window.currentGameVersion = "0.7.1c";

    // Initialize main menu system
    document.addEventListener('DOMContentLoaded', function() {
      const mainContainer = document.getElementById('mainContainer');
      const mainMenuModal = document.getElementById('mainMenuModal');
      const newGameModal = document.getElementById('newGameModal');
      const saveLoadModal = document.getElementById('saveLoadModal');
      const modMenu = document.getElementById('modMenu');
      const urlParams = getUrlParameters();

      // Update version displays
      const gameVersionSpan = document.querySelector('.game-version');
      if (gameVersionSpan) {
        gameVersionSpan.textContent = `Sandbox Delta v${window.currentGameVersion || '0.7.1c'}`;
      }

      // Hide main container initially

      // Handle URL parameters
      if (urlParams.skipload === 'true') {
        // Skip loading screen immediately
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
          loadingScreen.style.display = 'none';
        }
      }

      if (urlParams.skipmenu === 'true') {
        // Skip menu and start game directly
        let stageSize = 75; // Default size
        
        // Check if custom stage size is provided
        if (urlParams.stagesize) {
          const customSize = parseInt(urlParams.stagesize);
          if (!isNaN(customSize) && customSize > 0) {
            stageSize = customSize;
          }
        }
        
        // Initialize game directly
        initGrid(stageSize);
        mainMenuModal.style.display = 'none';
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
      } else if (urlParams.stagesize && !urlParams.skipmenu) {
        // If only stagesize is provided, update the default selection in new game modal
        const customSize = parseInt(urlParams.stagesize);
        if (!isNaN(customSize) && customSize > 0) {
          // Update the select dropdown to show custom size
          const sizeSelect = document.getElementById('newGameSizeSelect');
          if (sizeSelect) {
            // Add custom option if it doesn't match existing options
            const existingOption = Array.from(sizeSelect.options).find(opt => opt.value === customSize.toString());
            if (!existingOption) {
              const customOption = document.createElement('option');
              customOption.value = customSize;
              customOption.text = `${customSize}x${customSize} (Custom)`;
              customOption.selected = true;
              sizeSelect.appendChild(customOption);
            } else {
              sizeSelect.value = customSize;
            }
          }
        }
      }

      // Begin Game button
      document.getElementById('beginGameBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        newGameModal.style.display = 'block';
      });



      // Add game creation mode handling
      document.getElementById('gameCreationMode').addEventListener('change', function(e) {
        const newGameOptions = document.getElementById('newGameOptions');
        const createCanvasBtn = document.getElementById('createCanvasBtn');
        
        if (e.target.value === 'load') {
          newGameOptions.style.display = 'none';
          createCanvasBtn.textContent = 'Continue to Load';
        } else {
          newGameOptions.style.display = 'block';
          createCanvasBtn.textContent = 'Create Canvas';
        }
      });

    // Update Create Canvas button behavior
    document.getElementById('createCanvasBtn').addEventListener('click', function() {
      const creationMode = document.getElementById('gameCreationMode').value;
      const mainMenuModalElement = document.getElementById('mainMenuModal');
      
      if (creationMode === 'load') {
        // Initialize with default settings
        initGrid(75);
        newGameModal.style.display = 'none';
        if (mainMenuModalElement) mainMenuModalElement.style.display = 'none'; // Hide main menu
        mainContainer.style.display = 'flex';
        
        // Show load menu
        openSaveLoadModal();
        // Switch to load tab
        const loadTabBtn = document.querySelector('[data-tab="load"].tab-btn');
        if (loadTabBtn) {
          loadTabBtn.click();
        }
      } else {
        // Normal new game creation
        const size = parseInt(document.getElementById('newGameSizeSelect').value);
        const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
        
        initGrid(size);
        newGameModal.style.display = 'none';
        if (mainMenuModalElement) mainMenuModalElement.style.display = 'none'; // Hide main menu
        mainContainer.style.display = 'flex';
        
        if (shouldGenerateTerrain) {
          window.generateTerrain(); // Call the global function explicitly
        }
      }
    });

      // Update selected element notification
    // Direct mapping of element names to colors
    const ELEMENT_COLORS = {
      // Tools
      'eraser': '#FF0000',
      'heat': '#FF4500',
      'cool': '#1E90FF',
      'cook': '#FF8C00',
      'mix': '#9370DB',
      'move': '#FFD700',
      'sponge': '#F5F5DC',
      'extinguish': '#00BFFF',
      'grind': '#A9A9A9',
      
      // Basic Elements
      'sand': '#f4a460',
      'wall': '#666666',
      'water': '#1e7fdf',
      'salt-water': '#3aafff',
      'lava': '#ff4500',
      'stone': '#808080',
      'water-vapor': '#e0e0e0',
      'cloud': '#ffffff',
      'basalt': '#3c3c3c',
      'obsidian': '#333333',
      'molten-slag': '#ff6600',
      'copper': '#b87333',
      'steel': '#aaaaaa',
      'ice': '#cceeff',
      'wood': '#3B220E',
      'fire': '#ffcc00',
      'smoke': '#666666',
      'burning-wood': '#5a3310',
      'ash': '#444444',
      'glass': '#c2e9fb',
      'dirt': '#7B5E42',
      'wet-dirt': '#4d2e12',
      'wheat-seeds': '#bca136',
      'wheat': '#c2b280',
      'flour': '#f5f5dc',
      'dough': '#d2b48c',
      'bread': '#f4c986',
      'burning-organic': '#6a3400',
      'root': '#4a3a2f',
      'spark': '#ffdd00',
      'charged-copper': '#ff8c00',
      'charged-down-copper': '#cc6600',
      'oak-seeds': '#32CD32',
      'oak-leaves': '#228B22',
      'oak-baby-leaves': '#66bb6a',
      'oak-wood': '#8B4513',
      'dead-oak': '#5C4033',
      'burning-leaves': '#a0522d',
      'burning-root': '#ff4500',
      'dead-root': '#555555',
      'gas': 'rgba(200,200,200,0.2)',
      'burning-gas': '#ff6666',
      'acid': '#90EE90',
      'acid-steam': '#98FB98',
      'acid-cloud': '#98FB98',
      'slime': '#006400',
      'carbon-dioxide': 'rgba(128,128,128,0.2)',
      'oxygen': 'rgba(200,230,255,0.2)',
      'bird': '#B8860B',
      'meat': '#FF6B6B',
      'cooked-meat': '#8B4513',
      'cobblestone': '#808080',
      'oil': '#2F4F4F',
      'cooler': '#3399ff',
      'heater': '#ff3333',
      'heat-separator': '#ffef96',
      'charged-heat-separator': '#ffe033',
      'charged-down-heat-separator': '#ffd700',
      'input': '#646464',
      'charged-input': '#ffff77',
      'output': '#3636ff',
      'charged-output': '#8888ff',
      'not-gate': '#a15050',
      'and-gate': '#405050',
      'blocker': '#856fa8',
      'charged-blocker': '#9b50a3',
      'cloner': '#cc00cc',
      'coal': '#202020',
      'coal-lump': '#303030',
      'burning-coal': '#520f0f',
      'burning-coal-lump': '#812626',
      'thermite': '#AA4444',
      'burning-thermite': '#ffc31f',
      'bomb': '#ff0000',
      'big-bomb': '#ff3333',
      'water-bomb': '#3366ff',
      'fire-bomb': '#ff6600',
      'cryo-bomb': '#00ccff',
      'nuke-bomb': '#33cc33',
      'helium': '#e6f7ff',
      'bouncy-ball': '#ff5599',
      'cell': '#66cc99',
      'dead-cell': '#336644',
      'blood': '#cc0000',
      'glass-shard': '#e0f0ff',
      'sawdust': '#d9c29e',
      'salt': '#ffffff',
      'salt-water': '#1ea5ff',
      'grind': '#777777',
      'glue': '#e0e0a0',
      'sugar': '#ffffff',
      'sugar-water': '#e0f0ff',
      'plant': '#22aa22',
      'diamond': '#b9f2ff',
      'diamond-shards': 'rgba(185, 242, 255, 0.8)',
      'molten-diamond': '#80e0ff',
      'confetti': '#ff33ff', /* Bright consistent color */
      'dabicco': 'rgb(255,0,255)', /* Random colors handled in getTemperatureAdjustedColor */
      'oxidized-copper': '#66aa88',
      'molten-copper': '#ff8844',
      'molten-salt': '#ffddaa',
      'molten-steel': '#ff6600',
      'molten-sugar': '#ddaa88',
      'molten-glass': '#ffaa88',
      'molten-electrical': '#ff7722'
    };
    
    function updateSelectedElementNotification(toolElement) {
      try {
        // Get the tool's display name
        const toolName = toolElement.getAttribute('data-tool') || toolElement.getAttribute('title') || 'Unknown';
        let toolColor = '#FF0000'; // Default to red if we can't find a color
        
        // Try to find the element's class that matches our color map
        for (const className of toolElement.classList) {
          if (ELEMENT_COLORS[className]) {
            toolColor = ELEMENT_COLORS[className];
            break;
          }
        }
        
        // If we still don't have a color, try to find a span with color
        if (toolColor === '#FF0000') {
          const span = toolElement.querySelector('span');
          if (span) {
            const spanStyle = window.getComputedStyle(span);
            const spanColor = spanStyle.color || spanStyle.backgroundColor;
            if (spanColor && spanColor !== 'rgba(0, 0, 0, 0)' && spanColor !== 'transparent') {
              toolColor = spanColor;
            }
          }
        }
        
        // Get the notification elements
        const notification = document.getElementById('selectedElementNotification');
        const colorDisplay = document.getElementById('selectedElementColor');
        const nameDisplay = document.getElementById('selectedElementName');
        
        // Only proceed if all required elements exist
        if (!notification || !colorDisplay || !nameDisplay) {
          console.warn('Notification elements not found');
          return;
        }
        
        // Add a subtle animation class for the color swatch
        colorDisplay.style.animation = 'pulse 0.5s ease-in-out';
        
        // Remove the animation after it completes
        colorDisplay.addEventListener('animationend', function() {
          colorDisplay.style.animation = '';
        }, { once: true });
        
        // Update the color and text
        colorDisplay.style.backgroundColor = toolColor;
        nameDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
        
        // Show the notification with animation
        notification.classList.remove('visible');
        // Force reflow
        void notification.offsetWidth;
        notification.classList.add('visible');
        
        // Hide after 3 seconds
        clearTimeout(notification.timeoutId);
        notification.timeoutId = setTimeout(() => {
          notification.classList.remove('visible');
        }, 3000);
      } catch (error) {
        console.error('Error updating element notification:', error);
      }
    }
    
      // Function to handle tool clicks
    function handleToolClick() {
      updateSelectedElementNotification(this);
    }
    
    // Add click handlers to all tool elements
    function initializeToolClickHandlers() {
      const tools = document.querySelectorAll('.tool');
      console.log('Initializing click handlers for', tools.length, 'tools');
      
      tools.forEach(tool => {
        // Remove any existing click handlers to prevent duplicates
        tool.removeEventListener('click', handleToolClick);
        tool.addEventListener('click', handleToolClick);
      });
    }
    
    // Initialize tool click handlers when the DOM is fully loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeToolClickHandlers);
    } else {
      // DOM already loaded, initialize immediately
      setTimeout(initializeToolClickHandlers, 100);
    }
    
    // Re-initialize tool click handlers after loading a game or creating a new one
    const originalInitGrid = window.initGrid;
    if (originalInitGrid) {
      window.initGrid = function(size) {
        const result = originalInitGrid.call(this, size);
        // Small delay to ensure tools are created
        setTimeout(initializeToolClickHandlers, 100);
        return result;
      };
    }

      // Close buttons for modals
      document.getElementById('closeNewGameModal').addEventListener('click', function() {
        newGameModal.style.display = 'none';
        mainMenuModal.style.display = 'block';
      });

      // When closing save/load or mods menu, return to main menu if game hasn't started
      const closeModMenu = document.getElementById('closeModMenu');
      const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');

      // Variated Colors setting in Options menu
      const variatedColorsToggle = document.getElementById('variatedColorsToggle');
      const applyVariatedColors = document.getElementById('applyVariatedColors');
      
      // DSPLE setting in Options menu
      const dspleToggle = document.getElementById('dspleToggle');
      const applyDsple = document.getElementById('applyDsple');
      
      // Initialize toggles based on current settings
      variatedColorsToggle.value = window.isVariatedColorsEnabled ? '1' : '0';
      dspleToggle.value = window.isDspleEnabled ? '1' : '0';
      
      // Apply Variated Colors setting
      applyVariatedColors.addEventListener('click', function() {
        const newVariatedColorsSetting = variatedColorsToggle.value === '1';
        
        // If setting changed from disabled to enabled, reassign all color variations
        if (!window.isVariatedColorsEnabled && newVariatedColorsSetting) {
          reassignColorVariations();
        }
        
        // Update the setting
        window.isVariatedColorsEnabled = newVariatedColorsSetting;
        
        // Re-render the grid to apply changes
        renderGrid();
      });
      
      // Apply DSPLE setting
      applyDsple.addEventListener('click', function() {
        const newDspleSetting = dspleToggle.value === '1';
        
        // Update the setting
        window.isDspleEnabled = newDspleSetting;
        
        if (newDspleSetting) {
          // Initialize the lighting engine if enabling
          initDspleLightingEngine();
        } else {
          // Clean up lighting effects if disabling
          cleanupDspleLightingEngine();
        }
        
        // Re-render the grid to apply changes
        renderGrid();
      });
      
      closeModMenu.addEventListener('click', function() {
        modMenu.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      closeSaveLoadModal.addEventListener('click', function() {
        saveLoadModal.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      // Window click handlers
      window.addEventListener('click', function(event) {
        if (event.target === newGameModal) {
          newGameModal.style.display = 'none';
          mainMenuModal.style.display = 'block';
        }
        if (event.target === saveLoadModal) {
          saveLoadModal.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
        if (event.target === modMenu) {
          modMenu.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
      });
      
      // Mobile menu functionality
      // Wait for the DOM to be fully loaded
      window.addEventListener('load', function() {
        // Check if mobile
        const isMobile = window.matchMedia('(max-width: 1024px)').matches;
        
        // Get mobile menu elements
        const mobileMenuButton = document.getElementById('mobileMenuButton');
        const mobileSideMenu = document.getElementById('mobileSideMenu');
        const mobileSideMenuOverlay = document.getElementById('mobileSideMenuOverlay');
        const mobileMenuCloseBtn = document.getElementById('mobileMenuCloseBtn');
        
        if (isMobile) {
          // Show mobile menu button on mobile devices
          mobileMenuButton.style.display = 'block';
          
          // Ensure HUD is hidden on mobile
          const hud = document.getElementById('hud');
          if (hud) hud.style.display = 'none';
          
          // Add top margin to grid to avoid menu button overlap
          const grid = document.getElementById('grid');
          if (grid) grid.style.marginTop = '35px';
          
          // Mobile speed slider
          const mobileSpeed = document.getElementById('mobileSpeed');
          const mobileSpeedValue = document.getElementById('mobileSpeedValue');
          
          // Mobile buttons
          const mobileClearAllBtn = document.getElementById('mobileClearAllBtn');
          const mobileOptionsButton = document.getElementById('mobileOptionsButton');
          const mobileSaveLoadButton = document.getElementById('mobileSaveLoadButton');
          const mobileModButton = document.getElementById('mobileModButton');
          
          // Open mobile menu
          mobileMenuButton.addEventListener('click', function() {
            console.log('Mobile menu button clicked');
            mobileSideMenu.style.display = 'block';
            mobileSideMenu.classList.add('open');
            mobileSideMenuOverlay.style.display = 'block';
            mobileSideMenuOverlay.classList.add('open');
          });
          
          // Close mobile menu
          mobileMenuCloseBtn.addEventListener('click', function() {
            mobileSideMenu.classList.remove('open');
            mobileSideMenuOverlay.classList.remove('open');
            setTimeout(function() {
              mobileSideMenu.style.display = 'none';
              mobileSideMenuOverlay.style.display = 'none';
            }, 300); // Match transition duration
          });
          
          // Close when clicking overlay
          mobileSideMenuOverlay.addEventListener('click', function() {
            mobileSideMenu.classList.remove('open');
            mobileSideMenuOverlay.classList.remove('open');
            setTimeout(function() {
              mobileSideMenu.style.display = 'none';
              mobileSideMenuOverlay.style.display = 'none';
            }, 300); // Match transition duration
          });
          
          // Mobile speed slider
          mobileSpeed.addEventListener('input', function() {
            const value = parseFloat(this.value);
            mobileSpeedValue.textContent = value.toFixed(2);
            // Sync with main speed slider
            window.speed = value;
            // Update main slider if it exists
            const mainSpeedSlider = document.getElementById('speed');
            if (mainSpeedSlider) mainSpeedSlider.value = value;
          });
          
          // Mobile clear all button
          mobileClearAllBtn.addEventListener('click', function() {
            const mainClearAllBtn = document.getElementById('clearAllBtn');
            if (mainClearAllBtn) mainClearAllBtn.click();
            mobileSideMenu.classList.remove('open');
            mobileSideMenuOverlay.classList.remove('open');
            setTimeout(function() {
              mobileSideMenu.style.display = 'none';
              mobileSideMenuOverlay.style.display = 'none';
            }, 300);
          });
          
          // Mobile options button
          mobileOptionsButton.addEventListener('click', function() {
            const mainOptionsButton = document.getElementById('optionsButton');
            if (mainOptionsButton) mainOptionsButton.click();
            mobileSideMenu.classList.remove('open');
            mobileSideMenuOverlay.classList.remove('open');
            setTimeout(function() {
              mobileSideMenu.style.display = 'none';
              mobileSideMenuOverlay.style.display = 'none';
            }, 300);
          });
          
          // Mobile save/load button
          mobileSaveLoadButton.addEventListener('click', function() {
            const mainSaveLoadButton = document.getElementById('saveLoadButton');
            if (mainSaveLoadButton) mainSaveLoadButton.click();
            mobileSideMenu.classList.remove('open');
            mobileSideMenuOverlay.classList.remove('open');
            setTimeout(function() {
              mobileSideMenu.style.display = 'none';
              mobileSideMenuOverlay.style.display = 'none';
            }, 300);
          });
          
          // Mobile mod button
          mobileModButton.addEventListener('click', function() {
            const mainModButton = document.getElementById('modButton');
            if (mainModButton) mainModButton.click();
            mobileSideMenu.classList.remove('open');
            mobileSideMenuOverlay.classList.remove('open');
            setTimeout(function() {
              mobileSideMenu.style.display = 'none';
              mobileSideMenuOverlay.style.display = 'none';
            }, 300);
          });
          
          // Sync initial speed value
          const mainSpeedSlider = document.getElementById('speed');
          if (mainSpeedSlider) {
            mobileSpeed.value = mainSpeedSlider.value;
            mobileSpeedValue.textContent = parseFloat(mainSpeedSlider.value).toFixed(2);
          }
          
          console.log('Mobile menu initialized');
        } else {
          // Hide mobile elements in desktop mode
          if (mobileMenuButton) mobileMenuButton.style.display = 'none';
          if (mobileSideMenu) mobileSideMenu.style.display = 'none';
          if (mobileSideMenuOverlay) mobileSideMenuOverlay.style.display = 'none';
        }
      });
    });
  </script>

  <!-- Mobile menu button (only visible on mobile) -->
  <button id="mobileMenuButton" style="display: none;">â‰¡ Menu</button>
  
  <!-- Mobile side menu (only visible on mobile) -->
  <div id="mobileSideMenuOverlay" style="display: none;"></div>
  <div id="mobileSideMenu" style="display: none;">
    <div class="menu-header">
      <div class="menu-title">Game Menu</div>
      <button id="mobileMenuCloseBtn">Ã—</button>
    </div>
    
    <div id="mobileSpeedContainer">
      <label for="mobileSpeed">Simulation Speed:</label>
      <input type="range" id="mobileSpeed" min="0" max="5" step="0.01" value="1"/>
      <span id="mobileSpeedValue">1</span>Ã—
    </div>
    
    <button id="mobileClearAllBtn" class="mobile-menu-button">Clear All</button>
    <button id="mobileOptionsButton" class="mobile-menu-button">Options</button>
    <button id="mobileSaveLoadButton" class="mobile-menu-button">Save/Load</button>
    <button id="mobileModButton" class="mobile-menu-button">Mods</button>
  </div>

  <div id="mainContainer">
    <!-- The simulation grid (will be rebuilt based on stage size) -->
    <div id="grid">
      <!-- Hover overlay element -->
      <div id="hoverOverlay"></div>
    </div>
    <!-- Side panel -->
    <div id="sidePanel">
      <!-- Side content: two columns (element list and category menu) -->
      <div id="sideContent">
        <!-- Element list scroll area -->
        <div id="elementScroll">
          <div id="toolSearchContainer">
            <input type="text" id="toolSearch" placeholder="Search...">
            <select id="sortOrder" style="margin-left: 10px;">
              <option value="natural">Natural</option>
              <option value="alpha">A-Z</option>
              <option value="type">By Type</option>
            </select>
          </div>
          <!-- Custom Elements Interface -->
          <div id="customElementsInterface">
            <div class="custom-element-warning">
              âš ï¸ Custom elements are experimental! Saves with custom elements cannot be shared or exported.
            </div>
            
            <div class="custom-elements-header">
              <h3>ðŸŽ¨ Custom Elements</h3>
            </div>
            
            <div class="custom-elements-list" id="customElementsList">
              <!-- Custom elements will be populated here -->
              <div class="custom-element-item create-new" id="createNewCustomElement">
                <div class="create-new-icon">+</div>
                <div class="custom-element-name">Create New</div>
              </div>
            </div>
            
            <!-- Custom Element Creator -->
            <div class="custom-element-creator" id="customElementCreator">
              <div class="creator-header">
                <h3>ðŸ› ï¸ Element Creator</h3>
              </div>
              
              <div class="creator-color-name">
                <div class="color-input-container">
                  <label>Color</label>
                  <input type="color" id="customElementColor" class="creator-color-input" value="#ff6b6b">
                </div>
                <div class="name-input-container">
                  <label>Name (max 8 chars)</label>
                  <input type="text" id="customElementName" class="creator-name-input" placeholder="Element" maxlength="8">
                </div>
              </div>
              
              <div class="creator-properties">
                <!-- Basic Properties -->
                <div class="property-group">
                  <h4>âš—ï¸ Basic Properties</h4>
                  <div class="property-item">
                    <label>Element Type <span class="desc">How the element moves and behaves physically</span></label>
                    <select id="customElementType">
                      <option value="solid">Solid (doesn't move, rigid structure)</option>
                      <option value="liquid">Liquid (flows, settles at bottom)</option>
                      <option value="powder">Powder (falls like sand, piles up)</option>
                      <option value="gas">Gas (floats upward, spreads)</option>
                    </select>
                  </div>
                  <div class="property-item">
                    <label>Density <span class="range-value" id="densityValue">1.0</span> <span class="desc">How heavy it is - dramatically affects layering and interactions</span></label>
                    <input type="range" id="customElementDensity" min="0.1" max="5.0" step="0.1" value="1.0">
                    <small>0.1=helium-like (floats), 1.0=water-like, 2.0=heavy (sinks through most liquids)</small>
                  </div>
                  <div class="property-item">
                    <label>Viscosity <span class="range-value" id="viscosityValue">1.0</span> <span class="desc">How thick/sticky liquids are - dramatically affects flow speed</span></label>
                    <input type="range" id="customElementViscosity" min="0.0" max="2.0" step="0.1" value="1.0">
                    <small>0.0=water-like (fast flow), 1.0=slow flow, 2.0=barely moves (tar-like)</small>
                  </div>
                </div>
                
                <!-- Thermal Properties -->
                <div class="property-group">
                  <h4>ðŸŒ¡ï¸ Thermal Properties</h4>
                  <div class="property-item">
                    <label>Melting Point (Â°C) <span class="range-value" id="meltingPointValue">1000</span> <span class="desc">Temperature at which solids become liquids</span></label>
                    <input type="range" id="customElementMeltingPoint" min="-50" max="2000" step="10" value="1000">
                    <small>Ice melts at 0Â°C, wood burns at 200Â°C, iron melts at 1538Â°C</small>
                  </div>
                  <div class="property-item">
                    <label>Boiling Point (Â°C) <span class="range-value" id="boilingPointValue">1500</span> <span class="desc">Temperature at which liquids become gas</span></label>
                    <input type="range" id="customElementBoilingPoint" min="0" max="3000" step="10" value="1500">
                    <small>Water boils at 100Â°C, alcohol at 78Â°C, mercury at 357Â°C</small>
                  </div>
                  <div class="property-item">
                    <label>Heat Conductivity <span class="range-value" id="conductivityValue">0.5</span> <span class="desc">How quickly heat spreads through this element</span></label>
                    <input type="range" id="customElementConductivity" min="0.0" max="2.0" step="0.1" value="0.5">
                    <small>0.0=insulator, 1.0=normal, 2.0=excellent conductor</small>
                  </div>
                  <div class="property-item">
                    <label>Heat Capacity <span class="range-value" id="heatCapacityValue">1.0</span> <span class="desc">How much energy needed to change temperature</span></label>
                    <input type="range" id="customElementHeatCapacity" min="0.1" max="5.0" step="0.1" value="1.0">
                    <small>0.1=heats up quickly, 5.0=takes lots of energy to heat</small>
                  </div>
                </div>
                
                <!-- Fire Properties -->
                <div class="property-group">
                  <h4>ðŸ”¥ Fire Properties</h4>
                  <div class="property-item">
                    <label>Flammable <span class="desc">Can this element catch fire and burn?</span></label>
                    <select id="customElementFlammable">
                      <option value="false">No (fireproof)</option>
                      <option value="true">Yes (combustible)</option>
                    </select>
                  </div>
                  <div class="property-item" id="ignitionTempContainer">
                    <label>Ignition Temperature (Â°C) <span class="range-value" id="ignitionTempValue">300</span> <span class="desc">How hot before it catches fire</span></label>
                    <input type="range" id="customElementIgnitionTemp" min="50" max="1000" step="10" value="300">
                    <small>Paper: ~230Â°C, Wood: ~300Â°C, Gasoline: ~280Â°C</small>
                  </div>
                  <div class="property-item" id="fireResistanceContainer">
                    <label>Fire Resistance <span class="range-value" id="fireResistanceValue">0.0</span> <span class="desc">Chance to resist ignition from direct fire contact</span></label>
                    <input type="range" id="customElementFireResistance" min="0.0" max="0.9" step="0.1" value="0.0">
                    <small>0.0=ignites immediately, 0.9=very fire resistant</small>
                  </div>
                </div>
                
                <!-- Explosion Properties -->
                <div class="property-group">
                  <h4>ðŸ’¥ Explosion Properties</h4>
                  <div class="property-item">
                    <label>Explosive <span class="desc">Can this element explode?</span></label>
                    <select id="customElementExplosive">
                      <option value="false">No (stable)</option>
                      <option value="true">Yes (explosive)</option>
                    </select>
                  </div>
                  <div class="property-item" id="explosionTempContainer">
                    <label>Explosion Temperature (Â°C) <span class="range-value" id="explosionTempValue">200</span> <span class="desc">How hot before it explodes</span></label>
                    <input type="range" id="customElementExplosionTemp" min="50" max="1000" step="10" value="200">
                    <small>Most explosives detonate around 200-400Â°C</small>
                  </div>
                  <div class="property-item" id="explosionRadiusContainer">
                    <label>Explosion Radius <span class="range-value" id="explosionRadiusValue">3</span> <span class="desc">How big the explosion is</span></label>
                    <input type="range" id="customElementExplosionRadius" min="1" max="10" step="1" value="3">
                    <small>1=small pop, 5=medium blast, 10=huge explosion</small>
                  </div>
                  <div class="property-item" id="explosionPowerContainer">
                    <label>Destruction Power <span class="range-value" id="explosionPowerValue">0.4</span> <span class="desc">Chance to destroy nearby elements</span></label>
                    <input type="range" id="customElementExplosionPower" min="0.1" max="0.8" step="0.1" value="0.4">
                    <small>0.1=gentle, 0.4=moderate, 0.8=devastating</small>
                  </div>
                  <div class="property-item" id="explosionTypeContainer">
                    <label>Explosion Type <span class="desc">What the explosion creates</span></label>
                    <select id="customElementExplosionType">
                      <option value="fire">Fire (creates flames)</option>
                      <option value="water">Water (creates water splash)</option>
                      <option value="ice">Ice (creates freezing blast)</option>
                      <option value="lava">Lava (creates molten rock)</option>
                    </select>
                  </div>
                </div>
                
                <!-- Special Properties -->
                <div class="property-group">
                  <h4>âš¡ Electrical Properties</h4>
                  <div class="property-item">
                    <label>Conducts Electricity <span class="desc">Can electrical current pass through this?</span></label>
                    <select id="customElementConductive">
                      <option value="false">No (insulator)</option>
                      <option value="true">Yes (conductor)</option>
                    </select>
                  </div>
                </div>
                
                <!-- Interaction Properties -->
                <div class="property-group">
                  <h4>ðŸ”— Interaction Properties</h4>

                  <div class="property-item">
                    <label>Reacts with Fire <span class="desc">Special reaction when touching fire</span></label>
                    <select id="customElementFireReactive">
                      <option value="false">No reaction</option>
                      <option value="true">Reacts (changes when touching fire)</option>
                    </select>
                  </div>
                  <div class="property-item">
                    <label>Corrodes Metal <span class="desc">Destroys metal it touches (like acid)</span></label>
                    <select id="customElementCorrosive">
                      <option value="false">No (safe)</option>
                      <option value="true">Yes (corrosive)</option>
                    </select>
                  </div>
                </div>
                
                <!-- Reaction System -->
                <div class="property-group">
                  <h4>âš›ï¸ Element Reactions</h4>
                  <div class="property-item">
                    <label>Custom Reactions <span class="desc">Define what happens when this element touches other elements</span></label>
                    <div id="reactions-list" style="margin-top: 10px;"></div>
                    <button type="button" id="add-reaction-btn" style="margin-top: 10px; padding: 5px 10px; background: #4a7c59; color: white; border: none; border-radius: 3px; cursor: pointer;">Add Reaction</button>
                  </div>
                </div>
              </div>
              
              <div class="creator-actions">
                <button class="creator-btn" id="cancelCustomElement">Cancel</button>
                <button class="creator-btn" id="previewCustomElement">Preview</button>
                <button class="creator-btn primary" id="saveCustomElement">Create Element</button>
              </div>
            </div>
          </div>
          
          <div id="toolbar">
            <!-- Tools Section -->
            <div class="tool eraser" data-tool="eraser" data-cat="tools" title="Eraser"><span>Eraser</span></div>
            <div class="tool move" data-tool="move" data-cat="tools" title="Move Tool"><span>Move</span></div>
            <div class="tool heat" data-tool="heat" data-cat="tools" title="Heat Tool"><span>Heat</span></div>
            <div class="tool cool" data-tool="cool" data-cat="tools" title="Cool Tool"><span>Cool</span></div>
            <div class="tool cook" data-tool="cook" data-cat="tools" title="Cook Tool"><span>Cook</span></div>
            <div class="tool mix" data-tool="mix" data-cat="tools" title="Mix Tool"><span>Mix</span></div>
            <div class="tool sponge" data-tool="sponge" data-cat="tools" title="Sponge Tool"><span>Sponge</span></div>
            <div class="tool extinguish" data-tool="extinguish" data-cat="tools" title="Extinguish Tool"><span>Ext</span></div>
            <div class="tool grind" data-tool="grind" data-cat="tools" title="Grind Tool"><span>Grind</span></div>
            
            <!-- Basic Elements -->
            <div class="tool sand selected" data-tool="sand" data-cat="powders" title="Sand"><span>S</span></div>
            <div class="tool water" data-tool="water" data-cat="liquids" title="Water"><span>W</span></div>
            <div class="tool snow" data-tool="snow" data-cat="powders" title="Snow - Falls slowly, melts into water when heated"><span>Sn</span></div>
            <div class="tool wall" data-tool="wall" data-cat="solids" title="Wall"><span>Wall</span></div>
            <div class="tool stone" data-tool="stone" data-cat="solids" title="Stone"><span>St</span></div>
            <div class="tool lava" data-tool="lava" data-cat="liquids" title="Lava"><span>Lv</span></div>
            <div class="tool ice" data-tool="ice" data-cat="solids" title="Ice"><span>I</span></div>
            <div class="tool water-vapor" data-tool="water-vapor" data-cat="gasses" title="Water Vapor"><span>V</span></div>
            <div class="tool cloud" data-tool="cloud" data-cat="gasses" title="Cloud - Forms from water vapor"><span>Cld</span></div>
            <div class="tool dense-cloud" data-tool="dense-cloud" data-cat="gasses" title="Dense cloudLife"><span>DCld</span></div>
            
            <!-- Dirt & Related -->
            <div class="tool dirt" data-tool="dirt" data-cat="powders" title="Dirt"><span>Di</span></div>
            <div class="tool wet-dirt" data-tool="wet-dirt" data-cat="powders" title="Wet Dirt"><span>WDi</span></div>
            <div class="tool grass" data-tool="grass" data-cat="life" title="Grass"><span>Gr</span></div>
            
            <!-- Fire & Combustion -->
            <div class="tool fire" data-tool="fire" data-cat="gasses" title="Fire"><span>F</span></div>
            <div class="tool smoke" data-tool="smoke" data-cat="gasses" title="Smoke"><span>Sm</span></div>
            <div class="tool ash" data-tool="ash" data-cat="powders" title="Ash"><span>A</span></div>
            
            <!-- Wood & Related -->
            <div class="tool wood" data-tool="wood" data-cat="solids" title="Wood"><span>Wd</span></div>
            <div class="tool sawdust" data-tool="sawdust" data-cat="powders" title="Sawdust"><span>SDust</span></div>
            
            <!-- Glass & Related -->
            <div class="tool glass" data-tool="glass" data-cat="solids" title="Glass"><span>G</span></div>
            <div class="tool glass-shard" data-tool="glass-shard" data-cat="powders" title="Glass Shard"><span>GSh</span></div>
            
            <!-- Cooking -->
            <div class="tool wheat-seeds" data-tool="wheat-seeds" data-cat="life" title="Wheat Seeds"><span>WSeeds</span></div>
            <div class="tool flour" data-tool="flour" data-cat="powders,cooking" title="Flour"><span>Flr</span></div>
            <div class="tool dough" data-tool="dough" data-cat="cooking" title="Dough"><span>Dh</span></div>
            <div class="tool bread" data-tool="bread" data-cat="cooking" title="Bread"><span>Br</span></div>
            <div class="tool meat" data-tool="meat" data-cat="cooking" title="Meat"><span>Meat</span></div>
            <div class="tool cooked-meat" data-tool="cooked-meat" data-cat="cooking" title="Cooked Meat"><span>CMeat</span></div>
            
            <!-- Plant Life -->
            <div class="tool plant-root" data-tool="plant-root" data-cat="life" title="Plant Roots"><span>PR</span></div>
            <div class="tool oak-seeds" data-tool="oak-seeds" data-cat="life" title="Oak Tree Seeds"><span>OakS</span></div>
            <div class="tool birch-seeds" data-tool="birch-seeds" data-cat="life" title="Birch Tree Seeds"><span>BirchS</span></div>
            
            <!-- Electricity -->
            <div class="tool copper" data-tool="copper" data-cat="electricity" title="Copper"><span>Cu</span></div>
            <div class="tool oxidized-copper" data-tool="oxidized-copper" data-cat="electricity" title="Oxidized Copper"><span>OCu</span></div>
            <div class="tool spark" data-tool="spark" data-cat="electricity" title="Spark"><span>Sp</span></div>
            <div class="tool cooler" data-tool="cooler" data-cat="electricity" title="Cooler"><span>CL</span></div>
            <div class="tool heater" data-tool="heater" data-cat="electricity" title="Heater"><span>HT</span></div>
            <div class="tool heat-separator" data-tool="heat-separator" data-cat="electricity" title="Heat Separator"><span>HS</span></div>
            <div class="tool input" data-tool="input" data-cat="electricity" title="Input"><span>In</span></div>
            <div class="tool output" data-tool="output" data-cat="electricity" title="Output"><span>Out</span></div>
            <div class="tool cloner" data-tool="cloner" data-cat="special,electricity" title="Cloner"><span>Cloner</span></div>
            
            <!-- Liquids -->
            <div class="tool oil" data-tool="oil" data-cat="liquids" title="Oil"><span>Oil</span></div>
            <div class="tool acid" data-tool="acid" data-cat="liquids" title="Acid"><span>Ac</span></div>
            <div class="tool slime" data-tool="slime" data-cat="liquids" title="Slime"><span>Slime</span></div>
            <div class="tool blood" data-tool="blood" data-cat="liquids" title="Blood"><span>Blood</span></div>
            <div class="tool salt-water" data-tool="salt-water" data-cat="liquids" title="Salt Water"><span>SaltW</span></div>
            <div class="tool glue" data-tool="glue" data-cat="liquids" title="Glue"><span>Glue</span></div>
            <div class="tool sugar-water" data-tool="sugar-water" data-cat="liquids" title="Sugar Water"><span>SugarW</span></div>
            
            <!-- Gasses -->
            <div class="tool gas" data-tool="gas" data-cat="gasses" title="Gas"><span>Gas</span></div>
            <div class="tool oxygen" data-tool="oxygen" data-cat="gasses" title="Oxygen"><span>O2</span></div>
            <div class="tool carbon-dioxide" data-tool="carbon-dioxide" data-cat="gasses" title="Carbon Dioxide"><span>CO2</span></div>
            <div class="tool helium" data-tool="helium" data-cat="gasses" title="Helium"><span>He</span></div>
            
            <!-- Explosives -->
            <div class="tool bomb" data-tool="bomb" data-cat="explosives" title="Bomb"><span>B</span></div>
            <div class="tool big-bomb" data-tool="big-bomb" data-cat="explosives" title="Big Bomb"><span>GB</span></div>
            <div class="tool water-bomb" data-tool="water-bomb" data-cat="explosives" title="Water Bomb"><span>WB</span></div>
            <div class="tool nuke-bomb" data-tool="nuke-bomb" data-cat="explosives" title="Nuke Bomb"><span>Nuke</span></div>
            <div class="tool thermite" data-tool="thermite" data-cat="powders,explosives" title="Thermite"><span>Th</span></div>
            
            <!-- Metals -->
            <div class="tool steel" data-tool="steel" data-cat="solids" title="Steel"><span>Fe</span></div>
            
            <!-- Diamonds & Gems -->
            <div class="tool diamond" data-tool="diamond" data-cat="solids" title="Diamond"><span>Dia</span></div>
            <div class="tool diamond-shards" data-tool="diamond-shards" data-cat="powders" title="Diamond Shards"><span>DSh</span></div>
            
            <!-- Fun Stuff -->
            <div class="tool confetti" data-tool="confetti" data-cat="powders" title="Confetti"><span>Conf</span></div>
            <div class="tool dabicco" data-tool="dabicco" data-cat="special" title="Dabicco"><span>Dab</span></div>
            
            <!-- Coal & Related -->
            <div class="tool coal" data-tool="coal" data-cat="solids" title="Coal"><span>Coal</span></div>
            <div class="tool coal-lump" data-tool="coal-lump" data-cat="solids" title="Coal Lump"><span>CLump</span></div>
            
            <!-- Rocks & Minerals -->
            <div class="tool cobblestone" data-tool="cobblestone" data-cat="powders" title="Cobblestone"><span>Cbl</span></div>
            <div class="tool salt" data-tool="salt" data-cat="powders" title="Salt"><span>Salt</span></div>
            <div class="tool sugar" data-tool="sugar" data-cat="powders" title="Sugar"><span>Sugar</span></div>
            <div class="tool diamond-shards" data-tool="diamond-shards" data-cat="powders" title="Diamond Shards"><span>DSh</span></div>
            
            <!-- Life Forms -->
            <div class="tool bird" data-tool="bird" data-cat="life" title="Bird"><span>Bird</span></div>
            <div class="tool cell" data-tool="cell" data-cat="life" title="Cell"><span>Cell</span></div>
            <div class="tool plant" data-tool="plant" data-cat="life" title="Plant"><span>Plant</span></div>
            
            <!-- Special -->
            <div class="tool bouncy-ball" data-tool="bouncy-ball" data-cat="special" title="Bouncy Ball"><span>BB</span></div>
            
            <!-- New Physics Elements -->
            <div class="tool insulator" data-tool="insulator" data-cat="solids" title="Insulator"><span>Insul</span></div>
            <div class="tool photon" data-tool="photon" data-cat="special" title="Photon"><span>Photon</span></div>
            <div class="tool lightning" data-tool="lightning" data-cat="explosives" title="Lightning"><span>Lgtn</span></div>
          </div>
        </div>
        <!-- Category menu (independent scroll area on the right) -->
        <div id="categoryMenu">
          <button data-category="all" class="selectedCat">All</button>
          <button data-category="tools">Tools</button>
          <button data-category="liquids">Liquids</button>
          <button data-category="powders">Powders</button>
          <button data-category="solids">Solids</button>
          <button data-category="gasses">Gasses</button>
          <button data-category="explosives">Explosives</button>
          <button data-category="life">Life</button>
          <button data-category="cooking">Cooking</button>
          <button data-category="electricity">Electricity Beta</button>
          <button data-category="special">Special</button>
          <button data-category="custom">Custom</button>
        </div>
      </div>
      <!-- HUD (not scrollable) -->
      <div id="hud">
        <div id="hudTemp">Temp: -- Â°C</div>
        <div id="hudElem">Element: --</div>
        <div id="hudFPS">FPS: --</div>
      </div>
      <!-- Bottom controls (not scrollable) -->
      <div id="bottomControls">
        <div id="speedContainer">
          <label for="speed">Simulation Speed:</label>
          <input type="range" id="speed" min="0" max="5" step="0.01" value="1"/>
          <span id="speedValue">1</span>Ã—
        </div>
        <button id="clearAllBtn">Clear All</button>
      </div>
      <!-- Extra Sidebar Buttons -->
      <div id="optionsButtonContainer">
        <button id="optionsButton">Options</button>
      </div>
      <div id="saveLoadButtonContainer">
        <button id="saveLoadButton">Save/Load</button>
      </div>

      <div id="modButtonContainer">
        <button id="modButton">Mods</button>
      </div>
    </div>
  </div>

  <script>
    /***************************************************************
     * The Entire Game Script; Made By Dabicco (Compiled in Dabicco Engine). DO NOT COPY!!
     ***************************************************************/


    // Stage size is dynamic; default is 50.
    let GRID_SIZE = 75;

    // Initialize variables that are used before their declarations elsewhere
    // These were moved from later in the code to prevent 'before initialization' errors
    let dirtyGrid = [];
    let lastFrameTime = 0;
    // Reusable arrays for shuffling positions - moved from later in the code
    const reusablePositions = [];
    const reusableXPositions = [];
    // Tool constants
    const TOOL_HEAT         = 100;
    const TOOL_COOL         = 101;
    const TOOL_COOK         = 102;
    const TOOL_MIX          = 103;
    const TOOL_MOVE         = 104;
    const TOOL_SPONGE       = 105;
    const TOOL_EXTINGUISH   = 106;
    const TOOL_GRIND        = 107;

    const EMPTY             = 0;
    const ERASER            = 5;
    // Basic elements
    const SAND              = 1;
    const WALL              = 44;
    const WATER             = 2;
    const SNOW              = 221;
    const LAVA              = 3;
    const STONE             = 4;
    const WATER_VAPOR       = 6;
    const CLOUD             = 7;
    const BASALT            = 8;
    const OBSIDIAN          = 9;
    const MOLTEN_SLAG       = 10;
    const COPPER            = 11;
    const STEEL             = 12;
    const ICE               = 13;
    const WOOD              = 14;
    const FIRE              = 15;
    const SMOKE             = 16;
    const BURNING_WOOD      = 17;
    const ASH               = 18;
    const GLASS             = 19;
    const BOMB              = 20;
    // Additional
    const DIRT              = 21;
    const WET_DIRT          = 22;
    const WHEAT_SEEDS       = 23;
    const WHEAT             = 24;
    const FLOUR             = 25;
    const DOUGH             = 26;
    const BREAD             = 27;
    const ROOT              = 28;
    const BURNING_ORGANIC   = 29;
    const SPARK             = 30;
    const CHARGED_COPPER    = 31;
    const OAK_SEEDS         = 32;
    const OAK_LEAVES        = 33;
    const OAK_BABY_LEAVES   = 34;
    const DEAD_OAK          = 35;
    const WET_SAND          = 36;
    const GRASS             = 37;
    const DEAD_PLANT        = 38;
    const BURNING_LEAVES    = 39;
    const BURNING_ROOT      = 40;
    const DEAD_ROOT         = 41;
    const GAS               = 42;
    const BURNING_GAS       = 43;
    const CHARGED_DOWN_COPPER = 45;
    // COOLER & HEATER
    const COOLER            = 46;
    const HEATER            = 47;
    // Electric elements
    const HEAT_SEPARATOR                = 48;
    const CHARGED_HEAT_SEPARATOR        = 49;
    const CHARGED_DOWN_HEAT_SEPARATOR   = 50;
    const INPUT                         = 51;
    const CHARGED_INPUT                 = 52;
    const OUTPUT                        = 53;
    const CHARGED_OUTPUT                = 54;
    const NOT_GATE                      = 55;
    const AND_GATE                      = 56;
    const BLOCKER                       = 57;
    const CHARGED_BLOCKER               = 61;
    // Cloner
    const CLONER                        = 60;
    // New elements: Coal and Coal Lump
    const COAL              = 62;
    const COAL_LUMP         = 63;
    const BURNING_COAL      = 64;
    const BURNING_COAL_LUMP = 65;
    // New element: Thermite â€“ assign THERMITE and BURNING_THERMITE (ensure no conflict with mod Orange Juice)
    const THERMITE          = 68;
    const BURNING_THERMITE  = 69;
    // New elements
    const ACID              = 70;
    const ACID_STEAM        = 71;
    const ACID_CLOUD        = 72;
    const SLIME             = 73;
    // Additional new elements
    const CARBON_DIOXIDE    = 74;
    const OXYGEN            = 75;
    const BIRD             = 76;
    const MEAT             = 77;
    const COOKED_MEAT      = 78;
    const COBBLESTONE      = 79;
    const OIL              = 80;
    const BIG_BOMB         = 81;
    const WATER_BOMB       = 82;
    const FIRE_BOMB        = 83;
    const CRYO_BOMB        = 84;
    const NUKE_BOMB        = 85;
    const HELIUM           = 86;
    const BOUNCY_BALL      = 87;
    const BIRCH_SEEDS      = 88;
    const BIRCH_LEAVES     = 89;
    const BIRCH_BABY_LEAVES= 90;
    const BIRCH_WOOD       = 91;
    const DEAD_BIRCH       = 92;
    // New elements
    const CELL              = 93;
    const DEAD_CELL         = 94;
    const BLOOD             = 95;
    const GLASS_SHARD       = 96;
    const SAWDUST           = 97;
    // New elements: Salt and Salt Water
    const SALT             = 98;
    const SALT_WATER       = 99;
    // New elements: Glue, Sugar, Sugar Water, Plant, Diamond, etc.
    const GLUE             = 200;
    const SUGAR            = 201;
    const SUGAR_WATER      = 202;
    const PLANT            = 203;
    const DIAMOND          = 204;
    const DIAMOND_SHARDS   = 205;
    const MOLTEN_DIAMOND   = 206;
    const CONFETTI         = 207;
    const DABICCO          = 208;
    const OXIDIZED_COPPER  = 209;
    const MOLTEN_COPPER    = 210;
    const MOLTEN_SALT      = 211;
    const MOLTEN_STEEL     = 212;
    const MOLTEN_SUGAR     = 213;
    const MOLTEN_GLASS     = 214;
    const MOLTEN_ELECTRICAL = 215; // For electrical components
    // New physics elements
    const INSULATOR        = 216;
    const PHOTON           = 217;
    const LIGHTNING        = 218;
    const LIGHTNING_TRAIL  = 219;
    const DENSE_CLOUD      = 220;
    // Simulation constants
    let speed               = 1;
    const simulationTimeStep= 0.1;
    const vaporTransformThreshold= 4;
    const diffusionRate     = 0.3;
    // Realistic fire temperatures in Celsius
    const fireTemperature   = 1000;  // Standard fire temperature (more realistic)
    const woodFireTemp      = 800;   // Wood burning temperature
    const gasFireTemp       = 1200;  // Gas burning temperature
    const coalFireTemp      = 1400;  // Coal burning temperature
    const thermiteFireTemp  = 2500;  // Thermite burning temperature
    const organicFireTemp   = 600;   // Organic matter burning (lower temp)
    const oilFireTemp       = 900;   // Oil burning temperature
    
    // Function to get appropriate fire temperature based on source material
    function getFireTemperatureForSource(sourceElement) {
      switch(sourceElement) {
        case WOOD:
        case BURNING_WOOD:
        case BIRCH_WOOD:
          return woodFireTemp;
        case COAL:
        case COAL_LUMP:
        case BURNING_COAL:
        case BURNING_COAL_LUMP:
          return coalFireTemp;
        case GAS:
        case BURNING_GAS:
          return gasFireTemp;
        case THERMITE:
        case BURNING_THERMITE:
          return thermiteFireTemp;
        case OIL:
          return oilFireTemp;
        case GRASS:
        case OAK_LEAVES:
        case BIRCH_LEAVES:
        case OAK_BABY_LEAVES:
        case BIRCH_BABY_LEAVES:
        case BURNING_LEAVES:
        case ROOT:
        case BURNING_ROOT:
        case WHEAT:
        case FLOUR:
        case DOUGH:
        case BREAD:
        case BURNING_ORGANIC:
          return organicFireTemp;
        default:
          return fireTemperature; // Standard fire temperature
      }
    }
    
    // New element behavior functions
    function handlePhotons() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === PHOTON && !moved[y][x]) {
            photonLife[y][x] += simulationTimeStep;
            
            // Photons decay after too many bounces (instead of time)
            if (photonBounces[y][x] >= 15) { // Decay after 15 bounces
              // Restore underlying element if it exists
              if (photonUnderlying && photonUnderlyingTemp && 
                  photonUnderlying[y] && photonUnderlyingTemp[y] &&
                  photonUnderlying[y][x] !== null && photonUnderlying[y][x] !== undefined) {
                // Validate the stored element value
                const storedElement = photonUnderlying[y][x];
                if (storedElement >= 0 && storedElement <= 300) { // Valid element range check
                  grid[y][x] = storedElement;
                  temp[y][x] = photonUnderlyingTemp[y][x];
                } else {
                  // Invalid element, just erase
                  eraseCell(x, y);
                }
                photonUnderlying[y][x] = null;
                photonUnderlyingTemp[y][x] = null;
              } else {
                eraseCell(x, y);
              }
              continue;
            }
            
            // Move photon in its direction
            const dx = photonDirX[y][x];
            const dy = photonDirY[y][x];
            const nx = x + dx;
            const ny = y + dy;
            
            // Check bounds and bounce off screen edges
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
              // Bounce off screen edges
              if (nx < 0 || nx >= GRID_SIZE) {
                photonDirX[y][x] = -photonDirX[y][x];
              }
              if (ny < 0 || ny >= GRID_SIZE) {
                photonDirY[y][x] = -photonDirY[y][x];
              }
              photonBounces[y][x]++; // Increment bounce count
              photonEnergy[y][x] *= 0.9; // Lose some energy on bounce
              if (photonEnergy[y][x] < 10) {
                // Restore underlying element if it exists
                if (photonUnderlying && photonUnderlyingTemp && 
                    photonUnderlying[y] && photonUnderlyingTemp[y] &&
                    photonUnderlying[y][x] !== null && photonUnderlying[y][x] !== undefined) {
                  // Validate the stored element value
                  const storedElement = photonUnderlying[y][x];
                  if (storedElement >= 0 && storedElement <= 300) { // Valid element range check
                    grid[y][x] = storedElement;
                    temp[y][x] = photonUnderlyingTemp[y][x];
                  } else {
                    // Invalid element, just erase
                    eraseCell(x, y);
                  }
                  photonUnderlying[y][x] = null;
                  photonUnderlyingTemp[y][x] = null;
                } else {
                  eraseCell(x, y);
                }
              }
              continue;
            }
            
            const targetElement = grid[ny][nx];
            
            // Photon interactions
            if (targetElement === EMPTY) {
              // Move to empty space - restore underlying element if needed
              if (photonUnderlying && photonUnderlyingTemp && 
                  photonUnderlying[y] && photonUnderlyingTemp[y] &&
                  photonUnderlying[y][x] !== null && photonUnderlying[y][x] !== undefined) {
                const underlyingElement = photonUnderlying[y][x];
                const underlyingTemp = photonUnderlyingTemp[y][x];
                
                // Validate the stored element value
                if (underlyingElement >= 0 && underlyingElement <= 300) { // Valid element range check
                  photonUnderlying[y][x] = null;
                  photonUnderlyingTemp[y][x] = null;
                  
                  // Move photon to new position
                  grid[y][x] = underlyingElement;
                  temp[y][x] = underlyingTemp;
                  grid[ny][nx] = PHOTON;
                  temp[ny][nx] = temp[y][x];
                  moved[ny][nx] = true;
                  photonLife[ny][nx] = photonLife[y][x];
                  photonDirX[ny][nx] = photonDirX[y][x];
                  photonDirY[ny][nx] = photonDirY[y][x];
                  photonEnergy[ny][nx] = photonEnergy[y][x];
                  photonColor[ny][nx] = photonColor[y][x];
                  photonBounces[ny][nx] = photonBounces[y][x];
                } else {
                  // Invalid element, use moveCell
                  moveCell(x, y, nx, ny, temp[y][x], PHOTON);
                  photonLife[ny][nx] = photonLife[y][x];
                  photonDirX[ny][nx] = photonDirX[y][x];
                  photonDirY[ny][nx] = photonDirY[y][x];
                  photonEnergy[ny][nx] = photonEnergy[y][x];
                  photonColor[ny][nx] = photonColor[y][x];
                  photonBounces[ny][nx] = photonBounces[y][x];
                }
              } else {
                moveCell(x, y, nx, ny, temp[y][x], PHOTON);
                photonLife[ny][nx] = photonLife[y][x];
                photonDirX[ny][nx] = photonDirX[y][x];
                photonDirY[ny][nx] = photonDirY[y][x];
                photonEnergy[ny][nx] = photonEnergy[y][x];
                photonColor[ny][nx] = photonColor[y][x];
                photonBounces[ny][nx] = photonBounces[y][x];
              }
            } else if (targetElement === GLASS || targetElement === ICE || targetElement === WATER || 
                       targetElement === WATER_VAPOR || targetElement === CLOUD || targetElement === DENSE_CLOUD ||
                       targetElement === GAS || targetElement === OXYGEN || targetElement === CARBON_DIOXIDE ||
                       targetElement === HELIUM || targetElement === SMOKE || targetElement === ACID_STEAM ||
                       targetElement === ACID_CLOUD) {
              // Pass through transparent materials - photon overlays on top
              // Store photon data
              const tempPhotonLife = photonLife[y][x];
              const tempPhotonDirX = photonDirX[y][x];
              const tempPhotonDirY = photonDirY[y][x];
              const tempPhotonEnergy = photonEnergy[y][x];
              const tempPhotonColor = photonColor[y][x];
              const tempPhotonTemp = temp[y][x];
              
              // Clear current photon position and restore underlying element if needed
              if (photonUnderlying && photonUnderlyingTemp && 
                  photonUnderlying[y] && photonUnderlyingTemp[y] &&
                  photonUnderlying[y][x] !== null && photonUnderlying[y][x] !== undefined) {
                // Validate the stored element value
                const storedElement = photonUnderlying[y][x];
                if (storedElement >= 0 && storedElement <= 300) { // Valid element range check
                  grid[y][x] = storedElement;
                  temp[y][x] = photonUnderlyingTemp[y][x];
                } else {
                  // Invalid element, just erase
                  eraseCell(x, y);
                }
                photonUnderlying[y][x] = null;
                photonUnderlyingTemp[y][x] = null;
              } else {
                eraseCell(x, y);
              }
              
              // Place photon at new position (overlaying the existing element)
              // The photon will be rendered on top visually
              grid[ny][nx] = PHOTON;
              temp[ny][nx] = tempPhotonTemp;
              photonLife[ny][nx] = tempPhotonLife;
              photonDirX[ny][nx] = tempPhotonDirX;
              photonDirY[ny][nx] = tempPhotonDirY;
              photonEnergy[ny][nx] = tempPhotonEnergy;
              photonColor[ny][nx] = tempPhotonColor;
              photonBounces[ny][nx] = photonBounces[y][x]; // Copy bounce count
              moved[ny][nx] = true;
              
              // Store what was underneath the photon for when it moves away
              if (photonUnderlying && photonUnderlyingTemp &&
                  photonUnderlying[ny] && photonUnderlyingTemp[ny] &&
                  targetElement >= 0 && targetElement <= 300) { // Only store valid elements
                photonUnderlying[ny][nx] = targetElement;
                photonUnderlyingTemp[ny][nx] = temp[ny][nx];
              }
              
              // Slightly heat the material we're passing through
              temp[ny][nx] = Math.min((temp[ny][nx] || 20) + 0.5, temp[ny][nx] + 10);
            } else if (targetElement === GLASS_SHARD) {
              // Glass shards scatter the photon and change color - but don't destroy the shard
              const tempPhotonLife = photonLife[y][x];
              const tempPhotonEnergy = photonEnergy[y][x] * 0.9; // Lose some energy
              const tempPhotonTemp = temp[y][x];
              
              // Random new direction (bounce back)
              const directions = [[-1,-1], [0,-1], [1,-1], [-1,0], [1,0], [-1,1], [0,1], [1,1]];
              const newDir = directions[Math.floor(Math.random() * directions.length)];
              photonDirX[y][x] = newDir[0];
              photonDirY[y][x] = newDir[1];
              
              // Increment bounce count
              photonBounces[y][x]++;
              
              // Change color
              const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
              photonColor[y][x] = colors[Math.floor(Math.random() * colors.length)];
              
              // Update photon energy
              photonEnergy[y][x] = tempPhotonEnergy;
              
              // Heat the glass shard slightly
              temp[ny][nx] = Math.min((temp[ny][nx] || 20) + 2, 150);
              
              // Photon stays in current position with new direction and color
            } else {
              // Bounce off solid materials
              photonBounces[y][x]++; // Increment bounce count
              photonEnergy[y][x] *= 0.8; // Lose energy on bounce
              if (photonEnergy[y][x] < 10) {
                // Restore underlying element if it exists
                if (photonUnderlying && photonUnderlyingTemp && 
                    photonUnderlying[y] && photonUnderlyingTemp[y] &&
                    photonUnderlying[y][x] !== null && photonUnderlying[y][x] !== undefined) {
                  // Validate the stored element value
                  const storedElement = photonUnderlying[y][x];
                  if (storedElement >= 0 && storedElement <= 300) { // Valid element range check
                    grid[y][x] = storedElement;
                    temp[y][x] = photonUnderlyingTemp[y][x];
                  } else {
                    // Invalid element, just erase
                    eraseCell(x, y);
                  }
                  photonUnderlying[y][x] = null;
                  photonUnderlyingTemp[y][x] = null;
                } else {
                  eraseCell(x, y);
                }
                continue;
              }
              
              // Reverse direction
              photonDirX[y][x] = -photonDirX[y][x];
              photonDirY[y][x] = -photonDirY[y][x];
              
              // Heat the target slightly
              temp[ny][nx] = Math.min((temp[ny][nx] || 20) + 5, 200);
            }
          }
        }
      }
    }
    
    function handleLightning() {
      // Process lightning trail decay: any trail cell older than 0.7 seconds vanishes
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === LIGHTNING_TRAIL) {
            if (lightningTrailLife[y][x] === null) {
              lightningTrailLife[y][x] = 0;
            } else {
              lightningTrailLife[y][x] += simulationTimeStep;
              if (lightningTrailLife[y][x] >= 0.7) {
                eraseCell(x, y);
                lightningTrailLife[y][x] = null;
              }
            }
          }
        }
      }
      
      // Process explosion for lightning strike cells
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (!moved[y][x] && grid[y][x] === LIGHTNING) {
            if (lightningLife[y][x] === null) {
              lightningLife[y][x] = 0;
            }
            lightningLife[y][x] += simulationTimeStep;
            
            // Only convert to trail if this lightning was directly spawned from a dense cloud
            let isDirectlyFromCloud = false;
            if (y - 1 >= 0 && grid[y - 1][x] === DENSE_CLOUD) {
              isDirectlyFromCloud = true;
            }
            
            // Convert only cloud-spawned lightning to trail after a short time (0.1 seconds)
            if (isDirectlyFromCloud && lightningLife[y][x] >= 0.1) {
              grid[y][x] = LIGHTNING_TRAIL;
              lightningTrailLife[y][x] = 0;
              lightningLife[y][x] = null;
              continue;
            }
            
            // After 1 second, only the bottom lightning cell explodes
            if (lightningLife[y][x] >= 1.0) {
              // Check if this is the bottom-most lightning cell in the column
              let isBottomLightning = true;
              if (y + 1 < GRID_SIZE && (grid[y + 1][x] === LIGHTNING || grid[y + 1][x] === LIGHTNING_TRAIL)) {
                isBottomLightning = false; // There's more lightning below this cell
              }
              
              if (isBottomLightning) {
                // Only explode if this is the bottom lightning cell
                explodeBomb(x, y);
                
                // Clear the entire lightning column after explosion
                for (let clearY = y; clearY >= 0; clearY--) {
                  if (grid[clearY][x] === LIGHTNING || grid[clearY][x] === LIGHTNING_TRAIL) {
                    eraseCell(x, clearY);
                    lightningLife[clearY][x] = null;
                    lightningTrailLife[clearY][x] = null;
                  } else {
                    break;
                  }
                }
              } else {
                // If not bottom lightning, just clear this cell without explosion
                eraseCell(x, y);
                lightningLife[y][x] = null;
              }
            }
          }
        }
      }
    }
    
    function handleDenseClouds() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === DENSE_CLOUD) {
            // Check if surrounded by dense clouds for electrical activity
            let surroundingDenseClouds = 0;
            let adjacentDenseClouds = 0;
            const neighbors = [[-1,-1], [0,-1], [1,-1], [-1,0], [1,0], [-1,1], [0,1], [1,1]];
            const adjacentNeighbors = [[-1,0], [1,0], [0,-1], [0,1]];
            
            for (const [dx, dy] of neighbors) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === DENSE_CLOUD) {
                  surroundingDenseClouds++;
                }
              }
            }
            
            for (const [dx, dy] of adjacentNeighbors) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === DENSE_CLOUD) {
                  adjacentDenseClouds++;
                }
              }
            }
            
            // Lightning generation with better conditions
            if (surroundingDenseClouds >= 6 && surroundingDenseClouds < 8) { // Need 6-7 surrounding clouds (not completely surrounded)
              // Much rarer chance to create lightning, and only if nothing is underneath
              if (Math.random() < 0.002) { // 0.2% chance per frame (increased from 0.05%)
                // Check if the cell directly below is empty (where we'll spawn lightning)
                let canSpawnLightning = true;
                if (y + 1 >= GRID_SIZE || grid[y + 1][x] !== EMPTY) {
                  canSpawnLightning = false; // Can't spawn lightning here
                }
                
                // Also check that there's no existing lightning nearby
                let hasNearbyLightning = false;
                for (const [dx, dy] of neighbors) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    if (grid[ny][nx] === LIGHTNING || grid[ny][nx] === LIGHTNING_TRAIL) {
                      hasNearbyLightning = true;
                      break;
                    }
                  }
                }
                
                if (canSpawnLightning && !hasNearbyLightning && y + 1 < GRID_SIZE) {
                  // Create a full lightning strike downward from the dense cloud
                  let strikeY = y + 1;
                  const startY = strikeY; // Track starting position for length calculation
                  
                  // Strike downward until we hit something solid or reach the bottom
                  while (strikeY < GRID_SIZE) {
                    const currentElement = grid[strikeY][x];
                    
                    // Stop if we hit solid material (not gases/liquids/empty)
                    if (currentElement !== EMPTY && 
                        currentElement !== WATER_VAPOR && 
                        currentElement !== CLOUD && 
                        currentElement !== DENSE_CLOUD && 
                        currentElement !== SMOKE && 
                        currentElement !== GAS && 
                        currentElement !== BURNING_GAS &&
                        currentElement !== CARBON_DIOXIDE &&
                        currentElement !== OXYGEN &&
                        currentElement !== HELIUM &&
                        currentElement !== ACID_STEAM &&
                        currentElement !== ACID_CLOUD) {
                      break;
                    }
                    
                    // Heat up atmospheric elements without destroying them
                    if (currentElement === CLOUD || currentElement === DENSE_CLOUD || 
                        currentElement === WATER_VAPOR || currentElement === SMOKE) {
                      temp[strikeY][x] = Math.max(temp[strikeY][x], 2000);
                    }
                    
                    // Only place lightning in empty cells
                    if (currentElement === EMPTY) {
                      grid[strikeY][x] = LIGHTNING_TRAIL;
                      temp[strikeY][x] = 2000;
                      lightningTrailLife[strikeY][x] = 0;
                    }
                    
                    strikeY++;
                  }
                  
                  // Place the bottom lightning strike (the explosive one)
                  if (strikeY - 1 >= y + 1 && strikeY - 1 < GRID_SIZE) {
                    const bottomY = strikeY - 1;
                    grid[bottomY][x] = LIGHTNING;
                    temp[bottomY][x] = 5000;
                    lightningLife[bottomY][x] = 0;
                  }
                  
                  // Calculate lightning length and play sound if longer than 5 cells
                  const lightningLength = strikeY - startY;
                  if (lightningLength > 5) {
                    playLightningSound();
                  }
                }
              }
            }
            
            // Electrical sparks with adjacent dense clouds
            if (adjacentDenseClouds >= 3) {
              // Check if there's any lightning nearby (don't create sparks if lightning is active)
              let hasNearbyLightning = false;
              for (const [dx, dy] of neighbors) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] === LIGHTNING || grid[ny][nx] === LIGHTNING_TRAIL) {
                    hasNearbyLightning = true;
                    break;
                  }
                }
              }
              
              // Only create sparks if no lightning is nearby
              if (!hasNearbyLightning) {
                // Chance to create electrical sparks
                if (Math.random() < 0.005) { // 0.5% chance per frame (reduced from 2%)
                  for (const [dx, dy] of adjacentNeighbors) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                      if (grid[ny][nx] === DENSE_CLOUD && Math.random() < 0.4) {
                        grid[ny][nx] = SPARK;
                        temp[ny][nx] = 300;
                        sparkLife[ny][nx] = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    function transformCloudsToDense() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === CLOUD && temp[y][x] > 55 && temp[y][x] < 100) {
            // Check if touching at least 2 other clouds
            let touchingClouds = 0;
            const neighbors = [[-1,0], [1,0], [0,-1], [0,1]];
            
            for (const [dx, dy] of neighbors) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === CLOUD || grid[ny][nx] === DENSE_CLOUD) {
                  touchingClouds++;
                }
              }
            }
            
            if (touchingClouds >= 2) {
              grid[y][x] = DENSE_CLOUD;
              temp[y][x] = 60;
            }
          }
          // Dense clouds can become regular clouds if too hot
          else if (grid[y][x] === DENSE_CLOUD && temp[y][x] >= 100) {
            grid[y][x] = WATER_VAPOR;
            temp[y][x] = 105;
            vaporLife[y][x] = 0;
          }
        }
      }
    }
    const burnDuration      = 1.5;
    const burnToAshChance   = 0.25;
    const fireLifetime      = 2.0;
    const glassTemp         = 1700;
    const bombExplosionRadius= 3;
    const wetDirtEvapTemp   = 100;
    const doughBakeTemp     = 120;
    const breadBurnTemp     = 1000;
    const sparkLifetime     = 0.5;
    const burningGasDuration= 2.0;
    const burnDurationCoal      = 10.0;
    const burnDurationCoalLump  = 5.0;
    // Temperature definitions for various materials (in Celsius)
    const saltMeltingTemp = 801;      // Salt melting point
    const steelMeltingTemp = 1450;    // Steel melting point
    const copperMeltingTemp = 1085;   // Copper melting point
    const diamondMeltingTemp = 3550;  // Diamond melting point
    const glassMeltingTemp = 1400;    // Glass melting point
    const stoneMeltingTemp = 1200;    // Stone melting point
    const cobbleMeltingTemp = 800;    // Cobblestone melting point (lower than stone)
    const iceMeltingTemp = 0;         // Ice melting point
    const sugarMeltingTemp = 186;     // Sugar melting point
    
    // Map elements to their molten versions for consistent transformations
    const meltingMap = {
      [SALT]: MOLTEN_SALT,
      [STEEL]: MOLTEN_STEEL,
      [COPPER]: MOLTEN_COPPER,
      [OXIDIZED_COPPER]: MOLTEN_COPPER,
      [CHARGED_COPPER]: MOLTEN_COPPER,
      [CHARGED_DOWN_COPPER]: MOLTEN_COPPER,
      [DIAMOND]: MOLTEN_DIAMOND,
      [DIAMOND_SHARDS]: MOLTEN_DIAMOND,
      [GLASS]: MOLTEN_GLASS,
      [GLASS_SHARD]: MOLTEN_GLASS,
      [SUGAR]: MOLTEN_SUGAR
    };
    const saltWaterEvaporationRate = 0.02; // Rate at which salt water evaporates
    // Conduction rates
    const conductionRates = {
      // Base elements
      [EMPTY]: 0,
      [WALL]: 0, // I bloody broke wall ):
      [ERASER]: 0,
      
      // Metals (highest conductivity)
      [COPPER]: 4.0,       // Copper has excellent conductivity
      [CHARGED_COPPER]: 4.0,
      [CHARGED_DOWN_COPPER]: 4.0,
      [STEEL]: 1.5,        // Steel conducts well but less than copper
      
      // Liquids (moderate conductivity)
      [WATER]: 0.6,        // Water conducts heat moderately well
      [LAVA]: 0.8,         // Molten rock conducts better than water
      [MOLTEN_SLAG]: 0.7,
      [ACID]: 0.5,
      [OIL]: 0.3,          // Oil conducts less than water
      
      // Gases (poor conductivity but good convection)
      [WATER_VAPOR]: 0.2,  // Gases conduct poorly but move
      [CLOUD]: 0.15,
      [SMOKE]: 0.1,
      [GAS]: 0.15,
      [BURNING_GAS]: 0.2,
      [CARBON_DIOXIDE]: 0.15,
      [OXYGEN]: 0.15,
      [HELIUM]: 0.25,      // Helium conducts better than other gases
      [ACID_STEAM]: 0.2,
      [ACID_CLOUD]: 0.15,
      
      // Solids (varied conductivity)
      [STONE]: 0.3,
      [BASALT]: 0.25,
      [OBSIDIAN]: 0.2,
      [GLASS]: 0.15,       // Glass is a poor conductor
      [GLASS_SHARD]: 0.15,  // Glass shards conduct like glass
      [SAND]: 0.2,         // Sand conducts poorly
      [WET_SAND]: 0.3,     // Wet sand conducts better than dry
      [CELL]: 0.4,         // Cells conduct moderately well due to water content
      [BLOOD]: 0.5,        // Blood conducts like water
      [SAWDUST]: 0.1,
      [SALT]: 0.3,          // Salt conducts heat better than sand
      [SALT_WATER]: 0.5,   // Salt water conducts heat better than fresh water      // Sawdust is a poor conductor
      // New elements
      [GLUE]: 0.3,          // Glue has moderate conductivity
      [SUGAR]: 0.2,         // Sugar conducts heat similar to salt but slightly less
      [SUGAR_WATER]: 0.48,  // Sugar water conducts similar to salt water but slightly less
      [PLANT]: 0.1,         // Plant has poor conductivity like other organic materials
      [DIAMOND]: 10.0,      // Diamond has extremely high thermal conductivity
      [DIAMOND_SHARDS]: 8.0, // Diamond shards conduct slightly less than solid diamond
      [MOLTEN_DIAMOND]: 2.0, // Molten diamond conducts less than solid diamond but more than most liquids
      [CONFETTI]: 0.1,      // Confetti has poor conductivity like paper
      [OXIDIZED_COPPER]: 2.5, // Oxidized copper conducts less than copper but still well
      [MOLTEN_COPPER]: 2.0,  // Molten copper conducts well but less than solid
      [MOLTEN_SALT]: 0.6,   // Molten salt conducts better than solid salt
      [MOLTEN_STEEL]: 1.2,  // Molten steel conducts slightly less than solid steel
      [MOLTEN_SUGAR]: 0.4,  // Molten sugar conducts better than solid sugar
      [MOLTEN_GLASS]: 0.3,  // Molten glass conducts better than solid glass
      [MOLTEN_ELECTRICAL]: 2.0, // For electrical components when melted
      [DIRT]: 0.15,
      [WET_DIRT]: 0.25,
      [COBBLESTONE]: 0.25,
      [ICE]: 0.4,          // Ice conducts better than water
      
      // Organic materials (poor conductors)
      [WOOD]: 0.12,
      [BURNING_WOOD]: 0.15,
      [ROOT]: 0.1,
      [BURNING_ROOT]: 0.15,
      [DEAD_ROOT]: 0.08,
      [WHEAT]: 0.08,
      [WHEAT_SEEDS]: 0.07,
      [FLOUR]: 0.05,
      [DOUGH]: 0.1,
      [BREAD]: 0.08,
      [GRASS]: 0.07,
      [OAK_SEEDS]: 0.07,
      [OAK_LEAVES]: 0.08,
      [OAK_BABY_LEAVES]: 0.07,
      [DEAD_OAK]: 0.06,
      [BIRCH_SEEDS]: 0.07,
      [BIRCH_LEAVES]: 0.08,
      [BIRCH_BABY_LEAVES]: 0.07,
      [BIRCH_WOOD]: 0.11,
      [DEAD_BIRCH]: 0.06,
      [CELL]: 0.2,
      [DEAD_CELL]: 0.08,
      [BLOOD]: 0.5,
      [GLASS_SHARD]: 0.15,
      [SAWDUST]: 0.09,
      [SALT]: 0.2,          // Salt has moderate heat capacity
      [SALT_WATER]: 0.7,   // Salt water has higher heat capacity than fresh water
      [DEAD_PLANT]: 0.06,
      [BURNING_LEAVES]: 0.12,
      [BURNING_ORGANIC]: 0.15,
      [MEAT]: 0.3,         // Meat conducts better due to water content
      [COOKED_MEAT]: 0.2,  // Cooked meat conducts less as water evaporates
      
      // Special elements
      [FIRE]: 0.8,         // Fire transfers heat well
      [ASH]: 0.05,         // Ash is an insulator
      [COAL]: 0.2,
      [COAL_LUMP]: 0.15,
      [BURNING_COAL]: 0.4,
      [BURNING_COAL_LUMP]: 0.35,
      [THERMITE]: 0.3,
      [BURNING_THERMITE]: 1.2,  // Thermite reaction transfers heat extremely well
      [SLIME]: 0.3,
      
      // Electronic components
      [COOLER]: 1.0,       // Designed to transfer heat
      [HEATER]: 1.0,
      [HEAT_SEPARATOR]: 0.4,
      [CHARGED_HEAT_SEPARATOR]: 0.4,
      [CHARGED_DOWN_HEAT_SEPARATOR]: 0.4,
      [INPUT]: 0.3,
      [CHARGED_INPUT]: 0.3,
      [OUTPUT]: 0.3,
      [CHARGED_OUTPUT]: 0.3,
      [NOT_GATE]: 0.3,
      [AND_GATE]: 0.3,
      [BLOCKER]: 0.3,
      [CHARGED_BLOCKER]: 0.3,
      [CLONER]: 0.3,
      
      // Explosives (low conductivity for safety)
      [BOMB]: 0.1,
      [BIG_BOMB]: 0.1,
      [WATER_BOMB]: 0.1,
      [FIRE_BOMB]: 0.1,
      [CRYO_BOMB]: 0.1,
      [NUKE_BOMB]: 0.1,
      
      // Miscellaneous
      [SPARK]: 0.3,
      [BOUNCY_BALL]: 0.2,
      
      // New physics elements
      [INSULATOR]: 0.001,   // Nearly perfect insulator - almost no heat conduction
      [PHOTON]: 0,          // Photons don't conduct heat
      [LIGHTNING]: 10.0,    // Lightning conducts extremely well
      [LIGHTNING_TRAIL]: 0.5, // Lightning trail conducts moderately
      [DENSE_CLOUD]: 0.1,   // Dense clouds conduct slightly less than normal clouds
      [SNOW]: 0.25          // Snow conducts heat moderately (similar to wet sand)
    };
    const heatCapacities = {
      // Base elements
      [EMPTY]: 1,
      [WALL]: 1000,
      [ERASER]: 1,
      
      // Metals (low heat capacity - heat up/cool quickly)
      [COPPER]: 0.4,       // Copper heats up quickly
      [CHARGED_COPPER]: 0.4,
      [CHARGED_DOWN_COPPER]: 0.4,
      [STEEL]: 0.5,        // Steel takes a bit more energy to heat
      
      // Liquids (high heat capacity - store heat well)
      [WATER]: 4.0,        // Water has very high heat capacity
      [SALT_WATER]: 3.9,    // Salt water has slightly lower heat capacity than pure water
      [LAVA]: 1.0,         // Molten rock has lower capacity than water
      [MOLTEN_SLAG]: 1.0,
      [ACID]: 3.0,
      [OIL]: 2.0,          // Oil has lower capacity than water
      
      // Gases (moderate heat capacity)
      [WATER_VAPOR]: 2.0,  // Steam holds less heat than water
      [CLOUD]: 2.0,
      [SMOKE]: 1.0,
      [GAS]: 1.0,
      [BURNING_GAS]: 0.8,
      [CARBON_DIOXIDE]: 0.8,
      [OXYGEN]: 0.9,
      [HELIUM]: 5.0,       // Helium has extremely high heat capacity
      [ACID_STEAM]: 2.0,
      [ACID_CLOUD]: 2.0,
      
      // New elements
      [CELL]: 2.0,        // Cell has moderate heat capacity like living tissue
      [DEAD_CELL]: 1.0,   // Dead cell has lower heat capacity
      [BLOOD]: 3.8,       // Blood has high heat capacity similar to water
      [GLASS_SHARD]: 0.8, // Glass has moderate-low heat capacity
      
      // Solids (varied heat capacity)
      [STONE]: 0.8,
      [BASALT]: 0.8,
      [OBSIDIAN]: 0.8,
      [GLASS]: 0.8,
      [SAND]: 0.8,
      [SALT]: 0.8,         // Similar to sand and other minerals
      [WET_SAND]: 1.2,     // Water increases heat capacity
      // New elements
      [GLUE]: 1.5,         // Glue has moderate heat capacity
      [SUGAR]: 0.8,        // Similar to salt and other powder materials
      [SUGAR_WATER]: 3.8,  // Similar to salt water
      [PLANT]: 1.8,        // Similar to other plant materials
      [DIAMOND]: 0.5,      // Diamond has low heat capacity (heats/cools quickly)
      [DIAMOND_SHARDS]: 0.5, // Same as diamond
      [MOLTEN_DIAMOND]: 0.9, // Slightly higher in liquid form
      [CONFETTI]: 1.0,     // Paper-like heat capacity
      [OXIDIZED_COPPER]: 0.45, // Slightly higher than pure copper
      [MOLTEN_COPPER]: 0.6, // Higher in liquid form
      [MOLTEN_SALT]: 1.1,  // Higher than solid salt
      [MOLTEN_STEEL]: 0.7, // Higher than solid steel
      [MOLTEN_SUGAR]: 1.2, // Higher than solid sugar
      [MOLTEN_GLASS]: 1.0, // Higher than solid glass
      [MOLTEN_ELECTRICAL]: 0.6, // For electrical components when melted
      [DIRT]: 0.9,
      [WET_DIRT]: 1.3,
      [COBBLESTONE]: 0.8,
      [ICE]: 2.0,          // Ice has high heat capacity
      
      // Organic materials (moderate heat capacity)
      [WOOD]: 1.8,
      [BURNING_WOOD]: 1.0,
      [ROOT]: 1.8,
      [BURNING_ROOT]: 1.0,
      [DEAD_ROOT]: 1.5,
      [WHEAT]: 1.5,
      [WHEAT_SEEDS]: 1.2,
      [FLOUR]: 1.2,
      [DOUGH]: 2.0,        // Water content increases capacity
      [BREAD]: 1.5,
      [GRASS]: 1.5,
      [OAK_SEEDS]: 1.2,
      [OAK_LEAVES]: 1.5,
      [OAK_BABY_LEAVES]: 1.5,
      [DEAD_OAK]: 1.2,
      [BIRCH_SEEDS]: 1.2,
      [BIRCH_LEAVES]: 1.5,
      [BIRCH_BABY_LEAVES]: 1.5,
      [BIRCH_WOOD]: 1.7,
      [DEAD_BIRCH]: 1.2,
      [CELL]: 2.5,
      [DEAD_CELL]: 1.2,
      [BLOOD]: 3.5,
      [GLASS_SHARD]: 0.8,
      [DEAD_PLANT]: 1.2,
      [BURNING_LEAVES]: 0.8,
      [BURNING_ORGANIC]: 0.8,
      [MEAT]: 3.0,         // High water content means high capacity
      [COOKED_MEAT]: 1.5,  // Less water, lower capacity
      
      // Special elements
      [FIRE]: 0.2,         // Fire changes temperature quickly
      [ASH]: 0.8,
      [COAL]: 0.8,
      [COAL_LUMP]: 0.8,
      [BURNING_COAL]: 0.5,
      [BURNING_COAL_LUMP]: 0.5,
      [THERMITE]: 0.8,
      [BURNING_THERMITE]: 0.5,
      [SLIME]: 2.5,        // High water content
      
      // Electronic components (moderate capacity)
      [COOLER]: 1.0,
      [HEATER]: 1.0,
      [HEAT_SEPARATOR]: 1.0,
      [CHARGED_HEAT_SEPARATOR]: 1.0,
      [CHARGED_DOWN_HEAT_SEPARATOR]: 1.0,
      [INPUT]: 1.0,
      [CHARGED_INPUT]: 1.0,
      [OUTPUT]: 1.0,
      [CHARGED_OUTPUT]: 1.0,
      [NOT_GATE]: 1.0,
      [AND_GATE]: 1.0,
      [BLOCKER]: 1.0,
      [CHARGED_BLOCKER]: 1.0,
      [CLONER]: 1.0,
      
      // Explosives
      [BOMB]: 0.8,
      [BIG_BOMB]: 0.8,
      [WATER_BOMB]: 0.8,
      [FIRE_BOMB]: 0.8,
      [CRYO_BOMB]: 0.8,
      [NUKE_BOMB]: 0.8,
      
      // Miscellaneous
      [SPARK]: 0.2,
      [BOUNCY_BALL]: 1.5,
      
      // New physics elements
      [INSULATOR]: 50.0,    // Extremely high heat capacity - strongly resists temperature change
      [PHOTON]: 0.1,        // Photons have minimal heat capacity
      [LIGHTNING]: 0.1,     // Lightning changes temperature quickly
      [LIGHTNING_TRAIL]: 0.1, // Lightning trail changes temperature quickly
      [DENSE_CLOUD]: 2.5,   // Dense clouds have higher capacity than normal clouds
      [SNOW]: 1.8           // Snow has moderate heat capacity (similar to ice but less)
    };
    // New Constants:
    // Add this after your element constants (SAND, WATER, etc.)
    const elementBaseColors = {
      // Basic elements
      [EMPTY]: null,
      [SALT]: '#ffffff',
      [SALT_WATER]: '#1ea5ff',
      [SAND]: '#f4a460',
      [CELL]: '#66cc99',
      [DEAD_CELL]: '#336644',
      [BLOOD]: '#cc0000',
      [GLASS_SHARD]: '#e0f0ff',
      [SAWDUST]: '#d9c29e',
      [WALL]: '#666666',
      [WATER]: '#1e90ff',
      [SNOW]: '#ffffff',
      [LAVA]: '#ff4500',
      [STONE]: '#808080',
      [ERASER]: '#ffaaaa',
      
      // Gases and vapors
      [WATER_VAPOR]: '#e0e0e0',
      [CLOUD]: '#ffffff',
      [SMOKE]: '#666666',
      [GAS]: 'rgba(200,200,200,0.2)',
      [BURNING_GAS]: '#ff6666',
      [CARBON_DIOXIDE]: 'rgba(128,128,128,0.2)',
      [OXYGEN]: 'rgba(200,230,255,0.2)',
      [HELIUM]: '#e6f7ff',
      [ACID_STEAM]: '#98FB98',
      [ACID_CLOUD]: '#98FB98',
      
      // Rocks and minerals
      [BASALT]: '#555555',
      [OBSIDIAN]: '#333333',
      [MOLTEN_SLAG]: '#ff6600',
      [COBBLESTONE]: '#808080',
      [GLASS]: '#c2e9fb',
      
      // Metals
      [COPPER]: '#b87333',
      [STEEL]: '#aaaaaa',
      [CHARGED_COPPER]: '#ff8c00',
      [CHARGED_DOWN_COPPER]: '#cc6600',
      
      // Temperature elements
      [ICE]: '#cceeff',
      [FIRE]: '#ffcc00',
      [COOLER]: '#3399ff',
      [HEATER]: '#ff3333',
      
      // Wood and plants
      [WOOD]: '#3B220E',
      [BURNING_WOOD]: '#5a3310',
      [ROOT]: '#4a3a2f',
      [BURNING_ROOT]: '#ff4500',
      [DEAD_ROOT]: '#555555',
      [WHEAT_SEEDS]: '#bca136',
      [WHEAT]: '#c2b280',
      [OAK_SEEDS]: '#556b2f',
      [OAK_LEAVES]: '#228b22',
      [OAK_BABY_LEAVES]: '#32cd32',
      [DEAD_OAK]: '#8b4513',
      [BIRCH_SEEDS]: '#6b8e23',
      [BIRCH_LEAVES]: '#32cd32',
      [BIRCH_BABY_LEAVES]: '#7cfc00',
      [BIRCH_WOOD]: '#f5f5f5',
      [DEAD_BIRCH]: '#a9a9a9',
      [GRASS]: '#00aa00',
      [DEAD_PLANT]: '#555555',
      [BURNING_LEAVES]: '#a0522d',
      
      // Food and cooking
      [FLOUR]: '#f5f5dc',
      [DOUGH]: '#d2b48c',
      [BREAD]: '#f4c986',
      [MEAT]: '#FF6B6B',
      [COOKED_MEAT]: '#8B4513',
      
      // Earth elements
      [DIRT]: '#7B5E42',
      [WET_DIRT]: '#4d2e12',
      [WET_SAND]: '#d2a679',
      [ASH]: '#444444',
      
      // Special elements
      [BURNING_ORGANIC]: '#6a3400',
      [SPARK]: '#ffdd00',
      [ACID]: '#90EE90',
      [SLIME]: '#006400',
      [OIL]: '#2F4F4F',
      [BIRD]: '#B8860B',
      
      // Coal and combustibles
      [COAL]: '#202020',
      [COAL_LUMP]: '#303030',
      [BURNING_COAL]: '#ff4500',
      [BURNING_COAL_LUMP]: '#ff4500',
      [THERMITE]: '#AA4444',
      [BURNING_THERMITE]: '#ffc31f',
      
      // Electronic components
      [HEAT_SEPARATOR]: '#ffef96',
      [CHARGED_HEAT_SEPARATOR]: '#ffe033',
      [CHARGED_DOWN_HEAT_SEPARATOR]: '#ffd700',
      
      // New physics elements
      [INSULATOR]: '#ffe4b5',  // Light beige/cream color for insulation
      [PHOTON]: '#ffffff',     // White light
      [LIGHTNING]: '#ffd700',  // Gold yellow lightning
      [LIGHTNING_TRAIL]: '#ffd700', // Gold yellow lightning trail
      [DENSE_CLOUD]: '#d3d3d3', // Darker gray than normal clouds
      
      [INPUT]: '#646464',
      [CHARGED_INPUT]: '#ffff77',
      [OUTPUT]: '#3636ff',
      [CHARGED_OUTPUT]: '#8888ff',
      [NOT_GATE]: '#a15050',
      [AND_GATE]: '#405050',
      [BLOCKER]: '#856fa8',
      [CHARGED_BLOCKER]: '#9b50a3',
      [CLONER]: '#cc00cc',
      
      // Explosives
      [BOMB]: '#ff0000',
      [BIG_BOMB]: '#ff3333',
      [WATER_BOMB]: '#3366ff',
      [FIRE_BOMB]: '#ff6600',
      [CRYO_BOMB]: '#00ccff',
      [NUKE_BOMB]: '#33cc33',
      
      // Special objects
      [BOUNCY_BALL]: '#ff5599',
      
      // New elements with updated IDs
      [GLUE]: '#dfdfdf',
      [SUGAR]: '#ffffff',
      [SUGAR_WATER]: '#add8e6',
      [PLANT]: '#2e8b57',
      [DIAMOND]: '#b9f2ff',
      [DIAMOND_SHARDS]: '#a7e0ed',
      [MOLTEN_DIAMOND]: '#ff93a8',
      [CONFETTI]: '#ff33ff', // Bright consistent color for confetti
      [DABICCO]: '#ff00ff', // Starting base color for Dabicco, will be modified by getTemperatureAdjustedColor
      [OXIDIZED_COPPER]: '#66aa88',
      [MOLTEN_COPPER]: '#ff8844',
      [MOLTEN_SALT]: '#ffddaa',
      [MOLTEN_STEEL]: '#ff6666',
      [MOLTEN_SUGAR]: '#884411',
      [MOLTEN_GLASS]: '#ffaa88',
      [MOLTEN_ELECTRICAL]: '#ff7722'
    };
    // Global arrays for grid state
    let grid = [], temp = [], moved = [];
    let vaporLife = [], cloudLife = [];
    let fireLife = [], smokeLife = [];
    let burningWoodTime = [];
    let wheatHeight = [], wheatMaxHeight = [], seedGrowthTime = [], rootLife = [];
    let sparkLife = [], sparkTimer = [];
    let smokeMaxLife = [], cloudMaxLife = [];
    // New element arrays
    let photonLife = [], photonDirX = [], photonDirY = [], photonEnergy = [], photonColor = [];
let photonBounces = []; // Track number of bounces for each photon
let photonUnderlying = [], photonUnderlyingTemp = []; // Arrays to store what's underneath photons
let lightningLife = [];
let lightningTrailLife = [];
    let branchLevel = [], branchLen = [], branchMaxArr = [], branchSubCount = [];
    let branchDirX = [], branchDirY = [];
    let oakTreeGrowthTime = [], oakTreeHeight = [], oakTreeMaxHeight = [];
    let oakTreeRootTimer = [], oakTreeRootDepth = [], oakTreeRootMax = [];
    let grassStage = [];
    let burningGasTime = [];
    let chargedStateTime = [];
    // Bird movement arrays
    let birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
    let birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballVelocityX = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballVelocityY = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballSoundCooldown = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)); // Prevent sound spam per ball
    let colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // New global variable: stroke thickness (in cells)
    let strokeThickness = 1;
    let isAltKeyDown = false;
    // Audio context for placement sounds
    let audioContext = null;
    // Initialize audio context on first user interaction
    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    // Game version updated to 0.5.0a
    const currentGameVersion = "0.7.1c";

    // Add these right after the GRID_SIZE declaration and before any functions
    // Global lighting system variables
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    
    // Graphics settings
    window.isVariatedColorsEnabled = true; // Default to enabled
    window.isDspleEnabled = false; // DSPLE disabled by default
    window.lightSources = []; // Array to store light sources
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };
    
    function getTemperatureAdjustedColor(baseColor, temperature, elementType, x, y) {
      // Special case for Dabicco (random red/blue gradient that changes at random intervals)
      if (elementType === DABICCO) {
        // Change colors at random intervals (we'll use a slower time component)
        // This creates a more interesting effect than changing every second
        const timeComponent = Math.floor(Date.now() / (1000 + (Math.sin(Date.now() / 5000) * 500)));
        // Use position to ensure different dabicco particles have different colors
        const positionSeed = (x * 127 + y * 311) % 256;
        
        // Create red/blue gradient using the position and time components
        // We'll limit color to primarily red and blue values
        const r = Math.floor(Math.sin(positionSeed * 0.1 + timeComponent * 0.3) * 100 + 155); // Higher red values
        const g = Math.floor(Math.sin(positionSeed * 0.2 + timeComponent * 0.5) * 30); // Minimal green
        const b = Math.floor(Math.sin(positionSeed * 0.3 + timeComponent * 0.7) * 100 + 155); // Higher blue values
        
        return `rgb(${r}, ${g}, ${b})`;
      }
      
      // Special case for Confetti (persistent random colors for each cell)
      if (elementType === CONFETTI) {
        // Check if this cell already has a stored color variation
        if (!colorVariations[y] || !colorVariations[y][x] || !colorVariations[y][x].confettiColor) {
          // If not, assign a random persistent color to this cell
          if (!colorVariations[y]) colorVariations[y] = {};
          if (!colorVariations[y][x]) colorVariations[y][x] = {};
          
          // Generate vibrant color options
          const colorOptions = [
            [255, 50, 50],    // Bright red
            [255, 165, 0],    // Orange
            [255, 255, 0],    // Yellow
            [50, 205, 50],    // Lime green
            [30, 144, 255],   // Dodger blue
            [138, 43, 226],   // Blue violet
            [255, 105, 180],  // Hot pink
            [255, 215, 0],    // Gold
            [0, 255, 127]     // Spring green
          ];
          
          // Assign a random color from our options
          const colorIndex = Math.floor(Math.random() * colorOptions.length);
          colorVariations[y][x].confettiColor = colorOptions[colorIndex];
        }
        
        // Retrieve the persistent color for this cell
        let [r, g, b] = colorVariations[y][x].confettiColor;
        
        // Add a subtle shimmer effect based on time, but maintain the base color
        const shimmerFactor = Math.sin(Date.now() / 500) * 0.1 + 0.95;
        r = Math.floor(r * shimmerFactor);
        g = Math.floor(g * shimmerFactor);
        b = Math.floor(b * shimmerFactor);
        
        return `rgb(${r}, ${g}, ${b})`;
      }
      
      // Normal color processing for other elements
      let r, g, b;
      
      if (baseColor.startsWith('#')) {
        // Handle hex color
        const hex = baseColor.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
      } else if (baseColor.startsWith('rgb')) {
        // Handle rgb color
        const matches = baseColor.match(/\d+/g);
        r = parseInt(matches[0]);
        g = parseInt(matches[1]);
        b = parseInt(matches[2]);
      } else {
        // Default fallback
        return baseColor;
      }
      
      // Apply random variations if they exist for this cell
      if (colorVariations[y] && colorVariations[y][x]) {
        const variation = colorVariations[y][x];
        r = Math.floor(r * variation.r);
        g = Math.floor(g * variation.g);
        b = Math.floor(b * variation.b);
      }
      
      // For liquids, add a slight random variation each time to create a flowing effect
      if (elementType === WATER || elementType === LAVA || elementType === OIL || 
          elementType === ACID || elementType === MOLTEN_SLAG || elementType === BLOOD) {
        // Small random variation for liquids to create a flowing effect
        const liquidVariation = 0.02; 
        r = Math.floor(r * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
        g = Math.floor(g * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
        b = Math.floor(b * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
      }
      
      // Adjust color based on temperature
      // Hot: more red/yellow, Cold: more blue
      if (temperature > 100) {
        // Hot - shift toward red/yellow
        // More aggressive gradient: max effect at 1500Â°C instead of 3000Â°C
        const factor = Math.min((temperature - 100) / 1400, 1); // Max effect at 1500Â°C
        
        // Apply heat glow effect more strongly
        r = Math.min(r + (255 - r) * factor * 0.9, 255);  // Increased from 0.7 to 0.9
        g = Math.min(g + (200 - g) * factor * 0.6, 255);  // Add some yellow/orange glow
        b = Math.max(b - b * factor * 0.8, 0);            // Increased from 0.5 to 0.8
        
        // Add extra glow for very hot temperatures (above 1000Â°C)
        if (temperature > 1000) {
          const glowFactor = Math.min((temperature - 1000) / 1000, 1);
          // Add white-hot effect at extreme temperatures
          r = Math.min(r + (255 - r) * glowFactor * 0.3, 255);
          g = Math.min(g + (255 - g) * glowFactor * 0.3, 255);
          b = Math.min(b + (255 - b) * glowFactor * 0.1, 255);
        }
      } else if (temperature < 0) {
        // Cold - shift toward blue
        const factor = Math.min(Math.abs(temperature) / 100, 1); // Max effect at -100Â°C
        
        // Snow is much less affected by cold temperature hue
        if (elementType === SNOW) {
          // Only very slight blue tinting for snow, much less than other elements
          r = Math.max(r - r * factor * 0.1, 0);
          g = Math.max(g - g * factor * 0.05, 0);
          b = Math.min(b + (255 - b) * factor * 0.1, 255);
        } else {
          // Normal cold coloring for other elements
          r = Math.max(r - r * factor * 0.5, 0);
          g = Math.max(g - g * factor * 0.3, 0);
          b = Math.min(b + (255 - b) * factor * 0.5, 255);
        }
      }
      
      // Only apply color variations if the feature is enabled
      if (window.isVariatedColorsEnabled) {
        // Apply stored color variation for non-liquid elements
        // For liquids, continue to use random variations
        const liquidElements = [WATER, LAVA, ACID, OIL, MOLTEN_SLAG, BLOOD];
        
        if (liquidElements.includes(elementType)) {
          // For liquids, add a new random variation each time
          const variation = 0.02;
          r = Math.min(Math.max(Math.floor(r * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
          g = Math.min(Math.max(Math.floor(g * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
          b = Math.min(Math.max(Math.floor(b * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
        } else if (colorVariations[y][x]) {
          // For other elements, use the stored variation
          r = Math.min(Math.max(Math.floor(r * colorVariations[y][x].r), 0), 255);
          g = Math.min(Math.max(Math.floor(g * colorVariations[y][x].g), 0), 255);
          b = Math.min(Math.max(Math.floor(b * colorVariations[y][x].b), 0), 255);
        }
      }
      
      return `rgb(${r}, ${g}, ${b})`;
    }

    // Add this function to parse URL parameters
function getUrlParameters() {
  const params = {};
  const queryString = window.location.search.substring(1);
  const pairs = queryString.split('&');
  
  for (let i = 0; i < pairs.length; i++) {
    if(!pairs[i]) continue;
    const pair = pairs[i].split('=');
    params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  
  return params;
}

    // DSPLE (Dabicco Shader-Pixel Lighting Engine) functions
    let lightingCanvas = null;
    let lightingContext = null;
    let previousLightMap = null; // Store previous frame's light map for smooth transitions
    let lightingAnimationFrame = null; // Store animation frame ID
    
    // Initialize the DSPLE lighting engine
    function initDspleLightingEngine() {
      // Create lighting canvas overlay if it doesn't exist
      if (!lightingCanvas) {
        lightingCanvas = document.createElement('canvas');
        lightingCanvas.id = 'lightingCanvas';
        lightingCanvas.style.position = 'absolute';
        lightingCanvas.style.top = '0';
        lightingCanvas.style.left = '0';
        lightingCanvas.style.width = '100%';
        lightingCanvas.style.height = '100%';
        lightingCanvas.style.pointerEvents = 'none'; // Allow clicks to pass through
        lightingCanvas.style.zIndex = '1'; // Above the grid but below UI
        lightingCanvas.style.mixBlendMode = 'screen'; // Light blend mode
        lightingCanvas.style.imageRendering = 'pixelated'; // Ensure crisp pixel edges
        
        // Add the canvas to the grid container
        gridContainer.appendChild(lightingCanvas);
        
        // Get the context for drawing
        lightingContext = lightingCanvas.getContext('2d');
      }
      
      // Update canvas dimensions to match the grid
      updateLightingCanvasDimensions();
      
      // Initialize previous light map based on current grid size
      resetLightMap();
      
      // Start the lighting render loop
      lightingAnimationFrame = requestAnimationFrame(renderLighting);
      
      // Add resize observer to handle stage size changes
      if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver(entries => {
          if (window.isDspleEnabled) {
            updateLightingCanvasDimensions();
            resetLightMap();
          }
        });
        resizeObserver.observe(gridContainer);
      }
    }
    
    // Update lighting canvas dimensions to match the grid exactly
    function updateLightingCanvasDimensions() {
      if (lightingCanvas) {
        const gridRect = gridContainer.getBoundingClientRect();
        // Set the canvas size to exactly match the grid container
        lightingCanvas.width = gridRect.width;
        lightingCanvas.height = gridRect.height;
        
        // Ensure the canvas is positioned correctly
        lightingCanvas.style.top = '0';
        lightingCanvas.style.left = '0';
        lightingCanvas.style.width = '100%';
        lightingCanvas.style.height = '100%';
      }
    }
    
    // Reset the light map based on current grid size
    function resetLightMap() {
      previousLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    }
    
    // Clean up the DSPLE lighting engine
    function cleanupDspleLightingEngine() {
      if (lightingCanvas) {
        // Cancel animation frame if active
        if (lightingAnimationFrame) {
          cancelAnimationFrame(lightingAnimationFrame);
          lightingAnimationFrame = null;
        }
        
        // Remove the lighting canvas
        gridContainer.removeChild(lightingCanvas);
        lightingCanvas = null;
        lightingContext = null;
        previousLightMap = null;
      }
    }
    
    // Identify light sources in the grid
    function identifyLightSources() {
      // Clear existing light sources
      window.lightSources = [];
      
      // Define elements that emit light
      const lightEmitters = {
        [FIRE]: { intensity: 1.0, radius: 8, color: '#ffcc00' },
        [LAVA]: { intensity: 0.8, radius: 6, color: '#ff4500' },
        [BURNING_WOOD]: { intensity: 0.7, radius: 5, color: '#ff6600' },
        [BURNING_LEAVES]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_ORGANIC]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_ROOT]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_COAL]: { intensity: 0.9, radius: 7, color: '#ff4500' },
        [BURNING_COAL_LUMP]: { intensity: 1.0, radius: 8, color: '#ff4500' },
        [BURNING_THERMITE]: { intensity: 1.2, radius: 10, color: '#ffff00' },
        [BURNING_GAS]: { intensity: 0.5, radius: 4, color: '#ff6666' },
        [CHARGED_COPPER]: { intensity: 0.4, radius: 3, color: '#ff8c00' },
        [CHARGED_DOWN_COPPER]: { intensity: 0.3, radius: 2, color: '#cc6600' },
        [SPARK]: { intensity: 0.9, radius: 5, color: '#ffdd00' },
        [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, radius: 3, color: '#ffe033' },
        [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, radius: 2, color: '#ffd700' },
        [CHARGED_INPUT]: { intensity: 0.4, radius: 3, color: '#ffff77' },
        [CHARGED_OUTPUT]: { intensity: 0.4, radius: 3, color: '#8888ff' },
        [MOLTEN_SLAG]: { intensity: 0.8, radius: 6, color: '#ff4500' }
      };
      
      // Scan the grid for light sources
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          
          // Check if this element is a light emitter
          if (lightEmitters[element]) {
            const emitter = lightEmitters[element];
            
            // Get temperature for intensity variation
            const temperature = temp[y][x] || 20;
            let intensityMod = 1.0;
            
            // Increase intensity with temperature for fire elements
            if ([FIRE, BURNING_WOOD, BURNING_LEAVES, BURNING_ORGANIC, BURNING_COAL, BURNING_COAL_LUMP, BURNING_THERMITE].includes(element)) {
              intensityMod = Math.min(1.0 + (temperature - 500) / 1000, 2.0);
            }
            
            // Add to light sources
            window.lightSources.push({
              x: x,
              y: y,
              intensity: emitter.intensity * intensityMod,
              radius: emitter.radius,
              color: emitter.color
            });
          }
        }
      }
    }
    
    // Render the lighting effects
function renderLighting() {
  // Only continue if DSPLE is enabled
  if (!window.isDspleEnabled || !lightingContext) {
    return;
  }
  
  // Identify light sources
  identifyLightSources();
  
  // Skip rendering if no light sources are present
  if (window.lightSources.length === 0) {
    // Just clear the canvas and return
    lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
    return;
  }
  
  // Clear the canvas
  lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
  
  // Calculate cell size
  const cellSize = lightingCanvas.width / GRID_SIZE;
  
  // Performance optimization: Only create light map in areas that need it
  // First, determine the bounds of all light effects
  let minX = GRID_SIZE, minY = GRID_SIZE, maxX = 0, maxY = 0;
  
  // Calculate the maximum light radius across all sources
  let maxRadius = 0;
  
  // Cache parsed colors to avoid repeated parsing
  const parsedColors = new Map();
  
  // Pre-calculate light bounds
  for (const source of window.lightSources) {
    const radius = Math.ceil(source.radius);
    if (radius > maxRadius) maxRadius = radius;
    
    // Update bounds
    minX = Math.max(0, Math.min(minX, source.x - radius));
    minY = Math.max(0, Math.min(minY, source.y - radius));
    maxX = Math.min(GRID_SIZE - 1, Math.max(maxX, source.x + radius));
    maxY = Math.min(GRID_SIZE - 1, Math.max(maxY, source.y + radius));
    
    // Parse and cache colors
    if (!parsedColors.has(source.color)) {
      let r, g, b;
      if (source.color.startsWith('#')) {
        const hex = source.color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
      } else {
        // Default to orange if color format is unknown
        r = 255;
        g = 165;
        b = 0;
      }
      parsedColors.set(source.color, {r, g, b});
    }
  }
  
  // If bounds are invalid, no lighting is needed
  if (minX > maxX || minY > maxY) {
    return;
  }
  
  // Only allocate arrays for the affected area, not the entire grid
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  
  // Reuse arrays if possible to avoid garbage collection
  if (!window.currentLightMap || window.currentLightMap.length !== height || window.currentLightMap[0].length !== width) {
    window.currentLightMap = Array(height).fill().map(() => Array(width).fill(null));
  } else {
    // Clear existing array
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        window.currentLightMap[y][x] = null;
      }
    }
  }
  
  // For each light source, calculate its contribution to each cell
  for (const source of window.lightSources) {
    // Get parsed color
    const {r, g, b} = parsedColors.get(source.color);
    
    // Calculate the light's influence area
    const radius = Math.ceil(source.radius);
    // Reduce intensity by 40% to make lighting less intense
    const intensity = source.intensity * 0.6;
    
    // Calculate light source position relative to the light map bounds
    const relSourceX = source.x - minX;
    const relSourceY = source.y - minY;
    
    // Loop through cells in the influence area (relative to light map)
    const startX = Math.max(0, relSourceX - radius);
    const startY = Math.max(0, relSourceY - radius);
    const endX = Math.min(width - 1, relSourceX + radius);
    const endY = Math.min(height - 1, relSourceY + radius);
    
    // Optimization: Pre-calculate distance squared to avoid sqrt
    const radiusSquared = radius * radius;
    
    for (let y = startY; y <= endY; y++) {
      for (let x = startX; x <= endX; x++) {
        // Calculate distance squared (avoiding sqrt for performance)
        const dx = x - relSourceX;
        const dy = y - relSourceY;
        const distanceSquared = dx*dx + dy*dy;
        
        // Skip if outside the radius
        if (distanceSquared > radiusSquared) continue;
        
        // Use sqrt only when needed
        const distance = Math.sqrt(distanceSquared);
        
        // More efficient falloff calculation
        const falloff = Math.pow(1 - Math.min(distance / radius, 1), 2);
        const cellIntensity = intensity * falloff;
        
        // Initialize the cell's light value if needed
        if (!window.currentLightMap[y][x]) {
          window.currentLightMap[y][x] = { r: 0, g: 0, b: 0, a: 0 };
        }
        
        // Add this light's contribution (additive blending)
        const cell = window.currentLightMap[y][x];
        cell.r += r * cellIntensity;
        cell.g += g * cellIntensity;
        cell.b += b * cellIntensity;
        cell.a = Math.min(cell.a + cellIntensity * 0.3, 0.7); // Reduced alpha cap
      }
    }
  }
  
  // Skip transition calculations if this is the first frame
  if (!previousLightMap) {
    // First frame - use currentLightMap directly
    previousLightMap = window.currentLightMap;
  } else {
    // Performance improvement: Do transitions only where needed
    const transitionSpeed = 0.2; // Lower = slower transitions
    
    // Reuse finalLightMap array if possible
    if (!window.finalLightMap || window.finalLightMap.length !== height || window.finalLightMap[0].length !== width) {
      window.finalLightMap = Array(height).fill().map(() => Array(width).fill(null));
    } else {
      // Clear existing array
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          window.finalLightMap[y][x] = null;
        }
      }
    }
    
    // Apply transitions only to cells that need it
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const current = window.currentLightMap[y][x];
        // Get previous value from the equivalent position
        const previousX = x + minX - window.prevMinX;
        const previousY = y + minY - window.prevMinY;
        
        let previous = null;
        if (window.prevFinalLightMap && 
            previousX >= 0 && previousX < window.prevFinalLightMap[0].length && 
            previousY >= 0 && previousY < window.prevFinalLightMap.length) {
          previous = window.prevFinalLightMap[previousY][previousX];
        }
        
        // Skip if no light in current or previous frame
        if (!current && !previous) continue;
        
        // Initialize final light map cell
        window.finalLightMap[y][x] = { r: 0, g: 0, b: 0, a: 0 };
        
        // Apply transition
        if (current) {
          if (previous) {
            // Blend with previous frame for smooth transition
            window.finalLightMap[y][x].r = previous.r + (current.r - previous.r) * transitionSpeed;
            window.finalLightMap[y][x].g = previous.g + (current.g - previous.g) * transitionSpeed;
            window.finalLightMap[y][x].b = previous.b + (current.b - previous.b) * transitionSpeed;
            window.finalLightMap[y][x].a = previous.a + (current.a - previous.a) * transitionSpeed;
          } else {
            // Fade in new light
            window.finalLightMap[y][x].r = current.r * transitionSpeed;
            window.finalLightMap[y][x].g = current.g * transitionSpeed;
            window.finalLightMap[y][x].b = current.b * transitionSpeed;
            window.finalLightMap[y][x].a = current.a * transitionSpeed;
          }
        } else if (previous) {
          // Fade out disappearing light
          window.finalLightMap[y][x].r = previous.r * (1 - transitionSpeed);
          window.finalLightMap[y][x].g = previous.g * (1 - transitionSpeed);
          window.finalLightMap[y][x].b = previous.b * (1 - transitionSpeed);
          window.finalLightMap[y][x].a = previous.a * (1 - transitionSpeed);
        }
      }
    }
    
    // Store the current light map data for the next frame
    window.prevFinalLightMap = window.finalLightMap;
    window.prevMinX = minX;
    window.prevMinY = minY;
  }
      
      // Render the final light map to the canvas
  lightingContext.globalCompositeOperation = 'lighter';
  
  // Clear the canvas with a fully transparent background
  lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
  
  // Performance optimization: Only use gradients for larger light sources
  // For smaller lights, use simple rects which are much faster to render
  const useGradientThreshold = Math.ceil(maxRadius / 2); // Only use gradients for larger lights
  
  // Calculate actual pixel size for rendering
  const pixelSize = Math.ceil(cellSize);
  
  // Then draw each lit cell
  const lightMap = window.finalLightMap || window.currentLightMap;
  
  // Draw batches of lights with the same color for better performance
  const batchedLights = new Map(); // Map of color string to array of cells
  
  // Collect lights into batches by color
  for (let y = 0; y < lightMap.length; y++) {
    for (let x = 0; x < lightMap[0].length; x++) {
      const light = lightMap[y][x];
      if (!light || (light.r === 0 && light.g === 0 && light.b === 0) || light.a === 0) continue;
      
      // Create a key for this color
      const colorKey = `rgba(${Math.min(255, Math.round(light.r))}, ${Math.min(255, Math.round(light.g))}, ${Math.min(255, Math.round(light.b))}, ${light.a.toFixed(2)})`;
      
      if (!batchedLights.has(colorKey)) {
        batchedLights.set(colorKey, []);
      }
      
      // Convert to absolute grid coordinates
      const absX = x + (window.prevMinX || minX);
      const absY = y + (window.prevMinY || minY);
      
      batchedLights.get(colorKey).push({ x: absX, y: absY, intensity: Math.max(light.r, light.g, light.b) / 255 });
    }
  }
  
  // Draw each batch with a single fill style
  for (const [colorKey, cells] of batchedLights.entries()) {
    lightingContext.fillStyle = colorKey;
    
    // Draw all cells in this batch
    for (const cell of cells) {
      const pixelX = Math.floor(cell.x * cellSize);
      const pixelY = Math.floor(cell.y * cellSize);
      
      // For performance, only use gradients for bright lights
      if (cell.intensity > 0.5 && maxRadius > useGradientThreshold) {
        // Create gradient for smoother light appearance
        const gradient = lightingContext.createRadialGradient(
          pixelX + cellSize/2, pixelY + cellSize/2, 0,
          pixelX + cellSize/2, pixelY + cellSize/2, cellSize * 1.2
        );
        
        // Parse color for gradient
        const rgbaMatch = colorKey.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (rgbaMatch) {
          const [_, r, g, b, a] = rgbaMatch;
          
          // Inner color (full intensity)
          gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${a})`);
          // Outer color (fade to transparent)
          gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
          
          lightingContext.fillStyle = gradient;
          lightingContext.fillRect(pixelX - cellSize/2, pixelY - cellSize/2, cellSize * 2, cellSize * 2);
        }
      } else {
        // Use simple rect for better performance
        lightingContext.fillRect(pixelX, pixelY, pixelSize, pixelSize);
      }
    }
  }
  
  // Continue the animation loop
  lightingAnimationFrame = requestAnimationFrame(renderLighting);
    }
    
    // Function to reassign color variations to all cells
    function reassignColorVariations() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] !== EMPTY) {
            // Initialize color variation for this element
            const variation = 0.05;
            colorVariations[y][x] = {
              r: 1 + (Math.random() * variation * 2 - variation),
              g: 1 + (Math.random() * variation * 2 - variation),
              b: 1 + (Math.random() * variation * 2 - variation)
            };
          }
        }
      }
      renderGrid(); // Re-render the grid with new variations
    }
    
    // Function to initialize the grid based on GRID_SIZE.
    function initGrid(newSize) {
      GRID_SIZE = newSize;
      
      // Clear grid container
      gridContainer.innerHTML = "";
      
      // Create canvas for rendering
      const canvas = document.createElement('canvas');
      canvas.id = 'sandboxCanvas';
      gridContainer.appendChild(canvas);
      gridContainer.appendChild(hoverOverlay);
      
      // Size the canvas to fill the grid container
      const resizeCanvas = () => {
        const containerWidth = gridContainer.clientWidth;
        const containerHeight = gridContainer.clientHeight;
        canvas.width = containerWidth;
        canvas.height = containerHeight;
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerHeight + 'px';
        // Store the cell size for coordinate conversions
        window.cellSize = containerWidth / GRID_SIZE;
      };
      
      // Make resizeCanvas globally accessible for tab switching
      window.resizeCanvas = resizeCanvas;
      
      // Initial sizing
      resizeCanvas();
      
      // Add resize listener
      window.addEventListener('resize', resizeCanvas);
      
      // Store canvas and context for rendering
      window.sandboxCanvas = canvas;
      window.ctx = canvas.getContext('2d');
      
      // Reset all arrays
      grid = [];
      temp = [];
      moved = [];
      vaporLife = [];
      cloudLife = [];
      fireLife = [];
      smokeLife = [];
      burningWoodTime = [];
      wheatHeight = [];
      wheatMaxHeight = [];
      seedGrowthTime = [];
      rootLife = [];
      sparkLife = [];
      sparkTimer = [];
      smokeMaxLife = [];
      cloudMaxLife = [];
      branchLevel = [];
      branchLen = [];
      branchMaxArr = [];
      branchSubCount = [];
      branchDirX = [];
      branchDirY = [];
      oakTreeGrowthTime = [];
      oakTreeHeight = [];
      oakTreeMaxHeight = [];
      oakTreeRootTimer = [];
      oakTreeRootDepth = [];
      oakTreeRootMax = [];
      grassStage = [];
      burningGasTime = [];
      chargedStateTime = [];
      
      // Reset physics arrays
      ballVelocityX = [];
      ballVelocityY = [];
      ballSoundCooldown = [];
      
      // Reset color variations
      colorVariations = [];
      
      // Reset lighting arrays
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Initialize bird arrays
      birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
      birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      
      // Initialize cellsDirty array for tracking cells that need rendering
      cellsDirty = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));

      // Initialize empty cells array - will be used as a compatibility layer
      // Reset cells instead of reassigning to avoid 'Assignment to constant variable' error
      cells.length = 0;
      
      for (let y = 0; y < GRID_SIZE; y++) {
        let row = [], trow = [], mrow = [];
        let vrow = [], crow = [], frow = [], srow = [], bwrow = [];
        let wH = [], wMH = [], sGT = [], rLifeRow = [];
        let spLifeRow = [], spTimerRow = [];
        let smaxrow = [], cmaxrow = [];
        let bLevel = [], bLen = [], bMax = [], bSub = [], bDirXrow = [], bDirYrow = [];
        let otGrowth = [], otHeight = [], otMaxHeight = [];
        let otRootTimer = [], otRootDepth = [], otRootMax = [];
        let grassRow = [];
        let burnGasRow = [];
        let cdtRow = [];
        let bVelX = [], bVelY = [];
        let bSoundCooldown = [];
        let colorVarRow = [];
        // New element arrays
                let photonLifeRow = [], photonDirXRow = [], photonDirYRow = [], photonEnergyRow = [], photonColorRow = [];
        let photonBouncesRow = [];
        let photonUnderlyingRow = [], photonUnderlyingTempRow = [];
        let lightningLifeRow = [];
        let lightningTrailLifeRow = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          row.push(EMPTY);
          trow.push(null);
          mrow.push(false);
          vrow.push(0);
          crow.push(0);
          frow.push(0);
          srow.push(0);
          bwrow.push(0);
          wH.push(0);
          wMH.push(0);
          sGT.push(0);
          rLifeRow.push(0);
          spLifeRow.push(0);
          spTimerRow.push(0);
          smaxrow.push(1.0 + 2.0 * Math.random());
          cmaxrow.push(5.0 + 5.0 * Math.random());
          bLevel.push(-1);
          bLen.push(0);
          bMax.push(0);
          bSub.push(-1);
          bDirXrow.push(0);
          bDirYrow.push(0);
          otGrowth.push(0);
          otHeight.push(0);
          otMaxHeight.push(0);
          otRootTimer.push(0);
          otRootDepth.push(0);
          otRootMax.push(0);
          grassRow.push(1);
          burnGasRow.push(0);
          cdtRow.push(0);
          bVelX.push(0);
          bVelY.push(0);
          bSoundCooldown.push(0);
          colorVarRow.push(null);
          // New element arrays
          photonLifeRow.push(0);
          photonDirXRow.push(0);
          photonDirYRow.push(0);
          photonEnergyRow.push(100);
          photonColorRow.push('#ffffff');
          photonBouncesRow.push(0);
          photonUnderlyingRow.push(null);
          photonUnderlyingTempRow.push(null);
          lightningLifeRow.push(0);
          lightningTrailLifeRow.push(0);
        }
        grid.push(row);
        temp.push(trow);
        moved.push(mrow);
        vaporLife.push(vrow);
        cloudLife.push(crow);
        fireLife.push(frow);
        smokeLife.push(srow);
        burningWoodTime.push(bwrow);
        wheatHeight.push(wH);
        wheatMaxHeight.push(wMH);
        seedGrowthTime.push(sGT);
        rootLife.push(rLifeRow);
        sparkLife.push(spLifeRow);
        sparkTimer.push(spTimerRow);
        smokeMaxLife.push(smaxrow);
        cloudMaxLife.push(cmaxrow);
        branchLevel.push(bLevel);
        branchLen.push(bLen);
        branchMaxArr.push(bMax);
        branchSubCount.push(bSub);
        branchDirX.push(bDirXrow);
        branchDirY.push(bDirYrow);
        oakTreeGrowthTime.push(otGrowth);
        oakTreeHeight.push(otHeight);
        oakTreeMaxHeight.push(otMaxHeight);
        oakTreeRootTimer.push(otRootTimer);
        oakTreeRootDepth.push(otRootDepth);
        oakTreeRootMax.push(otRootMax);
        grassStage.push(grassRow);
        burningGasTime.push(burnGasRow);
        chargedStateTime.push(cdtRow);
        ballVelocityX.push(bVelX);
        ballVelocityY.push(bVelY);
        ballSoundCooldown.push(bSoundCooldown);
        colorVariations.push(colorVarRow);
        // New element arrays
        photonLife.push(photonLifeRow);
        photonDirX.push(photonDirXRow);
        photonDirY.push(photonDirYRow);
        photonEnergy.push(photonEnergyRow);
        photonColor.push(photonColorRow);
        photonBounces.push(photonBouncesRow);
        photonUnderlying.push(photonUnderlyingRow);
        photonUnderlyingTemp.push(photonUnderlyingTempRow);
        lightningLife.push(lightningLifeRow);
        lightningTrailLife.push(lightningTrailLifeRow);
        
        // Create virtual cells array for compatibility with existing code
        let rowOfCells = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          // Create a virtual cell object that mimics the DOM element API
          // This maintains compatibility with existing code that uses cells[y][x]
          const virtualCell = {
            style: {
              backgroundColor: '',
              opacity: ''
            },
            classList: {
              add: function(className) {
                this._className = className;
              },
              remove: function(className) {
                if (this._className === className) {
                  this._className = '';
                }
              },
              contains: function(className) {
                return this._className === className;
              }
            },
            _className: '',
            id: `cell-${x}-${y}`
          };
          rowOfCells.push(virtualCell);
        }
        cells.push(rowOfCells);
      }
      
      // Reinitialize lighting arrays when grid size changes
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Initialize dirtyGrid to mark all cells as needing rendering
      dirtyGrid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(true));
      
      // Reinitialize the reusable arrays for position shuffling
      reusablePositions.length = 0;
      reusableXPositions.length = 0;
      for (let i = 0; i < GRID_SIZE; i++) {
        reusablePositions.push(i);
        reusableXPositions.push(i);
      }
    }
    /***************************************
     * DOM
     ***************************************/
    const gridContainer = document.getElementById('grid');
    const hoverOverlay = document.getElementById('hoverOverlay');
    const toolElements = document.getElementsByClassName('tool');
    const speedSlider = document.getElementById('speed');
    const speedValueDisplay = document.getElementById('speedValue');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const hudTemp = document.getElementById('hudTemp');
    const hudElem = document.getElementById('hudElem');
    const hudFPS = document.getElementById('hudFPS');
    const toolSearch = document.getElementById('toolSearch');
    const toolbar = document.getElementById('toolbar');
    const categoryButtons = document.querySelectorAll('#categoryMenu button');
    const sortOrder = document.getElementById('sortOrder');
    let activeCategory = 'all';
    
    // Store the original order of tools for 'Natural' sort
    let originalToolsOrder = [];
    
    // Function to sort tools
    function sortTools() {
      const tools = Array.from(document.querySelectorAll('.tool'));
      const eraser = tools.find(tool => tool.dataset.tool === 'eraser');
      let otherTools = tools.filter(tool => tool !== eraser);
      
      // Store original order on first sort
      if (originalToolsOrder.length === 0) {
        originalToolsOrder = [...otherTools];
      }
      
      // Sort based on selected option
      const sortBy = sortOrder.value;
      
      if (sortBy === 'alpha') {
        otherTools.sort((a, b) => {
          return a.getAttribute('title').localeCompare(b.getAttribute('title'));
        });
      } else if (sortBy === 'type') {
        const categoryOrder = {
          'tools': 1,
          'liquids': 2,
          'powders': 3,
          'solids': 4,
          'gasses': 5,
          'explosives': 6,
          'life': 7,
          'cooking': 8,
          'electricity': 9,
          'special': 10
        };
        
        otherTools.sort((a, b) => {
          const catA = a.dataset.cat.split(',')[0]; // Get primary category
          const catB = b.dataset.cat.split(',')[0];
          return (categoryOrder[catA] || 99) - (categoryOrder[catB] || 99) || 
                 a.getAttribute('title').localeCompare(b.getAttribute('title'));
        });
      } else if (sortBy === 'natural') {
        // Restore original order
        otherTools = [...originalToolsOrder];
      }
      
      // Rebuild toolbar with sorted elements (keep eraser first)
      toolbar.innerHTML = '';
      if (eraser) toolbar.appendChild(eraser);
      otherTools.forEach(tool => toolbar.appendChild(tool));
      
      // Reattach event listeners
      document.querySelectorAll('.tool').forEach(el => {
        el.addEventListener('click', () => selectTool(el));
      });
    }
    
    // Add event listeners for sorting
    if (sortOrder) {
      sortOrder.addEventListener('change', sortTools);
      // Initial sort
      sortTools();
    }
    const cells = [];
    // The initGrid function will create the cells.
    initGrid(75); // Default stage size 75x75
    let currentTool = SAND;
    
    // Function to get element color for notification
    function getElementColor(elementType) {
      const colorMap = {
        [SAND]: '#f4a460',
        [WALL]: '#666666',
        [WATER]: '#1e7fdf',
        [SALT_WATER]: '#3aafff',
        [LAVA]: '#ff4500',
        [STONE]: '#808080',
        [WATER_VAPOR]: '#e0e0e0',
        [CLOUD]: '#ffffff',
        [HELIUM]: '#e6f7ff',
        [ERASER]: 'pink',
        [COPPER]: '#b87333',
        [STEEL]: '#aaaaaa',
        [ICE]: '#cceeff',
        [WOOD]: '#3B220E',
        [FIRE]: '#ffcc00',
        [SMOKE]: '#666666',
        [BURNING_WOOD]: '#5a3310',
        [ASH]: '#444444',
        [GLASS]: '#c2e9fb',
        [BOMB]: '#006400',
        [DIRT]: '#7B5E42',
        [WET_DIRT]: '#4d2e12',
        [WHEAT_SEEDS]: '#bca136',
        [WHEAT]: '#c2b280',
        [FLOUR]: '#f5f5dc',
        [DOUGH]: '#d2b48c',
        [BREAD]: '#f4c986',
        [BURNING_ORGANIC]: '#6a3400',
        [ROOT]: '#4a3a2f',
        [SPARK]: '#ffdd00',
        [CHARGED_COPPER]: '#ff8c00',
        [CHARGED_DOWN_COPPER]: '#cc6600',
        [OAK_SEEDS]: '#32CD32',
        [OAK_LEAVES]: '#228B22',
        [OAK_BABY_LEAVES]: '#66bb6a',
        [DEAD_OAK]: '#777777',
        [WET_SAND]: '#d2a679',
        [GRASS]: '#00aa00',
        [DEAD_PLANT]: '#555555',
        [BURNING_LEAVES]: '#a0522d',
        [BURNING_ROOT]: '#ff4500',
        [DEAD_ROOT]: '#555555',
        [GAS]: '#c8c8c8',
        [BURNING_GAS]: '#ff6666',
        [ACID]: '#90EE90',
        [ACID_STEAM]: '#98FB98',
        [ACID_CLOUD]: '#98FB98',
        [SLIME]: '#006400',
        [CARBON_DIOXIDE]: '#808080',
        [OXYGEN]: '#c8e6ff',
        [BIRD]: '#B8860B',
        [MEAT]: '#FF6B6B',
        [COOKED_MEAT]: '#8B4513',
        [COBBLESTONE]: '#808080',
        [OIL]: '#2F4F4F',
        [COOLER]: '#3399ff',
        [HEATER]: '#ff3333',
        [HEAT_SEPARATOR]: '#ffef96',
        [CHARGED_HEAT_SEPARATOR]: '#ffe033',
        [CHARGED_DOWN_HEAT_SEPARATOR]: '#ffd700',
        [INPUT]: '#646464',
        [CHARGED_INPUT]: '#ffff77',
        [OUTPUT]: '#3636ff',
        [CHARGED_OUTPUT]: '#8888ff',
        [NOT_GATE]: '#a15050',
        [AND_GATE]: '#405050',
        [BLOCKER]: '#856fa8',
        [CHARGED_BLOCKER]: '#9b50a3',
        [CLONER]: '#cc00cc',
        [COAL]: '#202020',
        [COAL_LUMP]: '#303030',
        [BURNING_COAL]: '#520f0f',
        [BURNING_COAL_LUMP]: '#812626',
        [THERMITE]: '#AA4444',
        [BIG_BOMB]: '#ff3333',
        [WATER_BOMB]: '#3366ff',
        [FIRE_BOMB]: '#ff6600',
        [CRYO_BOMB]: '#00ccff',
        [NUKE_BOMB]: '#33cc33',
        [BOUNCY_BALL]: '#ff5599',
        [BIRCH_SEEDS]: '#8cff9b',
        [CELL]: '#00ff99',
        [BLOOD]: '#cc0000',
        [GLASS_SHARD]: '#aaddff',
        [SAWDUST]: '#d9c29e',
        [SALT]: '#ffffff',
        [GLUE]: '#dfdfdf',
        [SUGAR]: '#ffffff',
        [SUGAR_WATER]: '#add8e6',
        [PLANT]: '#2e8b57',
        [DIAMOND]: '#b9f2ff',
        [DIAMOND_SHARDS]: '#a7e0ed',
        [MOLTEN_DIAMOND]: '#ff93a8',
        [CONFETTI]: '#ff6b6b',
        [DABICCO]: '#ff0000',
        [OXIDIZED_COPPER]: '#4fa889',
        [MOLTEN_COPPER]: '#ff7f00',
        [MOLTEN_SALT]: '#ffbbaa',
        [MOLTEN_STEEL]: '#ff6666',
        [MOLTEN_SUGAR]: '#884411',
        [MOLTEN_GLASS]: '#ffaa77',
        [INSULATOR]: '#ffe4b5',
        [PHOTON]: '#ffffff',
        [LIGHTNING]: '#ffd700',
        [LIGHTNING_TRAIL]: '#ffd700',
        [DENSE_CLOUD]: '#d3d3d3'
      };
      
      // Check if it's a custom element
      if (elementType >= CUSTOM_ELEMENT_START && customElements[elementType]) {
        return customElements[elementType].color;
      }
      
      return colorMap[elementType] || '#cccccc';
    }
    
    function selectTool(el) {
      Array.from(toolElements).forEach(t => t.classList.remove('selected'));
      el.classList.add('selected');
      const name = el.getAttribute('data-tool');
      
      // Show element notification with color
      const selectedElementNotification = document.getElementById('selectedElementNotification');
      if (selectedElementNotification) {
        const elementName = selectedElementNotification.querySelector('.element-name');
        const elementColor = selectedElementNotification.querySelector('.element-color');
        
        if (elementName && elementColor) {
          // Set element name
          elementName.textContent = el.getAttribute('title') || name;
          
          // Set element color based on tool name
          let toolElementType = null;
          switch (name) {
            case "eraser": toolElementType = ERASER; break;
            case "sand": toolElementType = SAND; break;
            case "wall": toolElementType = WALL; break;
            case "water": toolElementType = WATER; break;
            case "snow": toolElementType = SNOW; break;
            case "lava": toolElementType = LAVA; break;
            case "stone": toolElementType = STONE; break;
            case "water-vapor": toolElementType = WATER_VAPOR; break;
            case "copper": toolElementType = COPPER; break;
            case "steel": toolElementType = STEEL; break;
            case "ice": toolElementType = ICE; break;
            case "wood": toolElementType = WOOD; break;
            case "fire": toolElementType = FIRE; break;
            case "smoke": toolElementType = SMOKE; break;
            case "ash": toolElementType = ASH; break;
            case "glass": toolElementType = GLASS; break;
            case "bomb": toolElementType = BOMB; break;
            case "dirt": toolElementType = DIRT; break;
            case "wet-dirt": toolElementType = WET_DIRT; break;
            case "wheat-seeds": toolElementType = WHEAT_SEEDS; break;
            case "flour": toolElementType = FLOUR; break;
            case "dough": toolElementType = DOUGH; break;
            case "bread": toolElementType = BREAD; break;
            case "plant-root": toolElementType = ROOT; break;
            case "spark": toolElementType = SPARK; break;
            case "oak-seeds": toolElementType = OAK_SEEDS; break;
            case "grass": toolElementType = GRASS; break;
            case "gas": toolElementType = GAS; break;
            case "cooler": toolElementType = COOLER; break;
            case "heater": toolElementType = HEATER; break;
            case "heat-separator": toolElementType = HEAT_SEPARATOR; break;
            case "input": toolElementType = INPUT; break;
            case "output": toolElementType = OUTPUT; break;
            case "not-gate": toolElementType = NOT_GATE; break;
            case "and-gate": toolElementType = AND_GATE; break;
            case "blocker": toolElementType = BLOCKER; break;
            case "cloner": toolElementType = CLONER; break;
            case "coal": toolElementType = COAL; break;
            case "coal-lump": toolElementType = COAL_LUMP; break;
            case "thermite": toolElementType = THERMITE; break;
            case "acid": toolElementType = ACID; break;
            case "slime": toolElementType = SLIME; break;
            case "carbon-dioxide": toolElementType = CARBON_DIOXIDE; break;
            case "oxygen": toolElementType = OXYGEN; break;
            case "bird": toolElementType = BIRD; break;
            case "meat": toolElementType = MEAT; break;
            case "cooked-meat": toolElementType = COOKED_MEAT; break;
            case "cobblestone": toolElementType = COBBLESTONE; break;
            case "oil": toolElementType = OIL; break;
            case "big-bomb": toolElementType = BIG_BOMB; break;
            case "water-bomb": toolElementType = WATER_BOMB; break;
            case "fire-bomb": toolElementType = FIRE_BOMB; break;
            case "cryo-bomb": toolElementType = CRYO_BOMB; break;
            case "nuke-bomb": toolElementType = NUKE_BOMB; break;
            case "helium": toolElementType = HELIUM; break;
            case "bouncy-ball": toolElementType = BOUNCY_BALL; break;
            case "birch-seeds": toolElementType = BIRCH_SEEDS; break;
            case "cell": toolElementType = CELL; break;
            case "blood": toolElementType = BLOOD; break;
            case "glass-shard": toolElementType = GLASS_SHARD; break;
            case "sawdust": toolElementType = SAWDUST; break;
            case "salt": toolElementType = SALT; break;
            case "salt-water": toolElementType = SALT_WATER; break;
            case "glue": toolElementType = GLUE; break;
            case "sugar": toolElementType = SUGAR; break;
            case "sugar-water": toolElementType = SUGAR_WATER; break;
            case "plant": toolElementType = PLANT; break;
            case "diamond": toolElementType = DIAMOND; break;
            case "diamond-shards": toolElementType = DIAMOND_SHARDS; break;
            case "molten-diamond": toolElementType = MOLTEN_DIAMOND; break;
            case "confetti": toolElementType = CONFETTI; break;
            case "dabicco": toolElementType = DABICCO; break;
            case "oxidized-copper": toolElementType = OXIDIZED_COPPER; break;
            case "molten-copper": toolElementType = MOLTEN_COPPER; break;
            case "molten-salt": toolElementType = MOLTEN_SALT; break;
            case "molten-steel": toolElementType = MOLTEN_STEEL; break;
            case "molten-sugar": toolElementType = MOLTEN_SUGAR; break;
            case "molten-glass": toolElementType = MOLTEN_GLASS; break;
            case "insulator": toolElementType = INSULATOR; break;
            case "photon": toolElementType = PHOTON; break;
            case "lightning": toolElementType = LIGHTNING; break;
            case "dense-cloud": toolElementType = DENSE_CLOUD; break;
          }
          
          if (toolElementType !== null) {
            elementColor.style.backgroundColor = getElementColor(toolElementType);
          }
        }
        
        // Make it visible
        selectedElementNotification.classList.add('visible');
        
        // Hide after 3 seconds
        setTimeout(() => {
          selectedElementNotification.classList.remove('visible');
        }, 3000);
      }
      switch (name) {
        case "eraser": currentTool = ERASER; break;
        case "sand": currentTool = SAND; break;
        case "wall": currentTool = WALL; break;
        case "water": currentTool = WATER; break;
        case "snow": currentTool = SNOW; break;
        case "lava": currentTool = LAVA; break;
        case "stone": currentTool = STONE; break;
        case "water-vapor": currentTool = WATER_VAPOR; break;
        case "copper": currentTool = COPPER; break;
        case "steel": currentTool = STEEL; break;
        case "ice": currentTool = ICE; break;
        case "wood": currentTool = WOOD; break;
        case "fire": currentTool = FIRE; break;
        case "smoke": currentTool = SMOKE; break;
        case "ash": currentTool = ASH; break;
        case "glass": currentTool = GLASS; break;
        case "bomb": currentTool = BOMB; break;
        case "dirt": currentTool = DIRT; break;
        case "wet-dirt": currentTool = WET_DIRT; break;
        case "wheat-seeds": currentTool = WHEAT_SEEDS; break;
        case "flour": currentTool = FLOUR; break;
        case "dough": currentTool = DOUGH; break;
        case "bread": currentTool = BREAD; break;
        case "plant-root": currentTool = ROOT; break;
        case "spark": currentTool = SPARK; break;
        case "oak-seeds": currentTool = OAK_SEEDS; break;
        case "grass": currentTool = GRASS; break;
        case "gas": currentTool = GAS; break;
        case "cooler": currentTool = COOLER; break;
        case "heater": currentTool = HEATER; break;
        case "heat-separator": currentTool = HEAT_SEPARATOR; break;
        case "input": currentTool = INPUT; break;
        case "output": currentTool = OUTPUT; break;
        case "not-gate": currentTool = NOT_GATE; break;
        case "and-gate": currentTool = AND_GATE; break;
        case "blocker": currentTool = BLOCKER; break;
        case "cloner": currentTool = CLONER; break;
        case "coal": currentTool = COAL; break;
        case "coal-lump": currentTool = COAL_LUMP; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "heat": currentTool = TOOL_HEAT; break;
        case "cool": currentTool = TOOL_COOL; break;
        case "cook": currentTool = TOOL_COOK; break;
        case "mix": currentTool = TOOL_MIX; break;
        case "move": currentTool = TOOL_MOVE; break;
        case "sponge": currentTool = TOOL_SPONGE; break;
        case "extinguish": currentTool = TOOL_EXTINGUISH; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "carbon-dioxide": currentTool = CARBON_DIOXIDE; break;
        case "oxygen": currentTool = OXYGEN; break;
        case "bird": currentTool = BIRD; break;
        case "meat": currentTool = MEAT; break;
        case "cooked-meat": currentTool = COOKED_MEAT; break;
        case "cobblestone": currentTool = COBBLESTONE; break;
        case "oil": currentTool = OIL; break;
        case "big-bomb": currentTool = BIG_BOMB; break;
        case "water-bomb": currentTool = WATER_BOMB; break;
        case "fire-bomb": currentTool = FIRE_BOMB; break;
        case "cryo-bomb": currentTool = CRYO_BOMB; break;
        case "nuke-bomb": currentTool = NUKE_BOMB; break;
        case "helium": currentTool = HELIUM; break;
        case "bouncy-ball": currentTool = BOUNCY_BALL; break;
        case "birch-seeds": currentTool = BIRCH_SEEDS; break;
        case "cell": currentTool = CELL; break;
        case "blood": currentTool = BLOOD; break;
        case "glass-shard": currentTool = GLASS_SHARD; break;
        case "sawdust": currentTool = SAWDUST; break;
        case "grind": currentTool = TOOL_GRIND; break;
        case "salt": currentTool = SALT; break;
        case "salt-water": currentTool = SALT_WATER; break;
        case "glue": currentTool = GLUE; break;
        case "sugar": currentTool = SUGAR; break;
        case "sugar-water": currentTool = SUGAR_WATER; break;
        case "plant": currentTool = PLANT; break;
        case "diamond": currentTool = DIAMOND; break;
        case "diamond-shards": currentTool = DIAMOND_SHARDS; break;
        case "molten-diamond": currentTool = MOLTEN_DIAMOND; break;
        case "confetti": currentTool = CONFETTI; break;
        case "dabicco": currentTool = DABICCO; break;
        case "oxidized-copper": currentTool = OXIDIZED_COPPER; break;
        case "molten-copper": currentTool = MOLTEN_COPPER; break;
        case "molten-salt": currentTool = MOLTEN_SALT; break;
        case "molten-steel": currentTool = MOLTEN_STEEL; break;
        case "molten-sugar": currentTool = MOLTEN_SUGAR; break;
        case "molten-glass": currentTool = MOLTEN_GLASS; break;
        case "insulator": currentTool = INSULATOR; break;
        case "photon": currentTool = PHOTON; break;
        case "lightning": currentTool = LIGHTNING; break;
        case "dense-cloud": currentTool = DENSE_CLOUD; break;
      }
    }
    Array.from(toolElements).forEach(el => { el.addEventListener('click', () => selectTool(el)); });
    speedSlider.addEventListener('input', e => { speed = parseFloat(e.target.value); speedValueDisplay.textContent = speed.toFixed(2); });
    clearAllBtn.addEventListener('click', () => { for (let y = 0; y < GRID_SIZE; y++) { for (let x = 0; x < GRID_SIZE; x++) { eraseCell(x, y); } } });
    let isLeftMouseDown = false, isRightMouseDown = false;
    let hoveredX = null, hoveredY = null;
    let isTouching = false;
    let touchX = null, touchY = null;
    
    // Touch event handlers
    gridContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isTouching = true;
        const touch = e.touches[0];
        const pos = getMousePos(touch);
        touchX = pos.x;
        touchY = pos.y;
        hoveredX = pos.x;
        hoveredY = pos.y;
        
        // Handle touch as left click
        onMouseDown(e);
        placeElementAt(pos.x, pos.y, currentTool);
    });

    gridContainer.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isTouching) return;
        const touch = e.touches[0];
        const pos = getMousePos(touch);
        touchX = pos.x;
        touchY = pos.y;
        hoveredX = pos.x;
        hoveredY = pos.y;
        updateHoverOverlay();
        placeElementAt(pos.x, pos.y, currentTool);
    });

    gridContainer.addEventListener('touchend', (e) => {
        e.preventDefault();
        isTouching = false;
        touchX = null;
        touchY = null;
        hoveredX = null;
        hoveredY = null;
        onMouseUp(e);
    });

    // Override getMousePos to handle touch events
    // Function to get grid coordinates from touch/mouse event
    function getMousePos(e) {
        const rect = gridContainer.getBoundingClientRect();
        const x = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
        const y = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
        
        // Use the cellSize from the window object which is set during canvas initialization
        const cellSize = window.cellSize || gridContainer.clientWidth / GRID_SIZE;
        
        const posX = Math.floor((x - rect.left) / cellSize);
        const posY = Math.floor((y - rect.top) / cellSize);
        
        return {
            x: Math.max(0, Math.min(GRID_SIZE - 1, posX)),
            y: Math.max(0, Math.min(GRID_SIZE - 1, posY))
        };
    };
    function onMouseDown(e) {
      e.preventDefault();
      if (e.button === 0) isLeftMouseDown = true;
      else if (e.button === 2) isRightMouseDown = true;
      else if (e.button === 1) {
        // Middle click to select element under cursor
        selectElementUnderCursor(hoveredX, hoveredY);
      }
    }
    function onMouseUp(e) {
      if (e) e.preventDefault();
      isLeftMouseDown = false;
      isRightMouseDown = false;
    }
    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('mouseleave', () => {
      isLeftMouseDown = false;
      isRightMouseDown = false;
      hoveredX = null; hoveredY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });
    gridContainer.addEventListener('mousemove', e => { const { x, y } = getMousePos(e); hoveredX = x; hoveredY = y; });
    
    // Touch event handlers for mobile
    gridContainer.addEventListener('touchstart', e => {
      e.preventDefault();
      isLeftMouseDown = true;
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      hoveredX = x;
      hoveredY = y;
    });
    
    gridContainer.addEventListener('touchmove', e => {
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      hoveredX = x;
      hoveredY = y;
    });
    
    gridContainer.addEventListener('touchend', e => {
      e.preventDefault();
      isLeftMouseDown = false;
    });
    
    gridContainer.addEventListener('touchcancel', e => {
      e.preventDefault();
      isLeftMouseDown = false;
    });
    
    // Function to select element under cursor
    function selectElementUnderCursor(x, y) {
      if (x === null || y === null || x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      
      const elementType = grid[y][x];
      if (elementType !== EMPTY) {
        // Find the corresponding tool element
        let toolName = getElementName(elementType).toLowerCase().replace(/ /g, '-');
        
        // Special case handling for certain elements
        if (elementType === BURNING_WOOD) toolName = 'wood';
        else if (elementType === BURNING_LEAVES) toolName = 'oak-leaves';
        else if (elementType === BURNING_ORGANIC) toolName = 'grass';
        else if (elementType === BURNING_COAL) toolName = 'coal';
        else if (elementType === BURNING_COAL_LUMP) toolName = 'coal-lump';
        else if (elementType === BURNING_GAS) toolName = 'gas';
        else if (elementType === BURNING_THERMITE) toolName = 'thermite';
        
        const toolElement = document.querySelector(`.tool[data-tool="${toolName}"]`);
        if (toolElement) {
          selectTool(toolElement);
          
          // Show a brief visual confirmation
          const selectedElementNotification = document.getElementById('selectedElementNotification');
          if (selectedElementNotification) {
            const elementName = selectedElementNotification.querySelector('.element-name');
            if (elementName) elementName.textContent = getElementName(elementType);
            
            // Make it visible
            selectedElementNotification.classList.add('visible');
            
            // Hide after 2 seconds
            setTimeout(() => {
              selectedElementNotification.classList.remove('visible');
            }, 2000);
          }
        }
      }
    }
    // Listen for scroll (wheel) events to adjust stroke thickness.
    gridContainer.addEventListener('wheel', e => {
      e.preventDefault();
      if (e.deltaY < 0) {
        // Increase stroke thickness
        if (!isAltKeyDown) {
          // For circular selection, only allow odd numbers
          strokeThickness = Math.min(strokeThickness + 2, 49);
          if (strokeThickness % 2 === 0) strokeThickness--;
        } else {
          // For square selection, allow all numbers
          strokeThickness = Math.min(strokeThickness + 1, 50);
        }
      } else {
        // Decrease stroke thickness
        if (!isAltKeyDown) {
          // For circular selection, only allow odd numbers
          strokeThickness = Math.max(strokeThickness - 2, 1);
          if (strokeThickness % 2 === 0 && strokeThickness > 1) strokeThickness--;
        } else {
          // For square selection, allow all numbers
          strokeThickness = Math.max(strokeThickness - 1, 1);
        }
      }
    });
    
    // Listen for ALT key press/release to toggle between circle and square
    document.addEventListener('keydown', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = true;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    document.addEventListener('keyup', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = false;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    // Initialize audio on first user interaction
    document.addEventListener('mousedown', initAudioContext, { once: true });
    function getMousePos(e) {
      // Use the global cellSize to ensure consistency
      const cellSize = window.cellSize || gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let px = Math.floor((e.clientX - rect.left) / cellSize);
      let py = Math.floor((e.clientY - rect.top) / cellSize);
      return { x: Math.max(0, Math.min(GRID_SIZE - 1, px)), y: Math.max(0, Math.min(GRID_SIZE - 1, py)) };
    }
    // Function to set a cell's type with proper temperature
    function setCellType(x, y, elementType, temperature) {
      // Use our placeElementAt function which already handles all the element placement logic
      placeElementAt(x, y, elementType);
      
      // Override the temperature if specifically provided
      if (temperature !== undefined && temperature !== null && x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
        temp[y][x] = temperature;
      }
    }
    
    // Function to erase a cell at position x,y
    function eraseCell(x, y) {
      if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
        // Check if cell is not already empty
        if (grid[y][x] !== EMPTY) {
          // Set to empty
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          
          // Reset any special trackers for this cell
          vaporLife[y][x] = 0;
          cloudLife[y][x] = 0;
          fireLife[y][x] = 0;
          smokeLife[y][x] = 0;
          burningWoodTime[y][x] = 0;
          sparkLife[y][x] = 0;
          sparkTimer[y][x] = 0;
          smokeMaxLife[y][x] = 1.0 + 2.0 * Math.random();
          cloudMaxLife[y][x] = 5.0 + 5.0 * Math.random();
          colorVariations[y][x] = null;
          
          // Reset photon-related arrays
          if (photonLife && photonLife[y]) photonLife[y][x] = 0;
          if (photonDirX && photonDirX[y]) photonDirX[y][x] = 0;
          if (photonDirY && photonDirY[y]) photonDirY[y][x] = 0;
          if (photonEnergy && photonEnergy[y]) photonEnergy[y][x] = 100;
          if (photonColor && photonColor[y]) photonColor[y][x] = '#ffffff';
          if (photonBounces && photonBounces[y]) photonBounces[y][x] = 0;
          if (photonUnderlying && photonUnderlying[y]) photonUnderlying[y][x] = null;
          if (photonUnderlyingTemp && photonUnderlyingTemp[y]) photonUnderlyingTemp[y][x] = null;
          
          // Reset lightning arrays
          lightningLife[y][x] = 0;
          lightningTrailLife[y][x] = 0;
          
          // Mark the cell as dirty for rendering
          cellsDirty[y][x] = true;
        }
      }
    }
    
    // Function to place an element at a specific position
    function placeElementAt(x, y, elementType) {
      // Handle eraser first
      if (elementType === ERASER) {
        eraseCell(x, y);
        return;
      }

      // For regular elements, set them in the grid
      if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
        // Set the element type and default temperature
        grid[y][x] = elementType;
        
        // Set appropriate temperature based on element type
        if (elementType === FIRE) {
          temp[y][x] = fireTemperature;
          fireLife[y][x] = 0;
        } else if (elementType === LAVA) {
          temp[y][x] = 1200;
        } else if (elementType === ICE) {
          temp[y][x] = -10;
        } else if (elementType === MOLTEN_DIAMOND) {
          temp[y][x] = 4000;
        } else if (elementType === DIAMOND_SHARDS) {
          temp[y][x] = 25;
        } else if (elementType === WATER_VAPOR) {
          temp[y][x] = 120;
          vaporLife[y][x] = 0;
        } else if (elementType === CLOUD) {
          temp[y][x] = 50;
          cloudLife[y][x] = 0;
          cloudMaxLife[y][x] = 1 + 3 * Math.random();
        } else if (elementType === SMOKE) {
          temp[y][x] = 80;
          smokeLife[y][x] = 0;
          smokeMaxLife[y][x] = 1 + 2 * Math.random();
        } else if (elementType === INSULATOR) {
          temp[y][x] = 20;
        } else if (elementType === PHOTON) {
          temp[y][x] = 20;
          // Initialize photon properties
          photonLife[y][x] = 0;
          photonDirX[y][x] = Math.random() < 0.5 ? -1 : 1;
          photonDirY[y][x] = Math.random() < 0.5 ? -1 : 1;
          photonEnergy[y][x] = 100;
          photonColor[y][x] = '#ffffff';
        } else if (elementType === LIGHTNING) {
          temp[y][x] = 20;
          lightningLife[y][x] = 0;
        } else if (elementType === DENSE_CLOUD) {
          temp[y][x] = 60;
        } else {
          // Default temperature for most elements
          temp[y][x] = 20;
        }
        
        // Initialize color variations for this element
        colorVariations[y][x] = {
          r: 1 + (Math.random() * 0.1 - 0.05),
          g: 1 + (Math.random() * 0.1 - 0.05),
          b: 1 + (Math.random() * 0.1 - 0.05)
        };
        
        // For confetti, use more vibrant colors
        if (elementType === CONFETTI) {
          colorVariations[y][x] = {
            r: Math.random(),
            g: Math.random(),
            b: Math.random()
          };
        }
        
        // Mark the cell as dirty for rendering
        cellsDirty[y][x] = true;
      }
    }
    

    
    // Modified spamPlace to place elements over a circular or square area based on strokeThickness.
    function spamPlace() { 
      if (hoveredX === null || hoveredY === null) return; 
      let half = Math.floor(strokeThickness / 2);
      
      // Handle special tools
      if (currentTool >= 100 && currentTool <= 107) {
        if (isLeftMouseDown) {
          for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
            for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
              let x = hoveredX + dx, y = hoveredY + dy;
              if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
              
              switch(currentTool) {
                case 100: // TOOL_HEAT
                  if (temp[y][x] !== null) temp[y][x] = Math.min(temp[y][x] + 50, 3000);
                  break;
                case 101: // TOOL_COOL
                  if (temp[y][x] !== null) temp[y][x] = Math.max(temp[y][x] - 50, -271);
                  break;
                case 102: // TOOL_COOK
                  if (grid[y][x] === DOUGH) {
                    grid[y][x] = BREAD;
                    temp[y][x] = 30;
                  }
                  break;
                case 103: // TOOL_MIX
                  if (Math.random() < 0.5) {
                    let dirs = [[1,0], [-1,0], [0,1], [0,-1]];
                    let dir = dirs[Math.floor(Math.random() * dirs.length)];
                    let nx = x + dir[0], ny = y + dir[1];
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                      let tmpElem = grid[y][x];
                      let tmpTemp = temp[y][x];
                      grid[y][x] = grid[ny][nx];
                      temp[y][x] = temp[ny][nx];
                      grid[ny][nx] = tmpElem;
                      temp[ny][nx] = tmpTemp;
                    }
                  }
                  break;
                case 105: // TOOL_SPONGE
                  if ([BURNING_WOOD, BURNING_ORGANIC, BURNING_LEAVES, ASH, FIRE].includes(grid[y][x])) {
                    eraseCell(x, y);
                  }
                  break;
                case 106: // TOOL_EXTINGUISH
                  if (grid[y][x] === FIRE) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_WOOD) {
                    grid[y][x] = WOOD;
                    temp[y][x] = 20;
                  } else if (grid[y][x] === BURNING_ORGANIC) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_LEAVES) {
                    grid[y][x] = OAK_LEAVES;
                    temp[y][x] = 20;
                  }
                  break;
                case 107: // TOOL_GRIND
                  // Grinding different materials
                  if (grid[y][x] === WHEAT) {
                    // Wheat to flour
                    setCellType(x, y, FLOUR, temp[y][x] || 20);
                  } else if (grid[y][x] === GLASS) {
                    // Glass to glass shards
                    setCellType(x, y, GLASS_SHARD, temp[y][x] || 20);
                  } else if (grid[y][x] === STONE || grid[y][x] === BASALT) {
                    // Stone/basalt to cobblestone
                    setCellType(x, y, COBBLESTONE, temp[y][x] || 20);
                  } else if (grid[y][x] === CELL) {
                    // Cell to blood
                    setCellType(x, y, BLOOD, temp[y][x] || 20);
                  } else if (grid[y][x] === WOOD || grid[y][x] === BIRCH_WOOD) {
                    // Wood/birch wood to sawdust
                    setCellType(x, y, SAWDUST, temp[y][x] || 20);
                  }
                  break;
              }
            }
          }
        }
        return;
      }
      
      // Regular element placement
      for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
        for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
          let x = hoveredX + dx, y = hoveredY + dy;
          if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          
          // Check if we should place at this position based on shape
          let shouldPlace = true;
          
          if (!isAltKeyDown) { // Circular placement when ALT is not pressed
            // Ensure odd brush size for circles
            if (strokeThickness % 2 === 0) {
              strokeThickness--;
              if (strokeThickness < 1) strokeThickness = 1;
              half = Math.floor(strokeThickness / 2);
            }
            
            // Calculate distance from center to determine if point is in circle
            const centerX = hoveredX;
            const centerY = hoveredY;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            const radius = strokeThickness / 2;
            
            // Simple distance check for a pixelated circle
            shouldPlace = distance <= radius;
          }
          
          if (shouldPlace) {
            if (isLeftMouseDown) {
              placeElementAt(x, y, currentTool);
            } else if (isRightMouseDown) {
              placeElementAt(x, y, ERASER);
            }
          }
        }
      }
    }
    // Update the hover overlay that shows the stroke area using canvas for performance
    function updateHoverOverlay() {
      if (hoveredX === null || hoveredY === null) {
        // Hide the overlay when no hover position
        if (hoverOverlay) {
          hoverOverlay.style.display = "none";
        }
        return;
      }
      
      // Enforce odd brush size for circles when not using ALT
      if (!isAltKeyDown && strokeThickness % 2 === 0) {
        strokeThickness--;
        if (strokeThickness < 1) strokeThickness = 1;
      }
      
      // Get canvas context and cell size
      const canvas = window.sandboxCanvas;
      const ctx = window.ctx;
      
      if (!canvas || !ctx) return; // Safety check
      
      const cellSize = window.cellSize;
      
      // We'll draw directly on the main canvas and rely on the next frame to clear it
      // This avoids creating DOM elements and is much more efficient
      
      // Save the current canvas state
      ctx.save();
      
      // Set up stroke style for outline
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 1;
      
      if (!isAltKeyDown) {
        // Circular brush
        const radius = strokeThickness / 2;
        const half = Math.floor(radius);
        
        // Identify all cells that would be affected by the brush
        const circleArea = new Set();
        for (let dy = -half; dy <= half; dy++) {
          for (let dx = -half; dx <= half; dx++) {
            const distance = Math.sqrt(dx*dx + dy*dy);
            if (distance <= radius) {
              const cx = hoveredX + dx;
              const cy = hoveredY + dy;
              if (cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE) {
                circleArea.add(`${cx},${cy}`);
              }
            }
          }
        }
        
        // Draw edges for each cell in the circle area
        for (const cellPos of circleArea) {
          const [x, y] = cellPos.split(',').map(Number);
          
          // Check each of the four neighbors to see if they're outside the circle
          const neighbors = [
            {dx: 0, dy: -1, edge: 'top'},    // top
            {dx: 1, dy: 0, edge: 'right'},   // right
            {dx: 0, dy: 1, edge: 'bottom'},  // bottom
            {dx: -1, dy: 0, edge: 'left'}    // left
          ];
          
          for (const {dx, dy, edge} of neighbors) {
            const nx = x + dx;
            const ny = y + dy;
            const neighborKey = `${nx},${ny}`;
            
            // If neighbor is outside the circle or out of bounds, draw this edge
            if (!circleArea.has(neighborKey) || nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
              // Draw just the edge that faces outward from the circle
              ctx.beginPath();
              switch (edge) {
                case 'top':
                  ctx.moveTo(x * cellSize, y * cellSize);
                  ctx.lineTo((x + 1) * cellSize, y * cellSize);
                  break;
                case 'right':
                  ctx.moveTo((x + 1) * cellSize, y * cellSize);
                  ctx.lineTo((x + 1) * cellSize, (y + 1) * cellSize);
                  break;
                case 'bottom':
                  ctx.moveTo(x * cellSize, (y + 1) * cellSize);
                  ctx.lineTo((x + 1) * cellSize, (y + 1) * cellSize);
                  break;
                case 'left':
                  ctx.moveTo(x * cellSize, y * cellSize);
                  ctx.lineTo(x * cellSize, (y + 1) * cellSize);
                  break;
              }
              ctx.stroke();
            }
          }
        }
      } else {
        // Square brush when ALT is pressed
        const half = Math.floor(strokeThickness / 2);
        const startX = (hoveredX - half) * cellSize;
        const startY = (hoveredY - half) * cellSize;
        const size = strokeThickness * cellSize;
        
        // Draw only the outline of the square
        ctx.strokeRect(startX, startY, size, size);
      }
      
      // Restore the canvas state
      ctx.restore();
      
      // Hide the DOM-based overlay since we're using canvas
      if (hoverOverlay) {
        hoverOverlay.style.display = "none";
      }
    }
    /***************************************
     * PLACEMENT & ERASURE
     ***************************************/
     function placeElementAt(x, y, tool) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      if (grid[y][x] === tool) return;
      if (tool === ERASER) { eraseCell(x, y); playPlacementSound('eraser'); return; }
      
      // Lightning placement logic exactly like the mod
      if (tool === LIGHTNING) {
        // Compute the entire path instantly.
        let currentX = x, currentY = y;
        let path = [];
        path.push({ x: currentX, y: currentY });
        // Continue downward until reaching bottom or encountering a solid object
        while (currentY < GRID_SIZE - 1) {
          const nextCell = grid[currentY+1][currentX];
          // Stop if we hit a solid object (not clouds, vapor, or gases)
          if (nextCell !== EMPTY && 
              nextCell !== WATER_VAPOR && 
              nextCell !== CLOUD && 
              nextCell !== DENSE_CLOUD &&
              nextCell !== GAS &&
              nextCell !== OXYGEN &&
              nextCell !== CARBON_DIOXIDE &&
              nextCell !== HELIUM &&
              nextCell !== SMOKE &&
              nextCell !== ACID_STEAM &&
              nextCell !== ACID_CLOUD) {
            break; // Hit a solid object
          }
          
          // With a 30% chance, try a lateral shift.
          if (Math.random() < 0.3) {
            let lateralDir = Math.random() < 0.5 ? -1 : 1;
            let newX = currentX + lateralDir;
            // Check lateral bounds and ensure we can move laterally
            if (newX >= 0 && newX < GRID_SIZE) {
              const lateralCell = grid[currentY][newX];
              const belowLateralCell = grid[currentY+1][newX];
              // Can move laterally through empty space or passable materials
              if ((lateralCell === EMPTY || 
                   lateralCell === WATER_VAPOR || 
                   lateralCell === CLOUD || 
                   lateralCell === DENSE_CLOUD ||
                   lateralCell === GAS ||
                   lateralCell === OXYGEN ||
                   lateralCell === CARBON_DIOXIDE ||
                   lateralCell === HELIUM ||
                   lateralCell === SMOKE ||
                   lateralCell === ACID_STEAM ||
                   lateralCell === ACID_CLOUD) &&
                  (belowLateralCell === EMPTY || 
                   belowLateralCell === WATER_VAPOR || 
                   belowLateralCell === CLOUD || 
                   belowLateralCell === DENSE_CLOUD ||
                   belowLateralCell === GAS ||
                   belowLateralCell === OXYGEN ||
                   belowLateralCell === CARBON_DIOXIDE ||
                   belowLateralCell === HELIUM ||
                   belowLateralCell === SMOKE ||
                   belowLateralCell === ACID_STEAM ||
                   belowLateralCell === ACID_CLOUD)) {
                currentX = newX;
              }
            }
          }
          currentY++;
          path.push({ x: currentX, y: currentY });
        }
                 // For every cell in the path except the last one, mark it as a lightning trail.
         for (let i = 0; i < path.length - 1; i++) {
           let pos = path[i];
           const currentElement = grid[pos.y][pos.x];
           // Only place lightning trail if the cell is empty (don't replace clouds/vapor)
           if (currentElement === EMPTY) {
             grid[pos.y][pos.x] = LIGHTNING_TRAIL;
             temp[pos.y][pos.x] = 2000; // Hot lightning trail
             lightningTrailLife[pos.y][pos.x] = 0; // initialize trail timer
           } else {
             // Just heat up the existing clouds/vapor
             temp[pos.y][pos.x] = Math.min((temp[pos.y][pos.x] || 20) + 100, 500);
           }
         }
         // The bottom cell becomes the active lightning strike.
         let bottom = path[path.length - 1];
         const bottomElement = grid[bottom.y][bottom.x];
         if (bottomElement === EMPTY) {
           grid[bottom.y][bottom.x] = LIGHTNING;
           temp[bottom.y][bottom.x] = 5000; // Very hot lightning strike
           lightningLife[bottom.y][bottom.x] = 0; // initialize explosion timer
         } else {
           // If bottom isn't empty, just heat it up massively
           temp[bottom.y][bottom.x] = Math.min((temp[bottom.y][bottom.x] || 20) + 1000, 2000);
         }
        return;
      }
      
      eraseCell(x, y);
      grid[y][x] = tool;
      
      // Mark cell as dirty for rendering
      markDirty(x, y);
      // Mark neighbors as dirty for effects that might affect nearby cells
      markNeighborsDirty(x, y, 1);
      
      // Play placement sound
      playPlacementSound(tool);
      switch (tool) {
        case SAND: temp[y][x] = 20; break;
        case WALL: temp[y][x] = 20; break;
        case WATER: temp[y][x] = 20; break;
        case SNOW: temp[y][x] = -5; break; // Snow starts cold
        case LAVA: temp[y][x] = 1600; break;
        case STONE: temp[y][x] = 20; break;
        case WATER_VAPOR: temp[y][x] = 100; vaporLife[y][x] = 0; break;
        case CLOUD: temp[y][x] = 50; cloudLife[y][x] = 0; cloudMaxLife[y][x] = 5.0 + 5.0 * Math.random(); break;
        case COPPER: temp[y][x] = 100; break;
        case STEEL: temp[y][x] = 50; break;
        case ICE: temp[y][x] = -5; break;
        case WOOD: temp[y][x] = 20; burningWoodTime[y][x] = 0; break;
        case FIRE: temp[y][x] = fireTemperature; fireLife[y][x] = 0; break;
        case SMOKE: temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); break;
        case BURNING_WOOD: temp[y][x] = woodFireTemp; break;
        case BURNING_ORGANIC: temp[y][x] = organicFireTemp; break;
        case ASH: temp[y][x] = 20; break;
        case GLASS: temp[y][x] = 300; break;
        case BOMB: temp[y][x] = 20; break;
        case DIRT: temp[y][x] = 20; break;
        case WET_DIRT: temp[y][x] = 20; break;
        case WHEAT_SEEDS: temp[y][x] = 20; seedGrowthTime[y][x] = 0; break;
        case FLOUR: temp[y][x] = 20; break;
        case DOUGH: temp[y][x] = 25; break;
        case BREAD: temp[y][x] = 30; break;
        case ROOT: temp[y][x] = 15; break;
        case BURNING_ORGANIC: temp[y][x] = organicFireTemp; break;
        case SPARK: temp[y][x] = 20; sparkLife[y][x] = 0; break;
        case CHARGED_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case OAK_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case BIRCH_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case GRASS: temp[y][x] = 20; grassStage[y][x] = 1; break;
        case GAS: temp[y][x] = 20; break;
        case CHARGED_DOWN_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case COOLER: temp[y][x] = 20; break;
        case HEATER: temp[y][x] = 20; break;
        case HEAT_SEPARATOR: temp[y][x] = 20; break;
        case CHARGED_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CHARGED_DOWN_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case INPUT: temp[y][x] = 20; break;
        case CHARGED_INPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case OUTPUT: temp[y][x] = 20; break;
        case CHARGED_OUTPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case NOT_GATE: temp[y][x] = 20; break;
        case AND_GATE: temp[y][x] = 20; break;
        case BLOCKER: temp[y][x] = 20; break;
        case CHARGED_BLOCKER: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CLONER: temp[y][x] = 20; break;
        case COAL: temp[y][x] = 20; break;
        case COAL_LUMP: temp[y][x] = 20; break;
        case THERMITE: temp[y][x] = 20; break;
        case BURNING_THERMITE: temp[y][x] = thermiteFireTemp; break;
        case ACID: temp[y][x] = 20; break;
        case SLIME: temp[y][x] = 20; break;
        case ACID_STEAM: temp[y][x] = 120; break;
        case ACID_CLOUD: temp[y][x] = 50; break;
        case CARBON_DIOXIDE: temp[y][x] = 20; break;
        case OXYGEN: temp[y][x] = 20; break;
        case BIRD: temp[y][x] = 20; break;
        case MEAT: temp[y][x] = 20; break;
        case COOKED_MEAT: temp[y][x] = 20; break;
        case COBBLESTONE: temp[y][x] = 20; break;
        case OIL: temp[y][x] = 20; break;
        case BIG_BOMB: temp[y][x] = 20; break;
        case WATER_BOMB: temp[y][x] = 20; break;
        case FIRE_BOMB: temp[y][x] = 20; break;
        case CRYO_BOMB: temp[y][x] = 20; break;
        case NUKE_BOMB: temp[y][x] = 20; break;
        case CELL: temp[y][x] = 20; break;
        case DEAD_CELL: temp[y][x] = 20; break;
        case BLOOD: temp[y][x] = 20; break;
        case GLASS_SHARD: temp[y][x] = 20; break;
        case SAWDUST: temp[y][x] = 20; break;
        case BOUNCY_BALL: 
          temp[y][x] = 20; 
          // Initialize with a small random velocity
          ballVelocityX[y][x] = (Math.random() - 0.5) * 2;
          ballVelocityY[y][x] = -2 - Math.random() * 2; // Initial upward velocity
          break;
        case SALT: temp[y][x] = 20; break;
        case SALT_WATER: temp[y][x] = 20; break;
        case SUGAR: temp[y][x] = 20; break;
        case SUGAR_WATER: temp[y][x] = 20; break;
        case MOLTEN_SUGAR: temp[y][x] = sugarMeltingTemp + 20; break;
        case DIAMOND: temp[y][x] = 20; break;
        case DIAMOND_SHARDS: temp[y][x] = 20; break;
        case MOLTEN_DIAMOND: temp[y][x] = diamondMeltingTemp + 50; break;
        case CONFETTI: temp[y][x] = 20; break;
        case DABICCO: temp[y][x] = 20; break;
        case PLANT: temp[y][x] = 20; break;
        case GLUE: temp[y][x] = 20; break;
        case MOLTEN_COPPER: temp[y][x] = copperMeltingTemp + 15; break;
        case MOLTEN_GLASS: temp[y][x] = glassMeltingTemp + 100; break;
        case MOLTEN_STEEL: temp[y][x] = steelMeltingTemp + 50; break;
        case MOLTEN_SALT: temp[y][x] = saltMeltingTemp + 20; break;
        case HELIUM: temp[y][x] = 20; break;
        case OXIDIZED_COPPER: temp[y][x] = 20; break;
        case MOLTEN_COPPER: temp[y][x] = copperMeltingTemp + 15; break;
        case MOLTEN_GLASS: temp[y][x] = glassMeltingTemp + 100; break;
        case MOLTEN_STEEL: temp[y][x] = steelMeltingTemp + 50; break;
        case MOLTEN_SALT: temp[y][x] = saltMeltingTemp + 20; break;
        case INSULATOR: temp[y][x] = 20; break;
        case PHOTON: 
          temp[y][x] = 20; 
          photonLife[y][x] = 0;
          photonBounces[y][x] = 0; // Initialize bounce count
          // Random direction (8 directions: up, down, left, right, diagonals)
          const directions = [[-1,-1], [0,-1], [1,-1], [-1,0], [1,0], [-1,1], [0,1], [1,1]];
          const dir = directions[Math.floor(Math.random() * directions.length)];
          photonDirX[y][x] = dir[0];
          photonDirY[y][x] = dir[1];
          photonEnergy[y][x] = 100;
          photonColor[y][x] = '#ffffff';
          break;
        case LIGHTNING: 
          temp[y][x] = 5000; 
          lightningLife[y][x] = 0;
          break; // Lightning is extremely hot
        case DENSE_CLOUD: temp[y][x] = 60; break; // Slightly warmer than regular clouds
        default:
          // Handle custom elements (ID >= CUSTOM_ELEMENT_START)
          if (tool >= CUSTOM_ELEMENT_START && customElements[tool]) {
            temp[y][x] = 20; // Default temperature for custom elements
          } else {
            // Unknown element - fallback to room temperature
            temp[y][x] = 20;
          }
          break;
      }
      
      // Initialize color variation for this element
      const variation = 0.03;
      colorVariations[y][x] = {
        r: 1 + (Math.random() * variation * 2 - variation),
        g: 1 + (Math.random() * variation * 2 - variation),
        b: 1 + (Math.random() * variation * 2 - variation)
      };
    }

// Function to play placement sounds based on element type
function playPlacementSound(elementType) {
  if (!audioContext) return;
  
  // Create oscillator for sound
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  // Configure sound based on element type
  let frequency = 440; // Default frequency (A4)
  let type = 'sine'; // Default wave type
  let duration = 0.1; // Default duration in seconds
  
  // Customize sound based on element type
  switch(elementType) {
    case WATER:
      frequency = 300 + Math.random() * 50;
      type = 'sine';
      duration = 0.2;
      break;
    case LAVA:
      frequency = 150 + Math.random() * 30;
      type = 'sawtooth';
      duration = 0.3;
      break;
    case SAND:
      frequency = 800 + Math.random() * 200;
      type = 'triangle';
      duration = 0.05 + Math.random() * 0.05;
      break;
    case WALL:
    case STONE:
    case COBBLESTONE:
      frequency = 200 + Math.random() * 100;
      type = 'square';
      duration = 0.1;
      break;
    case FIRE:
      frequency = 500 + Math.random() * 300;
      type = 'sawtooth';
      duration = 0.15;
      break;
    case ICE:
      frequency = 600 + Math.random() * 100;
      type = 'sine';
      duration = 0.2;
      break;
    case WOOD:
      frequency = 350 + Math.random() * 50;
      type = 'triangle';
      duration = 0.15;
      break;
    case BOMB:
    case BIG_BOMB:
    case WATER_BOMB:
    case FIRE_BOMB:
    case CRYO_BOMB:
    case NUKE_BOMB:
      frequency = 200 + Math.random() * 50;
      type = 'square';
      duration = 0.2;
      break;
    case 'eraser':
      frequency = 100 + Math.random() * 50;
      type = 'sine';
      duration = 0.1;
      break;
    default:
      // For other elements, generate a sound based on the element ID
      frequency = 300 + (elementType % 10) * 50 + Math.random() * 30;
      type = ['sine', 'triangle', 'square', 'sawtooth'][elementType % 4];
      duration = 0.1 + Math.random() * 0.1;
  }
  
  // Set oscillator properties
  oscillator.type = type;
  oscillator.frequency.value = frequency;
  
  // Set volume envelope
  gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
  
  // Connect and start
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.start();
  oscillator.stop(audioContext.currentTime + duration);
}

    function eraseCell(x, y){
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      
      // Mark the cell as dirty to ensure it's re-rendered
      markDirty(x, y);
    }

    function eraseCellFull(x, y) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[y][x] = false;
      vaporLife[y][x] = 0;
      cloudLife[y][x] = 0;
      fireLife[y][x] = 0;
      
      // Mark the cell as dirty to ensure it's re-rendered
      markDirty(x, y);
      smokeLife[y][x] = 0;
      burningWoodTime[y][x] = 0;
      wheatHeight[y][x] = 0;
      wheatMaxHeight[y][x] = 0;
      seedGrowthTime[y][x] = 0;
      rootLife[y][x] = 0;
      
      // Mark cell as dirty for rendering
      markDirty(x, y);
      // Mark neighbors as dirty for effects that might affect nearby cells
      markNeighborsDirty(x, y, 1);
      sparkLife[y][x] = 0;
      sparkTimer[y][x] = 0;
      // Reset new element arrays
      photonLife[y][x] = 0;
      photonDirX[y][x] = 0;
      photonDirY[y][x] = 0;
      photonEnergy[y][x] = 100;
      photonColor[y][x] = '#ffffff';
      lightningLife[y][x] = 0;
      oakTreeGrowthTime[y][x] = 0;
      oakTreeHeight[y][x] = 0;
      oakTreeMaxHeight[y][x] = 0;
      oakTreeRootTimer[y][x] = 0;
      oakTreeRootDepth[y][x] = 0;
      oakTreeRootMax[y][x] = 0;
      branchLevel[y][x] = -1;
      branchLen[y][x] = 0;
      branchMaxArr[y][x] = 0;
      branchSubCount[y][x] = -1;
      branchDirX[y][x] = 0;
      branchDirY[y][x] = 0;
      grassStage[y][x] = 1;
      burningGasTime[y][x] = 0;
      chargedStateTime[y][x] = 0;
      colorVariations[y][x] = null;
    }
    
    // Sound pool to manage multiple sounds playing simultaneously
    const MAX_SOUNDS = 3; // Reduced to prevent audio cutout
    let soundPool = [];
    let lastSoundTime = 0;
    let soundThrottleDelay = 50; // ms between sounds
    let soundPlayProbability = 0.2; // Only play sound for 20% of cells
    
    // Sound volume settings
    let masterVolume = 1.0; // Master volume (0.0 to 1.0)
    
    // Individual element volume settings (default to 1.0)
    const elementVolumes = {};
    
    // Initialize element volumes for all element types
    function initElementVolumes() {
      // Set default volumes for all elements
      for (let i = 0; i <= 100; i++) {
        elementVolumes[i] = 1.0;
      }
      
      // Set specific volumes for elements that need adjustment
      elementVolumes[5] = 2.0;  // Fire at 200% volume
      elementVolumes[1] = 1.0;  // Sand at 100% volume
      elementVolumes[12] = 1.3; // Grass was too quiet
      elementVolumes[7] = 0.5;  // Lava at 50% volume
      elementVolumes[93] = 1.0; // Cell
      elementVolumes[95] = 1.0; // Blood
      elementVolumes[96] = 1.2; // Glass Shard
      elementVolumes[97] = 1.0; // Sawdust
    }
    
    // Initialize element volumes
    initElementVolumes();
    
    // Initialize new audio controls
    initAudioControls();
    
    // Initialize sound options when document is ready
    document.addEventListener('DOMContentLoaded', function() {
      initSoundOptions();
    });
    
    // Initialize sound options in the options modal
    function initSoundOptions() {
      // Master volume slider
      const masterVolumeSlider = document.getElementById('masterVolumeSlider');
      const masterVolumeValue = document.getElementById('masterVolumeValue');
      
      if (!masterVolumeSlider || !masterVolumeValue) return; // Elements not loaded yet
      
      // Set initial value
      masterVolumeSlider.value = masterVolume * 100;
      masterVolumeValue.textContent = Math.round(masterVolume * 100) + '%';
      
      // Add event listener for master volume change
      masterVolumeSlider.addEventListener('input', function() {
        masterVolume = this.value / 100;
        masterVolumeValue.textContent = this.value + '%';
        // Save to localStorage
        localStorage.setItem('masterVolume', masterVolume);
      });
      
      // Toggle element volume controls
      const toggleButton = document.getElementById('toggleElementVolumes');
      const elementControls = document.getElementById('elementVolumeControls');
      
      if (!toggleButton || !elementControls) return; // Elements not loaded yet
      
      toggleButton.addEventListener('click', function() {
        if (elementControls.style.display === 'none') {
          elementControls.style.display = 'block';
          toggleButton.textContent = 'Hide Element Volume Controls';
          
          // Create element volume sliders if they don't exist
          if (elementControls.querySelector('.element-volume-grid').children.length === 0) {
            createElementVolumeSliders();
          }
        } else {
          elementControls.style.display = 'none';
          toggleButton.textContent = 'Show Element Volume Controls';
        }
      });
      
      // Load saved volume settings
      loadVolumeSettings();
    }
    
    // Create volume sliders for each element type
    function createElementVolumeSliders() {
      const elementVolumeGrid = document.querySelector('.element-volume-grid');
      
      if (!elementVolumeGrid) return; // Element not found
      
      // Clear existing sliders
      elementVolumeGrid.innerHTML = '';
      
      // Get element names and colors from the elementColors object
      const elementTypes = [];
      
      // Add all elements with their IDs
      // These are organized by categories for easier navigation
      const commonElements = [
        // Basic elements
        { id: 1, name: 'Sand', color: '#e6c88a' },
        { id: 2, name: 'Water', color: '#4286f4' },
        { id: 3, name: 'Stone', color: '#808080' },
        { id: 4, name: 'Wood', color: '#8B4513' },
        { id: 5, name: 'Fire', color: '#ff4500' },
        { id: 6, name: 'Oil', color: '#3d3d29' },
        { id: 7, name: 'Lava', color: '#ff6600' },
        { id: 8, name: 'Wall', color: '#444444' },
        { id: 9, name: 'Ice', color: '#add8e6' },
        { id: 10, name: 'Acid', color: '#00ff00' },
        { id: 11, name: 'Dirt', color: '#8B4513' },
        { id: 12, name: 'Grass', color: '#7CFC00' },
        { id: 13, name: 'Smoke', color: '#a9a9a9' },
        { id: 14, name: 'Bomb', color: '#000000' },
        { id: 15, name: 'Gas', color: '#ffff99' },
        
        // Metals and minerals
        { id: 16, name: 'Coal', color: '#0f0f0f' },
        { id: 17, name: 'Iron', color: '#a19d94' },
        { id: 18, name: 'Gold', color: '#FFD700' },
        { id: 19, name: 'Copper', color: '#b87333' },
        { id: 20, name: 'Steel', color: '#71797E' },
        { id: 21, name: 'Diamond', color: '#b9f2ff' },
        
        // Plants and organic
        { id: 22, name: 'Plant', color: '#228B22' },
        { id: 23, name: 'Seeds', color: '#8B4513' },
        { id: 24, name: 'Leaves', color: '#32CD32' },
        
        // Gases and liquids
        { id: 25, name: 'Steam', color: '#ffffff' },
        { id: 26, name: 'Cloud', color: '#f0f0f0' },
        { id: 27, name: 'Oxygen', color: '#87CEEB' },
        { id: 28, name: 'Carbon Dioxide', color: '#708090' },
        
        // Explosives and reactive
        { id: 29, name: 'Thermite', color: '#AA4444' },
        { id: 30, name: 'Gunpowder', color: '#36454F' },
        
        // Construction materials
        { id: 31, name: 'Glass', color: '#add8e6' },
        { id: 32, name: 'Cobblestone', color: '#696969' },
        
        // Special elements
        { id: 33, name: 'Eraser', color: '#FF69B4' },
        { id: 34, name: 'Slime', color: '#00FF00' },
        { id: 35, name: 'Electricity', color: '#FFFF00' }
      ];
      
      // Add the common elements to our list
      elementTypes.push(...commonElements);
      
      // Add our new elements
      elementTypes.push({ id: 93, name: 'Cell', color: '#66cc99' });
      elementTypes.push({ id: 95, name: 'Blood', color: '#cc0000' });
      elementTypes.push({ id: 96, name: 'Glass Shard', color: '#e0f0ff' });
      
      // Add a category for other elements
      elementTypes.push({ id: 0, name: 'Other Elements', color: '#cccccc' });
      
      
      // Create a slider for each element type
      elementTypes.forEach(element => {
        const volumeItem = document.createElement('div');
        volumeItem.className = 'element-volume-item';
        
        // Color box to identify the element
        const colorBox = document.createElement('div');
        colorBox.className = 'element-color-box';
        colorBox.style.backgroundColor = element.color;
        
        // Element name
        const nameSpan = document.createElement('span');
        nameSpan.textContent = element.name + ': ';
        
        // Volume slider
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '200';
        slider.value = elementVolumes[element.id] * 100;
        slider.className = 'volume-slider';
        slider.style.width = '100px';
        slider.dataset.elementId = element.id;
        
        // Volume value display
        const valueSpan = document.createElement('span');
        valueSpan.textContent = Math.round(elementVolumes[element.id] * 100) + '%';
        valueSpan.style.minWidth = '40px';
        valueSpan.style.display = 'inline-block';
        
        // Add event listener
        slider.addEventListener('input', function() {
          const elementId = parseInt(this.dataset.elementId);
          elementVolumes[elementId] = this.value / 100;
          valueSpan.textContent = this.value + '%';
          
          // Save to localStorage
          saveElementVolumes();
        });
        
        // Assemble the volume item
        volumeItem.appendChild(colorBox);
        volumeItem.appendChild(nameSpan);
        volumeItem.appendChild(slider);
        volumeItem.appendChild(valueSpan);
        
        // Add to the grid
        elementVolumeGrid.appendChild(volumeItem);
      });
    }
    
    // Save element volumes to localStorage
    function saveElementVolumes() {
      localStorage.setItem('elementVolumes', JSON.stringify(elementVolumes));
    }
    
    // Load volume settings from localStorage
    function loadVolumeSettings() {
      // Load master volume
      const savedMasterVolume = localStorage.getItem('masterVolume');
      if (savedMasterVolume !== null) {
        masterVolume = parseFloat(savedMasterVolume);
        const masterVolumeSlider = document.getElementById('masterVolumeSlider');
        const masterVolumeValue = document.getElementById('masterVolumeValue');
        
        if (masterVolumeSlider && masterVolumeValue) {
          masterVolumeSlider.value = masterVolume * 100;
          masterVolumeValue.textContent = Math.round(masterVolume * 100) + '%';
        }
      }
      
      // Load element volumes
      const savedElementVolumes = localStorage.getItem('elementVolumes');
      if (savedElementVolumes !== null) {
        const parsedVolumes = JSON.parse(savedElementVolumes);
        
        // Update our elementVolumes object
        for (const elementId in parsedVolumes) {
          if (parsedVolumes.hasOwnProperty(elementId)) {
            elementVolumes[elementId] = parsedVolumes[elementId];
          }
        }
      }
    }

    // Initialize new audio controls
    function initAudioControls() {
      // Test buttons
      const testButtons = {
        'testPlacementSound': () => playPlacementSound(SAND),
        'testExplosionSound': () => playExplosionSound(BOMB),
        'testBouncingSound': () => playBouncingSound(),
        'testGlassBreakSound': () => playGlassBreakSound(),
        'testLightningSound': () => playLightningSound()
      };

      Object.keys(testButtons).forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
          button.addEventListener('click', testButtons[buttonId]);
        }
      });

      // Category volume sliders
      const categorySliders = {
        'placementVolume': 'placementVolumeValue',
        'explosionVolume': 'explosionVolumeValue',
        'bouncingVolume': 'bouncingVolumeValue',
        'glassBreakVolume': 'glassBreakVolumeValue',
        'lightningVolume': 'lightningVolumeValue'
      };

      Object.keys(categorySliders).forEach(sliderId => {
        const slider = document.getElementById(sliderId);
        const valueDisplay = document.getElementById(categorySliders[sliderId]);
        
        if (slider && valueDisplay) {
          slider.addEventListener('input', function() {
            valueDisplay.textContent = this.value + '%';
            // Update corresponding element volumes
            updateCategoryVolumes(sliderId, this.value / 100);
          });
        }
      });

      // Advanced settings
      const maxSoundsSlider = document.getElementById('maxSoundsSlider');
      const maxSoundsValue = document.getElementById('maxSoundsValue');
      if (maxSoundsSlider && maxSoundsValue) {
        maxSoundsSlider.addEventListener('input', function() {
          maxSoundsValue.textContent = this.value;
          MAX_SOUNDS = parseInt(this.value);
        });
      }

      const soundThrottleSlider = document.getElementById('soundThrottleSlider');
      const soundThrottleValue = document.getElementById('soundThrottleValue');
      if (soundThrottleSlider && soundThrottleValue) {
        soundThrottleSlider.addEventListener('input', function() {
          soundThrottleValue.textContent = this.value + '%';
          soundPlayProbability = this.value / 100;
        });
      }

      // Enhanced toggle button for element controls
      const toggleBtn = document.getElementById('toggleElementVolumes');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', function() {
          const controls = document.getElementById('elementVolumeControls');
          const isExpanded = controls.style.display !== 'none';
          
          controls.style.display = isExpanded ? 'none' : 'block';
          this.classList.toggle('expanded', !isExpanded);
          
          const span = this.querySelector('span');
          if (span) {
            span.textContent = isExpanded ? 'Show Element Controls' : 'Hide Element Controls';
          }
          
          // Create element volume sliders if they don't exist and we're opening
          if (!isExpanded && controls.querySelector('.element-volume-grid').children.length === 0) {
            createElementVolumeSliders();
          }
        });
      }

      // Element search functionality
      const searchInput = document.getElementById('elementVolumeSearch');
      if (searchInput) {
        searchInput.addEventListener('input', function() {
          filterElementControls(this.value);
        });
      }
    }

    // Update category-specific volumes
    function updateCategoryVolumes(category, multiplier) {
      switch (category) {
        case 'placementVolume':
          // Update placement sound volumes
          [SAND, WATER, STONE, WOOD, FIRE, ICE, BOMB].forEach(elementId => {
            if (elementVolumes[elementId]) {
              elementVolumes[elementId] = multiplier;
            }
          });
          break;
        case 'explosionVolume':
          // Update explosion volumes
          [BOMB, BIG_BOMB, WATER_BOMB, FIRE_BOMB, CRYO_BOMB, NUKE_BOMB].forEach(elementId => {
            if (elementVolumes[elementId]) {
              elementVolumes[elementId] = multiplier;
            }
          });
          break;
        case 'bouncingVolume':
          if (elementVolumes[BOUNCY_BALL]) {
            elementVolumes[BOUNCY_BALL] = multiplier;
          }
          break;
        case 'glassBreakVolume':
          if (elementVolumes[GLASS_SHARD]) {
            elementVolumes[GLASS_SHARD] = multiplier;
          }
          break;
        case 'lightningVolume':
          if (elementVolumes[LIGHTNING]) {
            elementVolumes[LIGHTNING] = multiplier;
          }
          break;
      }
      saveElementVolumes();
    }

    // Filter element controls based on search
    function filterElementControls(searchTerm) {
      const grid = document.querySelector('.element-volume-grid');
      if (!grid) return;
      
      const items = grid.querySelectorAll('.element-volume-item');
      const lowercaseSearch = searchTerm.toLowerCase();
      
      items.forEach(item => {
        const elementName = item.querySelector('span').textContent.toLowerCase();
        const shouldShow = elementName.includes(lowercaseSearch);
        item.style.display = shouldShow ? 'flex' : 'none';
      });
    }
    
    // Function to create more realistic sounds using multiple oscillators and filters
    function playPlacementSound(elementType) {
      if (!audioContext) return;
      
      // Throttle sounds by time and probability
      const now = Date.now();
      if (now - lastSoundTime < soundThrottleDelay || Math.random() > soundPlayProbability) {
        return; // Skip this sound
      }
      lastSoundTime = now;
      
      // Limit the number of simultaneous sounds to prevent audio cutoff
      while (soundPool.length >= MAX_SOUNDS) {
        // Remove the oldest sound to make room for the new one
        const oldestSound = soundPool.shift();
        if (oldestSound.gainNode) {
          // Stop it completely to free up audio resources
          oldestSound.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
          oldestSound.gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          if (oldestSound.oscillators) {
            oldestSound.oscillators.forEach(osc => {
              try { osc.stop(audioContext.currentTime); } catch (e) {}
            });
          }
        }
      }
      
      // Create master gain node
      const masterGain = audioContext.createGain();
      
      // Apply both master volume and element-specific volume
      const elementVolumeMultiplier = elementVolumes[elementType] || 1.0;
      const volumeScale = Math.max(0.05, 0.3 - (soundPool.length * 0.02)) * masterVolume * elementVolumeMultiplier;
      masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      
      // Create a BiquadFilter for sound shaping
      const filter = audioContext.createBiquadFilter();
      filter.connect(masterGain);
      masterGain.connect(audioContext.destination);
      
      // Create noise generator for certain sounds
      const createNoise = (duration) => {
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        return noise;
      };
      
      // Track all oscillators for cleanup
      const oscillators = [];
      let duration = 0.2; // Default duration
      
      // Create different sound profiles based on element type
      switch(elementType) {
        case WATER: {
          // Water splash sound
          duration = 0.4;
          filter.type = 'lowpass';
          filter.frequency.value = 800;
          filter.Q.value = 1;
          
          // White noise for splash
          const noise = createNoise(duration);
          noise.connect(filter);
          oscillators.push(noise);
          
          // Bubbling effect
          for (let i = 0; i < 3; i++) {
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 300 + Math.random() * 400;
            osc.frequency.exponentialRampToValueAtTime(100 + Math.random() * 200, audioContext.currentTime + duration);
            
            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(0, audioContext.currentTime);
            oscGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.05 + (i * 0.05));
            oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration - 0.05);
            
            osc.connect(oscGain);
            oscGain.connect(filter);
            oscillators.push(osc);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
          }
          
          masterGain.gain.setValueAtTime(volumeScale * 0.8, audioContext.currentTime);
          masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          noise.start();
          noise.stop(audioContext.currentTime + duration);
          break;
        }
        
        case SAND: {
          // Sand pouring/falling sound
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 2000;
          filter.Q.value = 1;
          
          // Filtered noise for sand particles
          const noise = createNoise(duration);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.5, audioContext.currentTime);
          noiseGain.gain.linearRampToValueAtTime(volumeScale * 0.2, audioContext.currentTime + duration);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          // Short impact sound
          const osc = audioContext.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = 600;
          osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
          
          const oscGain = audioContext.createGain();
          oscGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          osc.connect(oscGain);
          oscGain.connect(filter);
          oscillators.push(osc);
          
          masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
          masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          noise.start();
          noise.stop(audioContext.currentTime + duration);
          osc.start();
          osc.stop(audioContext.currentTime + 0.1);
          break;
        }
        
        case FIRE: {
          // Improved fire crackling sound
          duration = 0.6;
          
          // Create a bandpass filter for the main fire sound
          const fireFilter = audioContext.createBiquadFilter();
          fireFilter.type = 'bandpass';
          fireFilter.frequency.value = 400;
          fireFilter.Q.value = 0.5;
          fireFilter.connect(masterGain);
          
          // Create a highpass filter for the crackles
          const crackleFilter = audioContext.createBiquadFilter();
          crackleFilter.type = 'highpass';
          crackleFilter.frequency.value = 2000;
          crackleFilter.connect(masterGain);
          
          // Base fire sound (filtered noise with lower frequency content)
          const baseNoise = createNoise(duration);
          const baseNoiseGain = audioContext.createGain();
          baseNoiseGain.gain.setValueAtTime(volumeScale * 0.15, audioContext.currentTime);
          baseNoiseGain.gain.exponentialRampToValueAtTime(volumeScale * 0.05, audioContext.currentTime + duration);
          
          baseNoise.connect(baseNoiseGain);
          baseNoiseGain.connect(fireFilter);
          oscillators.push(baseNoise);
          
          // Mid-range fire sound
          const midNoise = createNoise(duration);
          const midNoiseGain = audioContext.createGain();
          midNoiseGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          midNoiseGain.gain.exponentialRampToValueAtTime(volumeScale * 0.03, audioContext.currentTime + duration);
          
          // Create a bandpass filter for mid-range
          const midFilter = audioContext.createBiquadFilter();
          midFilter.type = 'bandpass';
          midFilter.frequency.value = 800;
          midFilter.Q.value = 1;
          
          midNoise.connect(midNoiseGain);
          midNoiseGain.connect(midFilter);
          midFilter.connect(masterGain);
          oscillators.push(midNoise);
          
          // Realistic crackling effect with multiple layers
          for (let i = 0; i < 8; i++) {
            const delay = Math.random() * 0.4;
            
            // Create a short noise burst for each crackle
            const crackleLength = 0.02 + Math.random() * 0.03;
            const crackle = createNoise(crackleLength);
            
            const crackleGain = audioContext.createGain();
            crackleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            crackleGain.gain.linearRampToValueAtTime(volumeScale * (0.05 + Math.random() * 0.15), 
                                                   audioContext.currentTime + delay + 0.005);
            crackleGain.gain.exponentialRampToValueAtTime(0.001, 
                                                        audioContext.currentTime + delay + crackleLength);
            
            // Individual filter for each crackle to vary the sound
            const individualFilter = audioContext.createBiquadFilter();
            individualFilter.type = 'bandpass';
            individualFilter.frequency.value = 2000 + Math.random() * 6000;
            individualFilter.Q.value = 1 + Math.random() * 5;
            
            crackle.connect(crackleGain);
            crackleGain.connect(individualFilter);
            individualFilter.connect(crackleFilter);
            oscillators.push(crackle);
            
            crackle.start(audioContext.currentTime + delay);
            crackle.stop(audioContext.currentTime + delay + crackleLength);
          }
          
          // Add a subtle low-frequency rumble
          const rumble = audioContext.createOscillator();
          rumble.type = 'sine';
          rumble.frequency.value = 40 + Math.random() * 30;
          
          const rumbleGain = audioContext.createGain();
          rumbleGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          rumble.connect(rumbleGain);
          rumbleGain.connect(masterGain);
          oscillators.push(rumble);
          
          masterGain.gain.setValueAtTime(volumeScale * 0.8, audioContext.currentTime);
          masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          baseNoise.start();
          baseNoise.stop(audioContext.currentTime + duration);
          midNoise.start();
          midNoise.stop(audioContext.currentTime + duration);
          rumble.start();
          rumble.stop(audioContext.currentTime + duration);
          break;
        }
        
        case STONE:
        case WALL:
        case COBBLESTONE: {
          // Stone placement sound (solid thud)
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 500;
          
          // Impact sound
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sine';
          osc1.frequency.value = 120;
          osc1.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + duration);
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Short noise burst for impact
          const noise = createNoise(0.1);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.5, audioContext.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          noise.start();
          noise.stop(audioContext.currentTime + 0.1);
          break;
        }
        
        case WOOD: {
          // Wood placement sound (wooden knock)
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 1000;
          filter.Q.value = 2;
          
          // Wooden impact
          const osc1 = audioContext.createOscillator();
          osc1.type = 'triangle';
          osc1.frequency.value = 300;
          osc1.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.2);
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Secondary resonance
          const osc2 = audioContext.createOscillator();
          osc2.type = 'sine';
          osc2.frequency.value = 180;
          
          const osc2Gain = audioContext.createGain();
          osc2Gain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime + 0.01);
          osc2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc2.connect(osc2Gain);
          osc2Gain.connect(filter);
          oscillators.push(osc2);
          
          osc1.start();
          osc1.stop(audioContext.currentTime + 0.2);
          osc2.start();
          osc2.stop(audioContext.currentTime + duration);
          break;
        }
        
        case LAVA: {
          // Lava bubbling sound
          duration = 0.5;
          filter.type = 'lowpass';
          filter.frequency.value = 600;
          
          // Base rumble
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sawtooth';
          osc1.frequency.value = 80;
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale * 0.4, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Bubbling sounds
          for (let i = 0; i < 3; i++) {
            const delay = i * 0.1;
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 150 + Math.random() * 100;
            bubble.frequency.exponentialRampToValueAtTime(50 + Math.random() * 50, audioContext.currentTime + delay + 0.2);
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.3, audioContext.currentTime + delay + 0.05);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.2);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          break;
        }
        
        case ICE: {
          // Ice crystal sound (high pitched, glassy)
          duration = 0.4;
          filter.type = 'highpass';
          filter.frequency.value = 2000;
          
          // High pitched crystal sound
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sine';
          osc1.frequency.value = 1200 + Math.random() * 400;
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          osc1Gain.gain.linearRampToValueAtTime(volumeScale * 0.4, audioContext.currentTime + 0.05);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Secondary crystal tones
          for (let i = 0; i < 2; i++) {
            const osc2 = audioContext.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 800 + (i * 400) + Math.random() * 200;
            
            const osc2Gain = audioContext.createGain();
            osc2Gain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime + 0.05 * i);
            osc2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2 + (0.1 * i));
            
            osc2.connect(osc2Gain);
            osc2Gain.connect(filter);
            oscillators.push(osc2);
            osc2.start();
            osc2.stop(audioContext.currentTime + duration);
          }
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          break;
        }
        
        case 'eraser': {
          // Eraser/vacuum sound
          duration = 0.2;
          filter.type = 'highpass';
          filter.frequency.value = 2000;
          
          // Whoosh sound
          const noise = createNoise(duration);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          // Quick sweep
          const osc = audioContext.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = 2000;
          osc.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + duration);
          
          const oscGain = audioContext.createGain();
          oscGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc.connect(oscGain);
          oscGain.connect(filter);
          oscillators.push(osc);
          
          noise.start();
          noise.stop(audioContext.currentTime + duration);
          osc.start();
          osc.stop(audioContext.currentTime + duration);
          break;
        }
        
        case BOMB:
        case BIG_BOMB:
        case WATER_BOMB:
        case FIRE_BOMB:
        case CRYO_BOMB:
        case NUKE_BOMB: {
          // Heavy object placement sound
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 400;
          
          // Deep thud
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sine';
          osc1.frequency.value = 80;
          osc1.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + duration);
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale * 1.2, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Impact noise
          const noise = createNoise(0.1);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          noise.start();
          noise.stop(audioContext.currentTime + 0.1);
          break;
        }
        
        case DIRT: {
          // Dirt placement sound (soft thud with some texture)
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 800;
          
          // Soft impact sound
          const impact = createNoise(0.15);
          const impactFilter = audioContext.createBiquadFilter();
          impactFilter.type = 'bandpass';
          impactFilter.frequency.value = 200;
          impactFilter.Q.value = 0.7;
          
          const impactGain = audioContext.createGain();
          impactGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
          
          impact.connect(impactGain);
          impactGain.connect(impactFilter);
          impactFilter.connect(filter);
          oscillators.push(impact);
          
          // Dirt particles settling
          const particles = createNoise(duration);
          const particlesFilter = audioContext.createBiquadFilter();
          particlesFilter.type = 'bandpass';
          particlesFilter.frequency.value = 500;
          particlesFilter.Q.value = 0.5;
          
          const particlesGain = audioContext.createGain();
          particlesGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime + 0.05);
          particlesGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          particles.connect(particlesGain);
          particlesGain.connect(particlesFilter);
          particlesFilter.connect(filter);
          oscillators.push(particles);
          
          // Add a bit of low end for the impact
          const thud = audioContext.createOscillator();
          thud.type = 'sine';
          thud.frequency.value = 80;
          thud.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
          
          const thudGain = audioContext.createGain();
          thudGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
          
          thud.connect(thudGain);
          thudGain.connect(filter);
          oscillators.push(thud);
          
          impact.start();
          impact.stop(audioContext.currentTime + 0.15);
          particles.start();
          particles.stop(audioContext.currentTime + duration);
          thud.start();
          thud.stop(audioContext.currentTime + 0.2);
          break;
        }
        
        case FLOUR:
        case SAWDUST: {
          // Flour/Sawdust placement sound (soft puff with some particles)
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 1000;
          
          // Soft puff sound
          const puff = createNoise(0.2);
          const puffFilter = audioContext.createBiquadFilter();
          puffFilter.type = 'bandpass';
          puffFilter.frequency.value = 800;
          puffFilter.Q.value = 0.5;
          
          const puffGain = audioContext.createGain();
          puffGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          puffGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
          
          puff.connect(puffGain);
          puffGain.connect(puffFilter);
          puffFilter.connect(filter);
          oscillators.push(puff);
          
          // Particles settling
          const particles = createNoise(duration);
          const particlesFilter = audioContext.createBiquadFilter();
          particlesFilter.type = 'bandpass';
          particlesFilter.frequency.value = 1200;
          particlesFilter.Q.value = 0.8;
          
          const particlesGain = audioContext.createGain();
          particlesGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime + 0.05);
          particlesGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          particles.connect(particlesGain);
          particlesGain.connect(particlesFilter);
          particlesFilter.connect(filter);
          oscillators.push(particles);
          
          puff.start();
          puff.stop(audioContext.currentTime + 0.2);
          particles.start();
          particles.stop(audioContext.currentTime + duration);
          break;
        }
        
        case WHEAT_SEEDS:
        case OAK_SEEDS:
        case BIRCH_SEEDS: {
          // Seeds dropping sound (light, rattling)
          duration = 0.25;
          filter.type = 'bandpass';
          filter.frequency.value = 3000;
          filter.Q.value = 1;
          
          // Seed impact sounds - multiple small impacts
          for (let i = 0; i < 5; i++) {
            const delay = i * 0.03;
            const seedNoise = createNoise(0.05);
            
            const seedFilter = audioContext.createBiquadFilter();
            seedFilter.type = 'bandpass';
            seedFilter.frequency.value = 2000 + Math.random() * 2000;
            seedFilter.Q.value = 2;
            
            const seedGain = audioContext.createGain();
            seedGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            seedGain.gain.linearRampToValueAtTime(volumeScale * 0.05, audioContext.currentTime + delay + 0.01);
            seedGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.05);
            
            seedNoise.connect(seedGain);
            seedGain.connect(seedFilter);
            seedFilter.connect(filter);
            oscillators.push(seedNoise);
            
            seedNoise.start(audioContext.currentTime + delay);
            seedNoise.stop(audioContext.currentTime + delay + 0.05);
          }
          break;
        }
        
        case GRASS: {
          // Grass placement sound (light rustling)
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 2000;
          filter.Q.value = 1;
          
          // Rustling sound
          const rustle = createNoise(duration);
          
          // Shape the noise to sound like rustling leaves
          const rustleFilter = audioContext.createBiquadFilter();
          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 3000;
          rustleFilter.Q.value = 1;
          
          const rustleGain = audioContext.createGain();
          rustleGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime);
          
          // Create some movement in the sound
          for (let i = 0; i < 5; i++) {
            const time = audioContext.currentTime + (i * duration / 5);
            rustleGain.gain.setValueAtTime(volumeScale * (0.02 + Math.random() * 0.08), time);
          }
          
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          rustle.connect(rustleGain);
          rustleGain.connect(rustleFilter);
          rustleFilter.connect(filter);
          oscillators.push(rustle);
          
          rustle.start();
          rustle.stop(audioContext.currentTime + duration);
          break;
        }
        
        case OIL: {
          // Oil pouring sound (viscous liquid)
          duration = 0.4;
          filter.type = 'lowpass';
          filter.frequency.value = 600;
          
          // Base liquid sound
          const liquid = createNoise(duration);
          const liquidFilter = audioContext.createBiquadFilter();
          liquidFilter.type = 'lowpass';
          liquidFilter.frequency.value = 400;
          
          const liquidGain = audioContext.createGain();
          liquidGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          liquidGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          liquid.connect(liquidGain);
          liquidGain.connect(liquidFilter);
          liquidFilter.connect(filter);
          oscillators.push(liquid);
          
          // Viscous bubbling
          for (let i = 0; i < 2; i++) {
            const delay = 0.1 + (i * 0.15);
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 100 + Math.random() * 50;
            bubble.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + delay + 0.2);
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.1, audioContext.currentTime + delay + 0.05);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.2);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          liquid.start();
          liquid.stop(audioContext.currentTime + duration);
          break;
        }
        
        case GAS:
        case CARBON_DIOXIDE:
        case OXYGEN: {
          // Gas release sound (hissing)
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 5000;
          filter.Q.value = 2;
          
          // Hissing noise
          const hiss = createNoise(duration);
          
          const hissGain = audioContext.createGain();
          hissGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          hissGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          hiss.connect(hissGain);
          hissGain.connect(filter);
          oscillators.push(hiss);
          
          // Add some movement to the hiss
          const hissFilter = audioContext.createBiquadFilter();
          hissFilter.type = 'bandpass';
          hissFilter.Q.value = 5;
          hissFilter.frequency.value = 4000;
          hissFilter.frequency.exponentialRampToValueAtTime(6000, audioContext.currentTime + 0.1);
          hissFilter.frequency.exponentialRampToValueAtTime(3000, audioContext.currentTime + duration);
          
          hissGain.connect(hissFilter);
          hissFilter.connect(masterGain);
          
          hiss.start();
          hiss.stop(audioContext.currentTime + duration);
          break;
        }
        
        case ACID: {
          // Acid sound (sizzling)
          duration = 0.4;
          filter.type = 'bandpass';
          filter.frequency.value = 3000;
          filter.Q.value = 1;
          
          // Base sizzle
          const sizzle = createNoise(duration);
          
          const sizzleGain = audioContext.createGain();
          sizzleGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          sizzleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          sizzle.connect(sizzleGain);
          sizzleGain.connect(filter);
          oscillators.push(sizzle);
          
          // Add bubbling/reactive sounds
          for (let i = 0; i < 6; i++) {
            const delay = Math.random() * 0.3;
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 2000 + Math.random() * 2000;
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.05, audioContext.currentTime + delay + 0.01);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.05);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          sizzle.start();
          sizzle.stop(audioContext.currentTime + duration);
          break;
        }
        
        case LAVA: {
          // Lava sound (deep bubbling) - made a bit quieter by default
          duration = 0.5;
          filter.type = 'lowpass';
          filter.frequency.value = 300;
          
          // Base rumble
          const rumble = audioContext.createOscillator();
          rumble.type = 'sine';
          rumble.frequency.value = 60;
          
          const rumbleGain = audioContext.createGain();
          rumbleGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          rumble.connect(rumbleGain);
          rumbleGain.connect(filter);
          oscillators.push(rumble);
          
          // Bubbling effect
          for (let i = 0; i < 3; i++) {
            const delay = Math.random() * 0.3;
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 100 + Math.random() * 50;
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.15, audioContext.currentTime + delay + 0.05);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.2);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          rumble.start();
          rumble.stop(audioContext.currentTime + duration);
          break;
        }
        
        case 19: // Copper
        case 17: // Iron
        case 20: // Steel
        {
          // Metallic sound for metals (copper, iron, steel)
          duration = 0.4;
          
          // Create a metallic impact sound
          const impact = createNoise(0.05);
          const impactFilter = audioContext.createBiquadFilter();
          impactFilter.type = 'bandpass';
          impactFilter.frequency.value = 2000;
          impactFilter.Q.value = 5; // Higher Q for more resonance
          
          const impactGain = audioContext.createGain();
          impactGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
          
          impact.connect(impactGain);
          impactGain.connect(impactFilter);
          impactFilter.connect(masterGain);
          oscillators.push(impact);
          
          // Metallic resonance
          const resonance1 = audioContext.createOscillator();
          resonance1.type = 'sine';
          resonance1.frequency.value = 1200 + (elementType === 19 ? 400 : 0); // Copper higher pitch
          
          const resonance2 = audioContext.createOscillator();
          resonance2.type = 'sine';
          resonance2.frequency.value = 1800 + (elementType === 20 ? 600 : 0); // Steel higher pitch
          
          // Frequency modulation for more metallic sound
          resonance1.frequency.setValueAtTime(resonance1.frequency.value * 1.2, audioContext.currentTime + 0.01);
          resonance1.frequency.exponentialRampToValueAtTime(resonance1.frequency.value * 0.5, audioContext.currentTime + duration);
          
          resonance2.frequency.setValueAtTime(resonance2.frequency.value * 1.1, audioContext.currentTime + 0.01);
          resonance2.frequency.exponentialRampToValueAtTime(resonance2.frequency.value * 0.6, audioContext.currentTime + duration);
          
          // Create gain nodes with quick decay for metallic sound
          const resonanceGain1 = audioContext.createGain();
          resonanceGain1.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          resonanceGain1.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          const resonanceGain2 = audioContext.createGain();
          resonanceGain2.gain.setValueAtTime(volumeScale * 0.15, audioContext.currentTime);
          resonanceGain2.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration * 0.8);
          
          // Connect everything
          resonance1.connect(resonanceGain1);
          resonanceGain1.connect(masterGain);
          resonance2.connect(resonanceGain2);
          resonanceGain2.connect(masterGain);
          
          oscillators.push(resonance1);
          oscillators.push(resonance2);
          
          // Start and stop
          impact.start();
          impact.stop(audioContext.currentTime + 0.05);
          resonance1.start();
          resonance1.stop(audioContext.currentTime + duration);
          resonance2.start();
          resonance2.stop(audioContext.currentTime + duration * 0.8);
          break;
        }
        
        default: {
          // More natural generic placement sound based on element ID
          duration = 0.25;
          
          // Create a more natural impact sound using noise + tone
          const impactNoise = createNoise(0.1);
          const impactFilter = audioContext.createBiquadFilter();
          impactFilter.type = 'bandpass';
          impactFilter.frequency.value = 500 + (elementType % 10) * 300;
          impactFilter.Q.value = 1;
          
          const impactGain = audioContext.createGain();
          impactGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          impactNoise.connect(impactGain);
          impactGain.connect(impactFilter);
          impactFilter.connect(masterGain);
          oscillators.push(impactNoise);
          
          // Resonance tone
          const tone = audioContext.createOscillator();
          tone.type = ['sine', 'triangle'][elementType % 2]; // Avoid harsh square/sawtooth waves
          tone.frequency.value = 200 + (elementType % 15) * 40;
          tone.frequency.exponentialRampToValueAtTime(tone.frequency.value * 0.7, audioContext.currentTime + duration);
          
          const toneGain = audioContext.createGain();
          toneGain.gain.setValueAtTime(volumeScale * 0.15, audioContext.currentTime + 0.01);
          toneGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          tone.connect(toneGain);
          toneGain.connect(masterGain);
          oscillators.push(tone);
          
          // Add some texture
          const texture = createNoise(duration - 0.05);
          const textureFilter = audioContext.createBiquadFilter();
          textureFilter.type = 'bandpass';
          textureFilter.frequency.value = 1000 + (elementType % 8) * 200;
          textureFilter.Q.value = 2;
          
          const textureGain = audioContext.createGain();
          textureGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime + 0.05);
          textureGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          texture.connect(textureGain);
          textureGain.connect(textureFilter);
          textureFilter.connect(masterGain);
          oscillators.push(texture);
          
          impactNoise.start();
          impactNoise.stop(audioContext.currentTime + 0.1);
          tone.start();
          tone.stop(audioContext.currentTime + duration);
          texture.start(audioContext.currentTime + 0.05);
          texture.stop(audioContext.currentTime + duration);
          break;
        }
      }
      
      // Track this sound in our pool
      const soundObj = { oscillators, gainNode: masterGain, startTime: audioContext.currentTime };
      soundPool.push(soundObj);
      
      // Remove from pool after it's done
      setTimeout(() => {
        const index = soundPool.indexOf(soundObj);
        if (index !== -1) {
          soundPool.splice(index, 1);
        }
      }, duration * 1000 + 100); // Add a small buffer to ensure it's fully played
    }

    // Function to play lightning sound effect
    function playLightningSound() {
      if (!audioContext) {
        initAudioContext();
        if (!audioContext) return;
      }
      
      const now = Date.now();
      if (now - lastLightningSound < 200) return; // Throttle lightning sounds
      lastLightningSound = now;
      
      const duration = 1.2;
      const volumeScale = 0.6 * masterVolume * (elementVolumes[LIGHTNING] || 1.0);
      
      // Create master gain node
      const masterGain = audioContext.createGain();
      masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      masterGain.connect(audioContext.destination);
      
      // Create noise buffer
      const bufferSize = audioContext.sampleRate * 0.1;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      // Main thunder crack - sharp and loud
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      
      const noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(volumeScale * 1.5, audioContext.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
      
      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 800;
      filter.Q.value = 0.5;
      
      noise.connect(noiseGain);
      noiseGain.connect(filter);
      filter.connect(masterGain);
      
      // Low rumble
      const rumble = audioContext.createOscillator();
      rumble.type = 'sawtooth';
      rumble.frequency.value = 60;
      rumble.frequency.exponentialRampToValueAtTime(25, audioContext.currentTime + duration);
      
      const rumbleGain = audioContext.createGain();
      rumbleGain.gain.setValueAtTime(volumeScale * 0.8, audioContext.currentTime + 0.1);
      rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      rumble.connect(rumbleGain);
      rumbleGain.connect(masterGain);
      
      // Start sounds
      noise.start();
      noise.stop(audioContext.currentTime + 0.4);
      rumble.start();
      rumble.stop(audioContext.currentTime + duration);
    }

    // Sound throttling variables
    let lastExplosionSound = 0;
    let lastBouncingSound = 0;
    let lastGlassBreakSound = 0;
    let lastLightningSound = 0;

    // Function to play explosion sounds unique to each bomb type
    function playExplosionSound(bombType) {
      if (!audioContext) {
        initAudioContext();
        if (!audioContext) return;
      }
      
      const now = Date.now();
      if (now - lastExplosionSound < 100) return; // Throttle explosion sounds
      lastExplosionSound = now;
      
      const elementVolumeKey = bombType || 'explosion';
      const volumeScale = 0.8 * masterVolume * (elementVolumes[elementVolumeKey] || 1.0);
      
      // Create master gain node
      const masterGain = audioContext.createGain();
      masterGain.connect(audioContext.destination);
      
      let duration = 1.5;
      let mainFreq = 80;
      let crackleIntensity = 0.3;
      
      // Customize sound based on bomb type
      switch(bombType) {
        case BOMB:
          // Standard explosive - sharp crack with debris
          mainFreq = 80;
          duration = 1.0;
          crackleIntensity = 0.4;
          break;
        case BIG_BOMB:
          // Deeper, longer explosion
          mainFreq = 50;
          duration = 2.0;
          crackleIntensity = 0.6;
          break;
        case WATER_BOMB:
          // Wet splashing explosion
          mainFreq = 120;
          duration = 1.2;
          crackleIntensity = 0.2;
          break;
        case FIRE_BOMB:
          // Whooshing fire explosion
          mainFreq = 100;
          duration = 1.5;
          crackleIntensity = 0.8;
          break;
        case CRYO_BOMB:
          // Crystalline shattering explosion
          mainFreq = 200;
          duration = 1.0;
          crackleIntensity = 0.1;
          break;
        case NUKE_BOMB:
          // Massive, earth-shaking explosion
          mainFreq = 30;
          duration = 3.0;
          crackleIntensity = 1.0;
          break;
        default:
          mainFreq = 80;
          duration = 1.0;
          crackleIntensity = 0.3;
      }
      
      // Initial blast
      const blast = audioContext.createOscillator();
      blast.type = 'sawtooth';
      blast.frequency.value = mainFreq;
      blast.frequency.exponentialRampToValueAtTime(mainFreq * 0.3, audioContext.currentTime + 0.3);
      
      const blastGain = audioContext.createGain();
      blastGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      blastGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
      
      blast.connect(blastGain);
      blastGain.connect(masterGain);
      
      // Explosion noise
      const bufferSize = audioContext.sampleRate * 0.3;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      
      const noiseFilter = audioContext.createBiquadFilter();
      noiseFilter.type = 'bandpass';
      noiseFilter.frequency.value = bombType === CRYO_BOMB ? 3000 : 800;
      noiseFilter.Q.value = 0.7;
      
      const noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(volumeScale * 0.7, audioContext.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
      
      noise.connect(noiseGain);
      noiseGain.connect(noiseFilter);
      noiseFilter.connect(masterGain);
      
      // Rumble/echo
      const rumble = audioContext.createOscillator();
      rumble.type = 'sine';
      rumble.frequency.value = mainFreq * 0.5;
      rumble.frequency.exponentialRampToValueAtTime(mainFreq * 0.2, audioContext.currentTime + duration);
      
      const rumbleGain = audioContext.createGain();
      rumbleGain.gain.setValueAtTime(volumeScale * 0.5, audioContext.currentTime + 0.2);
      rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      rumble.connect(rumbleGain);
      rumbleGain.connect(masterGain);
      
      // Special effects per bomb type
      if (bombType === WATER_BOMB) {
        // Add splashing sounds
        for (let i = 0; i < 5; i++) {
          const splash = audioContext.createOscillator();
          splash.type = 'sine';
          splash.frequency.value = 300 + Math.random() * 400;
          
          const splashGain = audioContext.createGain();
          splashGain.gain.setValueAtTime(0, audioContext.currentTime + i * 0.05);
          splashGain.gain.linearRampToValueAtTime(volumeScale * 0.2, audioContext.currentTime + i * 0.05 + 0.02);
          splashGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + i * 0.05 + 0.3);
          
          splash.connect(splashGain);
          splashGain.connect(masterGain);
          splash.start();
          splash.stop(audioContext.currentTime + duration);
        }
      } else if (bombType === CRYO_BOMB) {
        // Add crystalline breaking sounds
        for (let i = 0; i < 8; i++) {
          const crystal = audioContext.createOscillator();
          crystal.type = 'sine';
          crystal.frequency.value = 1000 + Math.random() * 2000;
          
          const crystalGain = audioContext.createGain();
          crystalGain.gain.setValueAtTime(0, audioContext.currentTime + i * 0.02);
          crystalGain.gain.linearRampToValueAtTime(volumeScale * 0.15, audioContext.currentTime + i * 0.02 + 0.01);
          crystalGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + i * 0.02 + 0.2);
          
          crystal.connect(crystalGain);
          crystalGain.connect(masterGain);
          crystal.start();
          crystal.stop(audioContext.currentTime + duration);
        }
      }
      
      // Start sounds
      blast.start();
      blast.stop(audioContext.currentTime + 0.5);
      noise.start();
      noise.stop(audioContext.currentTime + 0.4);
      rumble.start();
      rumble.stop(audioContext.currentTime + duration);
    }

    // Function to play bouncing sound for bouncy ball
    function playBouncingSound() {
      if (!audioContext) {
        initAudioContext();
        if (!audioContext) return;
      }
      
      const now = Date.now();
      if (now - lastBouncingSound < 50) return; // Throttle bouncing sounds
      lastBouncingSound = now;
      
      const volumeScale = 0.4 * masterVolume * (elementVolumes[BOUNCY_BALL] || 1.0);
      const duration = 0.3;
      
      // Create master gain node
      const masterGain = audioContext.createGain();
      masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      masterGain.connect(audioContext.destination);
      
      // Characteristic "boing" sound
      const boing = audioContext.createOscillator();
      boing.type = 'sine';
      boing.frequency.value = 150;
      boing.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.05);
      boing.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + duration);
      
      const boingGain = audioContext.createGain();
      boingGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      boingGain.gain.linearRampToValueAtTime(volumeScale * 0.8, audioContext.currentTime + 0.05);
      boingGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      // Add harmonic for richness
      const harmonic = audioContext.createOscillator();
      harmonic.type = 'triangle';
      harmonic.frequency.value = 300;
      harmonic.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.05);
      harmonic.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + duration);
      
      const harmonicGain = audioContext.createGain();
      harmonicGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
      harmonicGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      // Filter for characteristic "springy" sound
      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 400;
      filter.Q.value = 2;
      
      boing.connect(boingGain);
      boingGain.connect(filter);
      filter.connect(masterGain);
      
      harmonic.connect(harmonicGain);
      harmonicGain.connect(filter);
      
      // Start sounds
      boing.start();
      boing.stop(audioContext.currentTime + duration);
      harmonic.start();
      harmonic.stop(audioContext.currentTime + duration);
    }

    // Function to play glass breaking sound when cobblestone hits glass
    function playGlassBreakSound() {
      if (!audioContext) {
        initAudioContext();
        if (!audioContext) return;
      }
      
      const now = Date.now();
      if (now - lastGlassBreakSound < 100) return; // Throttle glass break sounds
      lastGlassBreakSound = now;
      
      const volumeScale = 0.5 * masterVolume * (elementVolumes[GLASS_SHARD] || 1.0);
      const duration = 0.6;
      
      // Create master gain node
      const masterGain = audioContext.createGain();
      masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      masterGain.connect(audioContext.destination);
      
      // Initial impact sound
      const impact = audioContext.createOscillator();
      impact.type = 'triangle';
      impact.frequency.value = 800;
      impact.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
      
      const impactGain = audioContext.createGain();
      impactGain.gain.setValueAtTime(volumeScale * 0.8, audioContext.currentTime);
      impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
      
      impact.connect(impactGain);
      impactGain.connect(masterGain);
      
      // Glass shattering - multiple high-frequency components
      for (let i = 0; i < 8; i++) {
        const shard = audioContext.createOscillator();
        shard.type = 'sine';
        shard.frequency.value = 1200 + Math.random() * 1800;
        
        const shardGain = audioContext.createGain();
        const delay = Math.random() * 0.2;
        shardGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
        shardGain.gain.linearRampToValueAtTime(volumeScale * (0.2 + Math.random() * 0.3), audioContext.currentTime + delay + 0.01);
        shardGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.3);
        
        // High-pass filter for glassy sound
        const shardFilter = audioContext.createBiquadFilter();
        shardFilter.type = 'highpass';
        shardFilter.frequency.value = 1000;
        shardFilter.Q.value = 0.5;
        
        shard.connect(shardGain);
        shardGain.connect(shardFilter);
        shardFilter.connect(masterGain);
        
        shard.start();
        shard.stop(audioContext.currentTime + duration);
      }
      
      // Falling glass pieces
      const falling = audioContext.createOscillator();
      falling.type = 'sawtooth';
      falling.frequency.value = 600;
      falling.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + duration);
      
      const fallingGain = audioContext.createGain();
      fallingGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime + 0.1);
      fallingGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      const fallingFilter = audioContext.createBiquadFilter();
      fallingFilter.type = 'bandpass';
      fallingFilter.frequency.value = 800;
      fallingFilter.Q.value = 1;
      
      falling.connect(fallingGain);
      fallingGain.connect(fallingFilter);
      fallingFilter.connect(masterGain);
      
      // Start sounds
      impact.start();
      impact.stop(audioContext.currentTime + 0.1);
      falling.start();
      falling.stop(audioContext.currentTime + duration);
    }
    /***************************************
     * RENDER & HUD
     ***************************************/
     // Cache for element class names to avoid repeated lookups
     const elementClassCache = {};
     
     // Cache for transparent elements
     const transparentElements = new Set([GAS, WATER_VAPOR, BURNING_GAS, CARBON_DIOXIDE, OXYGEN, HELIUM]);
     
     // Class to color mapping for canvas rendering
     const elementClassColors = {
       'sand': '#e9d8a6',
       'wall': '#606060',
       'water': '#1e90ff',
       'lava': '#ff4500',
       'stone': '#808080',
       'water-vapor': 'rgba(173, 216, 230, 0.7)',
       'cloud': '#f0f0f0',
       'copper': '#cd7f32',
       'steel': '#a9a9a9',
       'ice': '#add8e6',
       'wood': '#8b4513',
       'fire': '#ff4500',
       'smoke': 'rgba(105, 105, 105, 0.7)',
       'burning-wood': '#ff6347',
       'burning-organic': '#ff6347',
       'ash': '#a9a9a9',
       'glass': 'rgba(240, 248, 255, 0.8)',
       'bomb': '#000000',
       'dirt': '#8b4513',
       'wet-dirt': '#654321',
       'wheat-seeds': '#f5deb3',
       'wheat': '#edc9af',
       'flour': '#fff8dc',
       'dough': '#f5deb3',
       'bread': '#d2b48c',
       'root': '#8b4513',
       'burning-root': '#ff6347',
       'dead-root': '#a9a9a9',
       'spark': '#ffff00',
       'charged-copper': '#ffa500',
       'charged-down-copper': '#cd7f32',
       'oak-seeds': '#a0522d',
       'oak-leaves': '#228b22',
       'oak-baby-leaves': '#32cd32',
       'dead-oak': '#a9a9a9',
       'birch-seeds': '#f5f5dc',
       'birch-leaves': '#9acd32',
       'birch-baby-leaves': '#adff2f',
       'birch-wood': '#f5f5dc',
       'dead-birch': '#d3d3d3',
       'wet-sand': '#d2b48c',
       'grass': '#7cfc00',
       'dead-plant': '#a9a9a9',
       'burning-leaves': '#ff6347',
       'gas': 'rgba(255, 255, 224, 0.7)',
       'burning-gas': '#ff6347',
       'cooler': '#87ceeb',
       'heater': '#ff6347',
       'heat-separator': '#b0c4de',
       'charged-heat-separator': '#ffa500',
       'charged-down-heat-separator': '#b0c4de',
       'input': '#32cd32',
       'charged-input': '#ffa500',
       'output': '#ff6347',
       'charged-output': '#ffa500',
       'not-gate': '#b0c4de',
       'and-gate': '#b0c4de',
       'blocker': '#8b0000',
       'charged-blocker': '#ffa500',
       'cloner': '#9370db',
       'coal': '#2f4f4f',
       'coal-lump': '#2f4f4f',
       'burning-coal': '#ff6347',
       'burning-coal-lump': '#ff6347',
       'thermite': '#a0522d',
       'burning-thermite': '#ff6347',
       'acid': '#32cd32',
       'acid-steam': 'rgba(173, 255, 47, 0.7)',
       'acid-cloud': 'rgba(173, 255, 47, 0.7)',
       'slime': '#32cd32',
       'carbon-dioxide': 'rgba(220, 220, 220, 0.7)',
       'oxygen': 'rgba(240, 248, 255, 0.7)',
       'bird': '#8b4513',
       'meat': '#cd5c5c',
       'cooked-meat': '#a52a2a',
       'cobblestone': '#696969',
       'oil': '#2f4f4f',
       'big-bomb': '#000000',
       'water-bomb': '#0000ff',
       'fire-bomb': '#ff0000',
       'cryo-bomb': '#00ffff',
       'nuke-bomb': '#006400',
       'helium': 'rgba(255, 255, 224, 0.7)',
       'bouncy-ball': '#ff0000',
       'cell-element': '#ff69b4',
       'dead-cell': '#696969',
       'blood': '#8b0000',
       'glass-shard': '#b0e0e6',
       'sawdust': '#d9c29e',
       'salt': '#ffffff',
       'salt-water': '#1ea5ff',
       'grind': '#777777',
       'glue': '#e0e0a0',
       'sugar': '#ffffff',
       'sugar-water': '#e0f0ff',
       'plant': '#22aa22',
       'diamond': '#b9f2ff',
       'diamond-shards': 'rgba(185, 242, 255, 0.8)',
       'molten-diamond': '#80e0ff',
       'confetti': '#ff33ff', /* Bright consistent color */
       'dabicco': 'rgb(255,0,255)', /* Random colors handled in getTemperatureAdjustedColor */
       'oxidized-copper': '#66aa88',
       'molten-copper': '#ff8844',
       'molten-salt': '#ffddaa',
       'molten-steel': '#ff6600',
       'molten-sugar': '#ddaa88',
       'molten-glass': '#ffaa88',
       'molten-electrical': '#ff7722'
     };
     
     // Function to get color for element class name
     function getColorForElementClass(className) {
       return elementClassColors[className] || '#808080'; // Default gray if not found
     }
     
     function renderCell(x, y) {
      const e = grid[y][x];
      const cell = cells[y][x]; // Virtual cell for compatibility
      
      // Update the virtual cell's state (for compatibility with existing code)
      cell.classList._className = 'cell';
      cell.style.backgroundColor = '';
      cell.style.opacity = '';
      
      if (e === EMPTY) {
        return;
      }
      
      // Calculate position and size for canvas rendering
      const cellSize = window.cellSize;
      const pixelX = Math.floor(x * cellSize);
      const pixelY = Math.floor(y * cellSize);
      const pixelSize = Math.ceil(cellSize); // Ensure no gaps between cells
      
      // Get base color
      let baseColor = elementBaseColors[e];
      
      // Check if it's a custom element
      if (!baseColor && e >= CUSTOM_ELEMENT_START && customElements[e]) {
        baseColor = customElements[e].color;
      }
      
      let finalColor;
      let opacity = 1.0;
      
      if (baseColor) {
        // Get temperature
        const temperature = temp[y][x] !== null ? temp[y][x] : 20;
        
        // Apply temperature and random variations
        finalColor = getTemperatureAdjustedColor(baseColor, temperature, e, x, y);
        
        // Update the virtual cell for compatibility
        cell.style.backgroundColor = finalColor;
        
        // Special case for smoke opacity
        if (e === SMOKE) {
          const max = smokeMaxLife[y][x];
          const life = smokeLife[y][x];
          opacity = Math.max(0, 1 - (life / max));
          cell.style.opacity = opacity.toString();
        }
        // Special case for other transparent elements
        else if (transparentElements.has(e)) {
          opacity = 0.7;
          cell.style.opacity = '0.7';
        }
      } else {
        // Fallback to class-based styling
        let elementClass = '';
        
        switch (e) {
          case SAND: elementClass = 'sand'; break;
          case WALL: elementClass = 'wall'; break;
          case WATER: elementClass = 'water'; break;
          case SNOW: elementClass = 'snow'; break;
          case LAVA: elementClass = 'lava'; break;
          case STONE: elementClass = 'stone'; break;
          case WATER_VAPOR: elementClass = 'water-vapor'; break;
          case CLOUD: elementClass = 'cloud'; break;
          case BASALT: elementClass = 'stone'; break;
          case OBSIDIAN: elementClass = 'stone'; break;
          case MOLTEN_SLAG: elementClass = 'lava'; break;
          case COPPER: elementClass = 'copper'; break;
          case STEEL: elementClass = 'steel'; break;
          case ICE: elementClass = 'ice'; break;
          case WOOD: elementClass = 'wood'; break;
          case FIRE: elementClass = 'fire'; break;
          case SMOKE: elementClass = 'smoke'; break;
          case BURNING_WOOD: elementClass = 'burning-wood'; break;
          case BURNING_ORGANIC: elementClass = 'burning-organic'; break;
          case ASH: elementClass = 'ash'; break;
          case GLASS: elementClass = 'glass'; break;
          case BOMB: elementClass = 'bomb'; break;
          case DIRT: elementClass = 'dirt'; break;
          case WET_DIRT: elementClass = 'wet-dirt'; break;
          case WHEAT_SEEDS: elementClass = 'wheat-seeds'; break;
          case WHEAT: elementClass = 'wheat'; break;
          case FLOUR: elementClass = 'flour'; break;
          case DOUGH: elementClass = 'dough'; break;
          case BREAD: elementClass = 'bread'; break;
          case ROOT: elementClass = 'root'; break;
          case BURNING_ROOT: elementClass = 'burning-root'; break;
          case DEAD_ROOT: elementClass = 'dead-root'; break;
          case SPARK: elementClass = 'spark'; break;
          case CHARGED_COPPER: elementClass = 'charged-copper'; break;
          case CHARGED_DOWN_COPPER: elementClass = 'charged-down-copper'; break;
          case OAK_SEEDS: elementClass = 'oak-seeds'; break;
          case OAK_LEAVES: elementClass = 'oak-leaves'; break;
          case OAK_BABY_LEAVES: elementClass = 'oak-baby-leaves'; break;
          case DEAD_OAK: elementClass = 'dead-oak'; break;
          case BIRCH_SEEDS: elementClass = 'birch-seeds'; break;
          case BIRCH_LEAVES: elementClass = 'birch-leaves'; break;
          case BIRCH_BABY_LEAVES: elementClass = 'birch-baby-leaves'; break;
          case BIRCH_WOOD: elementClass = 'birch-wood'; break;
          case DEAD_BIRCH: elementClass = 'dead-birch'; break;
          case WET_SAND: elementClass = 'wet-sand'; break;
          case GRASS: elementClass = 'grass'; break;
          case DEAD_PLANT: elementClass = 'dead-plant'; break;
          case BURNING_LEAVES: elementClass = 'burning-leaves'; break;
          case GAS: elementClass = 'gas'; break;
          case BURNING_GAS: elementClass = 'burning-gas'; break;
          case COOLER: elementClass = 'cooler'; break;
          case HEATER: elementClass = 'heater'; break;
          case HEAT_SEPARATOR: elementClass = 'heat-separator'; break;
          case CHARGED_HEAT_SEPARATOR: elementClass = 'charged-heat-separator'; break;
          case CHARGED_DOWN_HEAT_SEPARATOR: elementClass = 'charged-down-heat-separator'; break;
          case INPUT: elementClass = 'input'; break;
          case CHARGED_INPUT: elementClass = 'charged-input'; break;
          case OUTPUT: elementClass = 'output'; break;
          case CHARGED_OUTPUT: elementClass = 'charged-output'; break;
          case NOT_GATE: elementClass = 'not-gate'; break;
          case AND_GATE: elementClass = 'and-gate'; break;
          case BLOCKER: elementClass = 'blocker'; break;
          case CHARGED_BLOCKER: elementClass = 'charged-blocker'; break;
          case CLONER: elementClass = 'cloner'; break;
          case COAL: elementClass = 'coal'; break;
          case COAL_LUMP: elementClass = 'coal-lump'; break;
          case BURNING_COAL: elementClass = 'burning-coal'; break;
          case BURNING_COAL_LUMP: elementClass = 'burning-coal-lump'; break;
          case THERMITE: elementClass = 'thermite'; break;
          case BURNING_THERMITE: elementClass = 'burning-thermite'; break;
          case ACID: elementClass = 'acid'; break;
          case ACID_STEAM: elementClass = 'acid-steam'; break;
          case ACID_CLOUD: elementClass = 'acid-cloud'; break;
          case SLIME: elementClass = 'slime'; break;
          case CARBON_DIOXIDE: elementClass = 'carbon-dioxide'; break;
          case OXYGEN: elementClass = 'oxygen'; break;
          case BIRD: elementClass = 'bird'; break;
          case MEAT: elementClass = 'meat'; break;
          case COOKED_MEAT: elementClass = 'cooked-meat'; break;
          case COBBLESTONE: elementClass = 'cobblestone'; break;
          case OIL: elementClass = 'oil'; break;
          case BIG_BOMB: elementClass = 'big-bomb'; break;
          case WATER_BOMB: elementClass = 'water-bomb'; break;
          case FIRE_BOMB: elementClass = 'fire-bomb'; break;
          case CRYO_BOMB: elementClass = 'cryo-bomb'; break;
          case NUKE_BOMB: elementClass = 'nuke-bomb'; break;
          case HELIUM: elementClass = 'helium'; break;
          case BOUNCY_BALL: elementClass = 'bouncy-ball'; break;
          case GLUE: elementClass = 'glue'; break;
          case SUGAR: elementClass = 'sugar'; break;
          case SUGAR_WATER: elementClass = 'sugar-water'; break;
          case PLANT: elementClass = 'plant'; break;
          case DIAMOND: elementClass = 'diamond'; break;
          case DIAMOND_SHARDS: elementClass = 'diamond-shards'; break;
          case MOLTEN_DIAMOND: elementClass = 'molten-diamond'; break;
          case CONFETTI: elementClass = 'confetti'; break;
          case DABICCO: elementClass = 'dabicco'; break;
          case OXIDIZED_COPPER: elementClass = 'oxidized-copper'; break;
          case MOLTEN_COPPER: elementClass = 'molten-copper'; break;
          case MOLTEN_SALT: elementClass = 'molten-salt'; break;
          case MOLTEN_STEEL: elementClass = 'molten-steel'; break;
          case MOLTEN_SUGAR: elementClass = 'molten-sugar'; break;
          case MOLTEN_GLASS: elementClass = 'molten-glass'; break;
          case MOLTEN_ELECTRICAL: elementClass = 'molten-electrical'; break;
          case CELL: elementClass = 'cell-element'; break;
          case DEAD_CELL: elementClass = 'dead-cell'; break;
          case BLOOD: elementClass = 'blood'; break;
          case GLASS_SHARD: elementClass = 'glass-shard'; break;
          case INSULATOR: elementClass = 'insulator'; break;
          case PHOTON: elementClass = 'photon'; break;
          case LIGHTNING: elementClass = 'lightning'; break;
          case LIGHTNING_TRAIL: elementClass = 'lightning-trail'; break;
          case DENSE_CLOUD: elementClass = 'dense-cloud'; break;
          default:
            // Handle custom elements
            if (e >= CUSTOM_ELEMENT_START && customElements[e]) {
              // Use custom element color directly
              finalColor = customElements[e].color;
              opacity = 1.0;
            }
            break;
        }
        
        // Update the virtual cell for compatibility
        if (elementClass) {
          cell.classList._className = 'cell ' + elementClass;
          
          // Get the color for this class
          finalColor = getColorForElementClass(elementClass);
          
          // Check if color has opacity information
          if (finalColor && finalColor.startsWith('rgba')) {
            // Extract opacity from rgba
            const rgbaMatch = finalColor.match(/rgba\(\d+,\s*\d+,\s*\d+,\s*([\d.]+)\)/);
            if (rgbaMatch && rgbaMatch[1]) {
              opacity = parseFloat(rgbaMatch[1]);
              // Create RGB version for drawing with separate opacity
              finalColor = finalColor.replace(/rgba/, 'rgb').replace(/,\s*[\d.]+\)/, ')');
            }
          }
        }
      }
      
      // Draw the cell on the canvas
      if (finalColor) {
        const ctx = window.ctx;
        ctx.globalAlpha = opacity;
        ctx.fillStyle = finalColor;
        ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
      }
    }
    // Track cells that need rendering to avoid unnecessary DOM updates
    // This will be properly initialized in initGrid function
    // dirtyGrid is now declared at the top of the script
    
    // Mark a cell as needing re-render
    function markDirty(x, y) {
      if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && dirtyGrid && dirtyGrid[y]) {
        dirtyGrid[y][x] = true;
      }
    }
    
    // Helper function to safely modify a cell and ensure it's marked for re-rendering
    function setCellType(x, y, elemType, temperature = null) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      
      // Store the previous element type to detect transformations
      const previousType = grid[y][x];
      
      // Set the cell type and temperature
      grid[y][x] = elemType;
      temp[y][x] = temperature;
      
      // CRITICAL: When element type changes (transformation), force immediate rendering
      if (previousType !== elemType) {
        // Force immediate rendering of this cell
        renderCell(x, y);
      }
      
      // Mark the cell as dirty to ensure it's re-rendered in the next frame too
      markDirty(x, y);
    }
    
    // Mark neighbors as dirty too (for effects that might affect nearby cells)
    function markNeighborsDirty(x, y, radius = 1) {
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          markDirty(x + dx, y + dy);
        }
      }
    }
    
    // Mark all cells as dirty to ensure complete rendering
    function markAllCellsAsDirty() {
      // Mark all cells as dirty
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          // Always mark liquids as dirty to ensure their colors are constantly refreshed
          if (grid[y][x] === WATER || grid[y][x] === LAVA || grid[y][x] === OIL || 
              grid[y][x] === ACID || grid[y][x] === MOLTEN_SLAG || grid[y][x] === BLOOD || grid[y][x] === SALT_WATER || grid[y][x] === SUGAR_WATER) {
            markDirty(x, y);
            
            // Randomly update color variations for liquids to create a flowing effect
            if (Math.random() < 0.1) { // 10% chance each frame for subtle variation
              if (!colorVariations[y][x]) {
                colorVariations[y][x] = { r: 1, g: 1, b: 1 };
              }
              
              // Apply subtle random variations
              const variation = 0.02; // Reduced from 0.05 for more subtle effect
              colorVariations[y][x].r = 1 + (Math.random() * variation * 2 - variation);
              colorVariations[y][x].g = 1 + (Math.random() * variation * 2 - variation);
              colorVariations[y][x].b = 1 + (Math.random() * variation * 2 - variation);
            }
          }
          // Always mark gases and vapors as dirty for proper transparency rendering
          else if (grid[y][x] === GAS || grid[y][x] === WATER_VAPOR || grid[y][x] === BURNING_GAS || 
                   grid[y][x] === CARBON_DIOXIDE || grid[y][x] === OXYGEN || grid[y][x] === HELIUM || 
                   grid[y][x] === ACID_STEAM || grid[y][x] === ACID_CLOUD || grid[y][x] === CLOUD) {
            markDirty(x, y);
          }
          // Always mark plants and growing elements as dirty
          else if (grid[y][x] === WHEAT || grid[y][x] === WHEAT_SEEDS || 
                   grid[y][x] === GRASS || grid[y][x] === OAK_LEAVES || 
                   grid[y][x] === OAK_BABY_LEAVES || grid[y][x] === BIRCH_LEAVES || 
                   grid[y][x] === BIRCH_BABY_LEAVES || grid[y][x] === ROOT || 
                   grid[y][x] === WOOD || grid[y][x] === BIRCH_WOOD) {
            markDirty(x, y);
          }
          // Always mark fire, burning elements, and other animated elements as dirty
          else if (grid[y][x] === FIRE || grid[y][x] === BURNING_WOOD || 
                   grid[y][x] === BURNING_ORGANIC || grid[y][x] === BURNING_LEAVES || 
                   grid[y][x] === BURNING_COAL || grid[y][x] === BURNING_COAL_LUMP || 
                   grid[y][x] === BURNING_THERMITE || grid[y][x] === BURNING_ROOT || 
                   grid[y][x] === BURNING_GAS || grid[y][x] === SMOKE || 
                   grid[y][x] === SPARK || grid[y][x] === CELL) {
            markDirty(x, y);
          }
          // Mark cells that have moved or changed this frame
          else if (moved[y][x]) {
            markDirty(x, y);
          }
        }
      }
    }
    
    function renderGrid() {
      // Clear the canvas first for a clean drawing surface
      const canvas = window.sandboxCanvas;
      const ctx = window.ctx;
      
      if (!canvas || !ctx) return; // Safety check
      
      // Clear the entire canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Fill with black background for empty cells
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Get cell size for drawing
      const cellSize = window.cellSize;
      
      // Use ceiling function to ensure cells completely fill their space
      // This prevents any gaps between cells
      const pixelSize = Math.ceil(cellSize);
      
      // DSPLE is now handled through its own animation loop
      // Don't call renderLighting() here as it's already running in its own loop
      
      // Separate transparent and opaque elements for better rendering
      // Adding a third category specifically for gases that can transform
      const opaqueBatches = {};
      const transparentBatches = {};
      const gasTransformBatches = {}; // Special handling for O2/CO2 to prevent flickering
      
      // First pass - collect cells into batches based on opacity
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const e = grid[y][x];
          
          // Skip empty cells
          if (e === EMPTY) {
            dirtyGrid[y][x] = false;
            continue;
          }
          
          // Determine the color for this cell
          let finalColor;
          let opacity = 1.0;
          let isTransparent = false;
          let isGasTransform = false; // Special flag for O2/CO2 gases that transform
          
          // Get base color
          let baseColor = elementBaseColors[e];
          
          // Check if it's a custom element
          if (!baseColor && e >= CUSTOM_ELEMENT_START && customElements[e]) {
            baseColor = customElements[e].color;
            
            // Apply liquid texture for custom liquids
            if (customElements[e].type === 'liquid') {
              // Add subtle random texture like built-in liquids (much smaller variation)
              const liquidVariation = 0.02; // Same as built-in liquids
              
              // Parse the hex color
              const hex = baseColor.replace('#', '');
              let red = parseInt(hex.substr(0, 2), 16);
              let green = parseInt(hex.substr(2, 2), 16);
              let blue = parseInt(hex.substr(4, 2), 16);
              
              // Apply the same style variation as built-in liquids
              red = Math.floor(red * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
              green = Math.floor(green * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
              blue = Math.floor(blue * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
              
              // Clamp to valid RGB values
              red = Math.max(0, Math.min(255, red));
              green = Math.max(0, Math.min(255, green));
              blue = Math.max(0, Math.min(255, blue));
              
              baseColor = `rgb(${red}, ${green}, ${blue})`;
            }
          }
          
          if (baseColor) {
            // Get temperature
            const temperature = temp[y][x] !== null ? temp[y][x] : 20;
            
            // Special handling for O2/CO2 to eliminate flickering during transformation
            if (e === OXYGEN || e === CARBON_DIOXIDE) {
              // Use fixed colors for gases that can transform to prevent flickering
              finalColor = e === OXYGEN ? '#e0ffff' : '#d3d3d3';
              isGasTransform = true;
            } else if (e === PHOTON) {
              // Use photon's stored color
              finalColor = photonColor[y][x] || '#ffffff';
            } else {
              // Normal temperature adjustments for other elements
              finalColor = getTemperatureAdjustedColor(baseColor, temperature, e, x, y);
            }
            
            // Update the virtual cell for compatibility
            cells[y][x].style.backgroundColor = finalColor;
            
            // Handle special case for smoke opacity
            if (e === SMOKE) {
              const max = smokeMaxLife[y][x];
              const life = smokeLife[y][x];
              opacity = Math.max(0, 1 - (life / max));
              cells[y][x].style.opacity = opacity.toString();
              isTransparent = true;
            }
            // Handle special case for other transparent elements
            else if (transparentElements.has(e)) {
              opacity = 0.7;
              cells[y][x].style.opacity = '0.7';
              isTransparent = true;
            }
          } else {
            // Fallback to class-based styling
            let elementClass = '';
            
            // Determine element class - complete implementation from renderCell
            switch (e) {
              case SAND: elementClass = 'sand'; break;
              case WALL: elementClass = 'wall'; break;
              case WATER: elementClass = 'water'; break;
              case SNOW: elementClass = 'snow'; break;
              case LAVA: elementClass = 'lava'; break;
              case STONE: elementClass = 'stone'; break;
              case WATER_VAPOR: elementClass = 'water-vapor'; isTransparent = true; break;
              case CLOUD: elementClass = 'cloud'; isTransparent = true; break;
              case BASALT: elementClass = 'stone'; break;
              case OBSIDIAN: elementClass = 'stone'; break;
              case MOLTEN_SLAG: elementClass = 'lava'; break;
              case COPPER: elementClass = 'copper'; break;
              case STEEL: elementClass = 'steel'; break;
              case ICE: elementClass = 'ice'; break;
              case WOOD: elementClass = 'wood'; break;
              case FIRE: elementClass = 'fire'; break;
              case SMOKE: elementClass = 'smoke'; isTransparent = true; break;
              case BURNING_WOOD: elementClass = 'burning-wood'; break;
              case BURNING_ORGANIC: elementClass = 'burning-organic'; break;
              case ASH: elementClass = 'ash'; break;
              case GLASS: elementClass = 'glass'; break;
              case BOMB: elementClass = 'bomb'; break;
              case DIRT: elementClass = 'dirt'; break;
              case WET_DIRT: elementClass = 'wet-dirt'; break;
              case WHEAT_SEEDS: elementClass = 'wheat-seeds'; break;
              case WHEAT: elementClass = 'wheat'; break;
              case FLOUR: elementClass = 'flour'; break;
              case DOUGH: elementClass = 'dough'; break;
              case BREAD: elementClass = 'bread'; break;
              case ROOT: elementClass = 'root'; break;
              case BURNING_ROOT: elementClass = 'burning-root'; break;
              case DEAD_ROOT: elementClass = 'dead-root'; break;
              case SPARK: elementClass = 'spark'; break;
              case CHARGED_COPPER: elementClass = 'charged-copper'; break;
              case CHARGED_DOWN_COPPER: elementClass = 'charged-down-copper'; break;
              case OAK_SEEDS: elementClass = 'oak-seeds'; break;
              case OAK_LEAVES: elementClass = 'oak-leaves'; break;
              case OAK_BABY_LEAVES: elementClass = 'oak-baby-leaves'; break;
              case DEAD_OAK: elementClass = 'dead-oak'; break;
              case BIRCH_SEEDS: elementClass = 'birch-seeds'; break;
              case BIRCH_LEAVES: elementClass = 'birch-leaves'; break;
              case BIRCH_BABY_LEAVES: elementClass = 'birch-baby-leaves'; break;
              case BIRCH_WOOD: elementClass = 'birch-wood'; break;
              case DEAD_BIRCH: elementClass = 'dead-birch'; break;
              case WET_SAND: elementClass = 'wet-sand'; break;
              case GRASS: elementClass = 'grass'; break;
              case DEAD_PLANT: elementClass = 'dead-plant'; break;
              case BURNING_LEAVES: elementClass = 'burning-leaves'; break;
              case GAS: elementClass = 'gas'; isTransparent = true; break;
              case BURNING_GAS: elementClass = 'burning-gas'; isTransparent = true; break;
              case COOLER: elementClass = 'cooler'; break;
              case HEATER: elementClass = 'heater'; break;
              case HEAT_SEPARATOR: elementClass = 'heat-separator'; break;
              case CHARGED_HEAT_SEPARATOR: elementClass = 'charged-heat-separator'; break;
              case CHARGED_DOWN_HEAT_SEPARATOR: elementClass = 'charged-down-heat-separator'; break;
              case INPUT: elementClass = 'input'; break;
              case CHARGED_INPUT: elementClass = 'charged-input'; break;
              case OUTPUT: elementClass = 'output'; break;
              case CHARGED_OUTPUT: elementClass = 'charged-output'; break;
              case NOT_GATE: elementClass = 'not-gate'; break;
              case AND_GATE: elementClass = 'and-gate'; break;
              case BLOCKER: elementClass = 'blocker'; break;
              case CHARGED_BLOCKER: elementClass = 'charged-blocker'; break;
              case CLONER: elementClass = 'cloner'; break;
              case COAL: elementClass = 'coal'; break;
              case COAL_LUMP: elementClass = 'coal-lump'; break;
              case BURNING_COAL: elementClass = 'burning-coal'; break;
              case BURNING_COAL_LUMP: elementClass = 'burning-coal-lump'; break;
              case THERMITE: elementClass = 'thermite'; break;
              case BURNING_THERMITE: elementClass = 'burning-thermite'; break;
              case ACID: elementClass = 'acid'; break;
              case ACID_STEAM: elementClass = 'acid-steam'; isTransparent = true; break;
              case ACID_CLOUD: elementClass = 'acid-cloud'; isTransparent = true; break;
              case SLIME: elementClass = 'slime'; break;
              case CARBON_DIOXIDE: elementClass = 'carbon-dioxide'; isTransparent = true; isGasTransform = true; break;
              case OXYGEN: elementClass = 'oxygen'; isTransparent = true; isGasTransform = true; break;
              case BIRD: elementClass = 'bird'; break;
              case MEAT: elementClass = 'meat'; break;
              case COOKED_MEAT: elementClass = 'cooked-meat'; break;
              case COBBLESTONE: elementClass = 'cobblestone'; break;
              case OIL: elementClass = 'oil'; break;
              case BIG_BOMB: elementClass = 'big-bomb'; break;
              case WATER_BOMB: elementClass = 'water-bomb'; break;
              case FIRE_BOMB: elementClass = 'fire-bomb'; break;
              case CRYO_BOMB: elementClass = 'cryo-bomb'; break;
              case NUKE_BOMB: elementClass = 'nuke-bomb'; break;
              case HELIUM: elementClass = 'helium'; isTransparent = true; break;
              case BOUNCY_BALL: elementClass = 'bouncy-ball'; break;
              case CELL: elementClass = 'cell-element'; break;
              case DEAD_CELL: elementClass = 'dead-cell'; break;
              case BLOOD: elementClass = 'blood'; break;
              case GLASS_SHARD: elementClass = 'glass-shard'; break;
              case SAWDUST: elementClass = 'sawdust'; break;
              case SALT: elementClass = 'salt'; break;
              case SALT_WATER: elementClass = 'salt-water'; break;
              case INSULATOR: elementClass = 'insulator'; break;
              case PHOTON: elementClass = 'photon'; break;
              case LIGHTNING: elementClass = 'lightning'; break;
              case LIGHTNING_TRAIL: elementClass = 'lightning-trail'; break;
              case DENSE_CLOUD: elementClass = 'dense-cloud'; isTransparent = true; break;
              default: 
                // Handle custom elements
                if (e >= CUSTOM_ELEMENT_START && customElements[e]) {
                  // Use custom element color directly instead of class
                  finalColor = customElements[e].color;
                  opacity = 1.0;
                } else {
                  elementClass = '';
                }
                break;
            }
            
            // Update the virtual cell for compatibility
            if (elementClass) {
              cells[y][x].classList._className = 'cell ' + elementClass;
              
              // Get the color for this class
              finalColor = getColorForElementClass(elementClass);
              
              // Check if color has opacity information
              if (finalColor && finalColor.startsWith('rgba')) {
                // Extract opacity from rgba
                const rgbaMatch = finalColor.match(/rgba\(\d+,\s*\d+,\s*\d+,\s*([\d.]+)\)/);
                if (rgbaMatch && rgbaMatch[1]) {
                  opacity = parseFloat(rgbaMatch[1]);
                  isTransparent = true;
                  // Create RGB version for drawing with separate opacity
                  finalColor = finalColor.replace(/rgba/, 'rgb').replace(/,\s*[\d.]+\)/, ')');
                }
              }
            }
          }
          
          // If we have a valid color, add this cell to the appropriate batch
          if (finalColor) {
            // Create a batch key combining color and opacity
            const batchKey = `${finalColor}|${opacity.toFixed(2)}`;
            
            // Choose the correct batch collection based on element type
            let targetBatches;
            if (isGasTransform) {
              targetBatches = gasTransformBatches; // Use special batch for O2/CO2
            } else if (isTransparent) {
              targetBatches = transparentBatches;
            } else {
              targetBatches = opaqueBatches;
            }
            
            // Initialize the batch if it doesn't exist
            if (!targetBatches[batchKey]) {
              targetBatches[batchKey] = {
                color: finalColor,
                opacity: opacity,
                cells: []
              };
            }
            
            // Add this cell to the batch
            targetBatches[batchKey].cells.push({
              x: x,
              y: y
            });
          }
          
          // Mark as no longer dirty
          dirtyGrid[y][x] = false;
        }
      }
      
      // Render opaque elements first
      ctx.globalCompositeOperation = 'source-over';
      for (const batchKey in opaqueBatches) {
        const batch = opaqueBatches[batchKey];
        
        // Set styles once for the entire batch
        ctx.globalAlpha = batch.opacity;
        ctx.fillStyle = batch.color;
        
        // Draw all cells in this batch with pixel-perfect alignment
        for (const cell of batch.cells) {
          // Use integer math for crisp rendering without gaps
          const pixelX = Math.floor(cell.x * cellSize);
          const pixelY = Math.floor(cell.y * cellSize);
          ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
        }
      }
      
      // Reset global alpha before drawing transparent elements
      ctx.globalAlpha = 1.0;
      
      // Render transparent elements second with proper blending
      // This prevents the flickering by using consistent layering
      for (const batchKey in transparentBatches) {
        const batch = transparentBatches[batchKey];
        
        // Set styles once for the entire batch
        ctx.globalAlpha = batch.opacity;
        ctx.fillStyle = batch.color;
        
        // Draw all cells in this batch with pixel-perfect alignment
        for (const cell of batch.cells) {
          // Use integer math for crisp rendering without gaps
          const pixelX = Math.floor(cell.x * cellSize);
          const pixelY = Math.floor(cell.y * cellSize);
          ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
        }
      }
      
      // Special handling for gases that can transform (O2/CO2)
      // This prevents flickering during gas transformations
      ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
      for (const batchKey in gasTransformBatches) {
        const batch = gasTransformBatches[batchKey];
        
        // Force a consistent appearance for transforming gases
        ctx.globalAlpha = 0.7; // Fixed opacity for all gas transformations
        ctx.fillStyle = batch.color;
        
        // Draw with anti-flicker settings
        for (const cell of batch.cells) {
          const pixelX = Math.floor(cell.x * cellSize);
          const pixelY = Math.floor(cell.y * cellSize);
          // Apply consistent rendering to prevent flickering during transformation
          ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
        }
      }
      
      // Reset global alpha and composite operation
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = 'source-over';
    }
    function updateHUD(){
      if (hoveredX !== null && hoveredY !== null && 
          hoveredX >= 0 && hoveredX < GRID_SIZE && 
          hoveredY >= 0 && hoveredY < GRID_SIZE){
        let t = temp[hoveredY][hoveredX];
        let displayT = (t === null || t === undefined || isNaN(t)) ? "--" : t.toFixed(1);
        hudTemp.textContent = `Temp: ${displayT} Â°C`;
        hudElem.textContent = `Element: ${getElementName(grid[hoveredY][hoveredX])}`;
      }
    }
    function getElementName(e){
      switch(e){
        case EMPTY: return "Empty";
        case SAND: return "Sand";
        case WALL: return "Wall";
        case WATER: return "Water";
        case SNOW: return "Snow";
        case LAVA: return "Lava";
        case STONE: return "Stone";
        case ERASER: return "Eraser";
        case WATER_VAPOR: return "Water Vapor";
        case CLOUD: return "Cloud";
        case BASALT: return "Basalt";
        case OBSIDIAN: return "Obsidian";
        case MOLTEN_SLAG: return "Molten Slag";
        case COPPER: return "Copper";
        case STEEL: return "Steel";
        case ICE: return "Ice";
        case WOOD: return "Wood";
        case FIRE: return "Fire";
        case SMOKE: return "Smoke";
        case BURNING_WOOD: return "Burning Wood";
        case BURNING_ORGANIC: return "Burning Organic";
        case ASH: return "Ash";
        case GLASS: return "Glass";
        case BOMB: return "Bomb";
        case DIRT: return "Dirt";
        case WET_DIRT: return "Wet Dirt";
        case WHEAT_SEEDS: return "Wheat Seeds";
        case WHEAT: return "Wheat";
        case FLOUR: return "Flour";
        case DOUGH: return "Dough";
        case BREAD: return "Bread";
        case ROOT: return "Plant Root";
        case BURNING_ROOT: return "Burning Root";
        case DEAD_ROOT: return "Dead Root";
        case SPARK: return "Spark";
        case CHARGED_COPPER: return "Charged Copper";
        case CHARGED_DOWN_COPPER: return "Charged-Down Copper";
        case OAK_SEEDS: return "Oak Seeds";
        case OAK_LEAVES: return "Oak Leaves";
        case OAK_BABY_LEAVES: return "Oak Baby Leaves";
        case DEAD_OAK: return "Dead Oak";
        case BIRCH_SEEDS: return "Birch Seeds";
        case BIRCH_LEAVES: return "Birch Leaves";
        case BIRCH_BABY_LEAVES: return "Birch Baby Leaves";
        case BIRCH_WOOD: return "Birch Wood";
        case DEAD_BIRCH: return "Dead Birch";
        case WET_SAND: return "Wet Sand";
        case GRASS: return "Grass";
        case DEAD_PLANT: return "Dead Plant";
        case BURNING_LEAVES: return "Burning Leaves";
        case GAS: return "Gas";
        case BURNING_GAS: return "Burning Gas";
        case COOLER: return "Cooler";
        case HEATER: return "Heater";
        case HEAT_SEPARATOR: return "Heat Separator";
        case CHARGED_HEAT_SEPARATOR: return "Charged Heat Separator";
        case CHARGED_DOWN_HEAT_SEPARATOR: return "Charged-Down Heat Separator";
        case INPUT: return "Input";
        case CHARGED_INPUT: return "Charged Input";
        case OUTPUT: return "Output";
        case CHARGED_OUTPUT: return "Charged Output";
        case NOT_GATE: return "Not Gate";
        case AND_GATE: return "And Gate";
        case BLOCKER: return "Blocker";
        case CHARGED_BLOCKER: return "Charged Blocker";
        case CLONER: return "Cloner";
        case COAL: return "Coal";
        case COAL_LUMP: return "Coal Lump";
        case BURNING_COAL: return "Burning Coal";
        case BURNING_COAL_LUMP: return "Burning Coal Lump";
        case THERMITE: return "Thermite";
        case BURNING_THERMITE: return "Molten Thermite";
        case ACID: return "Acid";
        case SLIME: return "Slime";
        case ACID_STEAM: return "Acid Steam";
        case ACID_CLOUD: return "Acid Cloud";
        case CARBON_DIOXIDE: return "Carbon Dioxide";
        case OXYGEN: return "Oxygen";
        case BIRD: return "Bird";
        case MEAT: return "Meat";
        case COOKED_MEAT: return "Cooked Meat";
        case COBBLESTONE: return "Cobblestone";
        case OIL: return "Oil";
        case BIG_BOMB: return "Big Bomb";
        case WATER_BOMB: return "Water Bomb";
        case FIRE_BOMB: return "Fire Bomb";
        case CRYO_BOMB: return "Cryo Bomb";
        case NUKE_BOMB: return "Nuke Bomb";
        case HELIUM: return "Helium";
        case BOUNCY_BALL: return "Bouncy Ball";
        case CELL: return "Cell";
        case DEAD_CELL: return "Dead Cell";
        case BLOOD: return "Blood";
        case GLASS_SHARD: return "Glass Shard";
        case SAWDUST: return "Sawdust";
        case SALT: return "Salt";
        case SALT_WATER: return "Salt Water";
        case SUGAR: return "Sugar";
        case SUGAR_WATER: return "Sugar Water";
        case MOLTEN_SUGAR: return "Molten Sugar";
        case DIAMOND: return "Diamond";
        case DIAMOND_SHARDS: return "Diamond Shards";
        case MOLTEN_DIAMOND: return "Molten Diamond";
        case CONFETTI: return "Confetti";
        case DABICCO: return "Dabicco";
        case PLANT: return "Plant";
        case GLUE: return "Glue";
        case MOLTEN_COPPER: return "Molten Copper";
        case MOLTEN_GLASS: return "Molten Glass";
        case MOLTEN_STEEL: return "Molten Steel";
        case MOLTEN_SALT: return "Molten Salt";
        case OXIDIZED_COPPER: return "Oxidized Copper";
        case INSULATOR: return "Insulator";
        case PHOTON: return "Photon";
        case LIGHTNING: return "Lightning";
        case LIGHTNING_TRAIL: return "Lightning Trail";
        case DENSE_CLOUD: return "Dense Cloud";
        default: 
          // Check if it's a custom element
          if (e >= CUSTOM_ELEMENT_START && customElements[e]) {
            return customElements[e].name;
          }
          return "Unknown";
      }
    }
    
    function resetMoved(){
      // Use WebAssembly for resetMoved if available
      if (wasmEnabled && wasmExports && typeof wasmExports.resetMovedJS === 'function' && wasmInt32Array) {
        try {
          // Store grid size in WebAssembly memory
          wasmInt32Array[0] = GRID_SIZE;
          
          // In a real implementation, this would be handled by WebAssembly
          // For now, we'll use a hybrid approach that still leverages WebAssembly memory
          
          // Store grid size in WebAssembly memory
          wasmInt32Array[0] = GRID_SIZE;
          
          // Use a more efficient approach with TypedArrays
          // This is much faster than nested loops for large grids
          const totalSize = GRID_SIZE * GRID_SIZE;
          const offset = 16; // Leave some space at the beginning of the array
          
          // Set all values to 0 (false) in one operation
          wasmInt32Array.fill(0, offset, offset + totalSize);
          
          // Copy back to the moved array
          for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
              moved[y][x] = false;
            }
          }
          
          return;
        } catch (error) {
          console.error('WebAssembly resetMoved failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // JavaScript fallback implementation
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          moved[y][x] = false;
        }
      }
    }
    /***************************************
     * GAME LOOP
     ***************************************/
    // lastFrameTime is now declared at the top of the script
    let fps = 0;
    let fpsUpdateCounter = 0;
    const FPS_UPDATE_INTERVAL = 5; // Update FPS display more frequently (changed from 10 to 5)
    let fpsHistory = [60, 60, 60, 60, 60]; // Store last 5 FPS values for smoothing
    let fpsHistoryIndex = 0;
    let stepAccumulator = 0;
    
    // Pre-allocate arrays for neighbor calculations to avoid GC
    const neighborOffsets = [
      [-1, -1], [0, -1], [1, -1],
      [-1, 0],           [1, 0],
      [-1, 1],  [0, 1],  [1, 1]
    ];
    
    // Reusable arrays for shuffling positions - now declared at the top of the script
    // The initialization is done in the initGrid function
    
    // Define a performance budget in milliseconds
    const PERFORMANCE_BUDGET = 14; // Target ~70fps with some overhead
    
    function gameLoop(timestamp) {
      // Track start time for performance budget
      const startTime = performance.now();
      
      // Ensure lastFrameTime is properly initialized
      if (!timestamp) timestamp = performance.now();
      if (lastFrameTime === 0 || !lastFrameTime) lastFrameTime = timestamp;
      
      // Calculate delta time with safety checks
      let deltaTime = timestamp - lastFrameTime;
      
      // Prevent extreme delta times (e.g., after tab was inactive)
      if (deltaTime > 1000) deltaTime = 16.67; // Cap at ~60fps equivalent
      
      // Update FPS counter more frequently but with smoothing
      if (fpsUpdateCounter++ % FPS_UPDATE_INTERVAL === 0) {
        // Avoid division by zero
        let currentFps = deltaTime > 0 ? Math.round(1000 / deltaTime) : 60;
        
        // Add to rolling average
        fpsHistory[fpsHistoryIndex] = currentFps;
        fpsHistoryIndex = (fpsHistoryIndex + 1) % fpsHistory.length;
        
        // Calculate average FPS from history for smoother display
        let totalFps = 0;
        for (let i = 0; i < fpsHistory.length; i++) {
          totalFps += fpsHistory[i];
        }
        fps = Math.round(totalFps / fpsHistory.length);
        
        // Update FPS display with high-performance approach
        if (hudFPS) {
          // Use textContent for better performance than innerHTML
          hudFPS.textContent = "FPS: " + fps;
          
          // Add color coding for FPS values
          if (fps >= 55) {
            hudFPS.style.color = "#00ff00"; // Green for good FPS
          } else if (fps >= 30) {
            hudFPS.style.color = "#ffff00"; // Yellow for acceptable FPS
          } else {
            hudFPS.style.color = "#ff0000"; // Red for poor FPS
          }
        }
      }
      
      lastFrameTime = timestamp;
      
      // Handle user input
      spamPlace();
      
      // Check if simulation is paused
      if (speed > 0) {
        // Convert real time to simulation time
        // This is the key part - we accumulate time based on real elapsed milliseconds
        const simulationTimeToAdd = (deltaTime / 1000) * (speed / 0.80);
        stepAccumulator += simulationTimeToAdd;
        
        // Run a fixed number of simulation steps based on accumulated time
        const fixedTimeStep = 0.016; // 16ms, equivalent to 60fps
        
        // Limit max steps per frame to prevent spiral of death
        const maxStepsPerFrame = 4;
        let stepsThisFrame = 0;
        
        // Track if we've used up our performance budget
        let budgetExceeded = false;
        
        while(stepAccumulator >= fixedTimeStep && stepsThisFrame < maxStepsPerFrame && !budgetExceeded) {
          resetMoved();
          performSimulationStep();
          
          // Check if we've exceeded our performance budget
          if (performance.now() - startTime > PERFORMANCE_BUDGET) {
            budgetExceeded = true;
          } else {
            // Only do these expensive operations if we have budget left
            updateTemperature();
            unifyCopperClusters();
            processTransformations();
            stepAccumulator -= fixedTimeStep;
            stepsThisFrame++;
          }
        }
        
        // Always mark cells as dirty for rendering, even if we ran out of budget
        markAllCellsAsDirty();
        
        // If we're falling behind, drop some accumulated time
        if (stepAccumulator > fixedTimeStep * 10) {
          stepAccumulator = fixedTimeStep * 10;
        }
      }
      
      updateHUD();
      renderGrid();
      updateHoverOverlay();
      requestAnimationFrame(gameLoop);
    }
    /***************************************
     * SIMULATION STEP
     ***************************************/
    // Create cell type category arrays for batch processing
    const POWDER_ELEMENTS = new Set([SAND, ASH, THERMITE, BOMB, BIG_BOMB, WATER_BOMB, FIRE_BOMB, CRYO_BOMB, NUKE_BOMB, DIRT, WET_DIRT, WHEAT_SEEDS, OAK_SEEDS, BIRCH_SEEDS, FLOUR, DEAD_PLANT, GRASS, COAL_LUMP, COBBLESTONE, GLASS_SHARD, SAWDUST, SALT, DEAD_CELL, SUGAR, DIAMOND_SHARDS, CONFETTI, SNOW]);
    const LIQUID_ELEMENTS = new Set([WATER, LAVA, MOLTEN_SLAG, OIL, BLOOD, SALT_WATER, BURNING_THERMITE, ACID, GLUE, SUGAR_WATER, MOLTEN_DIAMOND]);
    const GAS_ELEMENTS = new Set([GAS, WATER_VAPOR, CLOUD, SMOKE, BURNING_GAS, CARBON_DIOXIDE, OXYGEN, HELIUM, ACID_STEAM, ACID_CLOUD]);
    
    // Removed spatial partitioning code that was causing conflicts with the simulation
    // We're keeping the original physics approach which has better compatibility with the game mechanics
    
    function performSimulationStep() {
      // Use WebAssembly for simulation step preparation if available
      if (wasmEnabled && wasmExports && typeof wasmExports.prepareSimulationJS === 'function' && wasmInt32Array) {
        try {
          // Store grid size in WebAssembly memory
          wasmInt32Array[0] = GRID_SIZE;
          
          // In a real implementation, this would handle the shuffling and preparation
          // For now, we'll still use the JavaScript implementation
        } catch (error) {
          console.error('WebAssembly simulation preparation failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // Revert to original approach for processing cells since batch processing has issues
      // Use reusable arrays directly without copying to reduce memory allocations
      // Shuffle the original arrays in place for better performance
      shuffle(reusablePositions);
      
      for (let i = reusablePositions.length - 1; i >= 0; i--){
        const y = reusablePositions[i];
        
        // Shuffle X positions once per row
        shuffle(reusableXPositions);
        
        for (let j = 0; j < reusableXPositions.length; j++){
          const x = reusableXPositions[j];
          // Fast path for common cases
          if(moved[y][x] || grid[y][x] === WALL) continue;
          const e = grid[y][x];

          switch(e) {
            case SPARK:
              sparkLife[y][x] += simulationTimeStep;
              if(sparkLife[y][x] >= sparkLifetime){
                eraseCell(x, y);
                continue;
              }
              
              // Use direct neighbor checking instead of spatial grid
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of neighbors){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BOMB){
                    explodeBomb(nx, ny);
                  }
                  if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){
                    grid[ny][nx] = CHARGED_COPPER;
                    temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                    chargedStateTime[ny][nx] = 0;
                  }
                }
              }
              break;

            case SAND:
            case ASH:
            case THERMITE:
            case BOMB:
            case BIG_BOMB:
            case WATER_BOMB:
            case FIRE_BOMB:
            case CRYO_BOMB:
            case NUKE_BOMB:
            case DIRT:
            case WET_DIRT:
            case WHEAT_SEEDS:
            case OAK_SEEDS:
            case BIRCH_SEEDS:
            case FLOUR:
            case DEAD_PLANT:
            case GRASS:
            case COAL_LUMP:
            case COBBLESTONE:
            case GLASS_SHARD: // Add Glass Shard as a powder element
            case SAWDUST: // Add Sawdust as a powder element
            case SALT: // Add Salt as a powder element
            case DEAD_CELL:
            case SUGAR: // Add Sugar as a powder element
            case DIAMOND_SHARDS: // Add Diamond Shards as a powder element
            case CONFETTI: // Bright consistent colored confetti
            case DABICCO: // Old confetti with random changing colors
            case SNOW: // Snow falls slowly like powder
              if (e === SNOW) {
                // Snow falls more slowly than regular powder
                if (Math.random() < 0.3) { // 30% chance to move each frame (slower than normal powder)
                  moveLikePowder(x, y, temp[y][x], e);
                }
              } else {
                moveLikePowder(x, y, temp[y][x], e);
              }
              break;

            case WET_SAND:
            case DOUGH:
            case BREAD:
              moveNonPowderGravity(x, y, temp[y][x], e);
              break;

            case WATER:
              moveLikeLiquid(x, y, temp[y][x], WATER);
              break;
              
            case SALT_WATER:
              moveLikeLiquid(x, y, temp[y][x], SALT_WATER);
              break;

            case OIL:
              moveOil(x, y, temp[y][x]);
              break;
              
            case BLOOD:
              moveBlood(x, y, temp[y][x]);
              break;

            case BOUNCY_BALL:
              moveBouncyBall(x, y, temp[y][x]);
              break;

            case LAVA:
            case MOLTEN_SLAG:
              if(Math.random() < 0.5) continue;
              moveLikeLiquid(x, y, temp[y][x], LAVA);
              break;

            case BURNING_THERMITE:
              moveLikeLiquid(x, y, temp[y][x], THERMITE);
              break;

            case WATER_VAPOR:
            case ACID_STEAM:
              vaporLife[y][x] += simulationTimeStep;
              moveVaporUp(x, y, temp[y][x]);
              break;

            case CLOUD:
            case ACID_CLOUD:
              cloudLife[y][x] += simulationTimeStep;
              moveCloud(x, y, temp[y][x]);
              break;

            case FIRE:
              fireLife[y][x] += simulationTimeStep;
              moveFire(x, y, temp[y][x]);
              break;

            case SMOKE:
              smokeLife[y][x] += simulationTimeStep;
              moveSmoke(x, y, temp[y][x]);
              break;

            case GAS:
            case BURNING_GAS:
            case CARBON_DIOXIDE:
            case OXYGEN:
              moveGasElement(x, y, temp[y][x], e);
              break;

            case ACID:
              moveAcid(x, y, temp[y][x]);
              break;

            case SLIME:
              moveSlime(x, y, temp[y][x]);
              break;
              
            case GLUE:
              moveGlue(x, y, temp[y][x]);
              break;
              
            case SUGAR_WATER:
              moveSugarWater(x, y, temp[y][x]);
              break;
              
            case MOLTEN_DIAMOND:
              moveMoltenDiamond(x, y, temp[y][x]);
              break;
              
            case MOLTEN_SUGAR:
              moveMoltenSugar(x, y, temp[y][x]);
              break;
              
            case MOLTEN_COPPER:
            case MOLTEN_STEEL:
            case MOLTEN_SALT:
            case MOLTEN_GLASS:
              // Move like a liquid but with 40% chance to stay in place
              if (Math.random() < 0.4) continue;
              moveLikeLiquid(x, y, temp[y][x], e);
              break;
              
            case PLANT:
              // Plants don't move, they're static but can grow through the transform function
              break;
              
            case DIAMOND:
              // Diamond is static, doesn't move
              break;
              
            case OXIDIZED_COPPER:
              // Oxidized Copper is static, doesn't move
              break;

            case BIRD:
              moveBird(x, y, temp[y][x]);
              break;

            case HELIUM:
              moveHelium(x, y, temp[y][x]);
              break;

            case MEAT:
            case COOKED_MEAT:
              if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                moveCell(x, y, x, y+1, temp[y][x], e);
              }
              break;
              
            case INSULATOR:
              // Insulator doesn't move - it's static
              break;
              
            case PHOTON:
              // Photon movement is handled in handlePhotons()
              break;
              
            case LIGHTNING:
              // Lightning movement is handled in handleLightning()
              break;
              
            case DENSE_CLOUD:
              // Dense clouds move like regular clouds but slower
              cloudLife[y][x] += simulationTimeStep;
              if (Math.random() < 0.3) { // 30% chance to move (slower than regular clouds)
                moveCloud(x, y, temp[y][x]);
              }
              break;
              
            default:
              // Handle custom elements
              if (e >= CUSTOM_ELEMENT_START && customElements[e]) {
                const customElement = customElements[e];
                
                // Apply physics based on custom element type and properties
                let movementChance = 1.0;
                
                // Adjust movement based on viscosity (higher viscosity = much slower movement)
                if (customElement.type === 'liquid') {
                  // More dramatic viscosity effects: 0.0 viscosity = water-like, 2.0 viscosity = barely moves
                  movementChance = Math.max(0.02, Math.pow(0.5, customElement.viscosity * 2));
                  // At viscosity 0.0: chance = 1.0 (always moves)
                  // At viscosity 1.0: chance = 0.25 (moves 25% of time)  
                  // At viscosity 2.0: chance = 0.0625 (moves 6% of time - very slow)
                }
                
                // Powder movement affected by density (heavier powders fall through more things)
                if (customElement.type === 'powder') {
                  // High density powders can displace lighter elements
                  movementChance = 0.8 + (customElement.density * 0.1);
                }
                
                // Gas movement affected by density (lighter gases float more aggressively)
                if (customElement.type === 'gas') {
                  // Low density gases float more, high density gases sink
                  movementChance = Math.max(0.1, 2.0 - customElement.density);
                }
                
                const shouldMove = Math.random() < movementChance;
                
                if (shouldMove) {
                  switch (customElement.type) {
                    case 'solid':
                      // Solids don't move (like wall, diamond, etc.)
                      break;
                      
                    case 'liquid':
                      // Custom liquid physics with density and viscosity
                      moveCustomLiquid(x, y, e, customElement);
                      break;
                      
                    case 'powder':
                      // Custom powder physics with density
                      moveCustomPowder(x, y, e, customElement);
                      break;
                      
                    case 'gas':
                      // Use standard gas movement but with density-based special behaviors
                      if (customElement.density < 0.5) {
                        // Very light gases try to float upward like helium
                        if (y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]) {
                          moveCell(x, y, x, y-1, temp[y][x], e);
                        } else {
                          moveGasElement(x, y, temp[y][x], e);
                        }
                      } else if (customElement.density > 1.5) {
                        // Heavy gases sink downward
                        if (y + 1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                          moveCell(x, y, x, y+1, temp[y][x], e);
                        } else {
                          moveGasElement(x, y, temp[y][x], e);
                        }
                      } else {
                        // Normal density gases use standard movement
                        moveGasElement(x, y, temp[y][x], e);
                      }
                      break;
                      
                    default:
                      // Unknown type - treat as solid (don't move)
                      break;
                  }
                }
              }
              break;
          }
        }
      }
      
      // Process custom element reactions
      processCustomElementReactions();
      
      // Removed batch processing code since we're using the original approach
      /*
          case SAND:
          case ASH:
          case THERMITE:
          case BOMB:
          case BIG_BOMB:
          case WATER_BOMB:
          case FIRE_BOMB:
          case CRYO_BOMB:
          case NUKE_BOMB:
          case DIRT:
          case WET_DIRT:
          case WHEAT_SEEDS:
          case OAK_SEEDS:
          case BIRCH_SEEDS:
          case FLOUR:
          case DEAD_PLANT:
          case GRASS:
          case COAL_LUMP:
          case COBBLESTONE:
          case GLASS_SHARD:
          case SAWDUST:
          case SALT:
          case DEAD_CELL:
            moveLikePowder(x, y, t, e);
            break;
        }
      }
      
      // Process wet materials that have gravity but aren't true powders
      for (const cell of staticCells) {
        const {x, y, e, t} = cell;
        if (moved[y][x]) continue;
        
        switch(e) {
          case WET_SAND:
          case DOUGH:
          case BREAD:
            moveNonPowderGravity(x, y, t, e);
            break;
          case BOUNCY_BALL:
            moveBouncyBall(x, y, t);
            break;
        }
      }
      
      // Process liquid elements
      for (const cell of liquidCells) {
        const {x, y, e, t} = cell;
        if (moved[y][x]) continue;
        
        switch(e) {
          case WATER:
            moveLikeLiquid(x, y, t, WATER);
            break;
          case SALT_WATER:
            moveLikeLiquid(x, y, t, SALT_WATER);
            break;
          case OIL:
            moveOil(x, y, t);
            break;
          case BLOOD:
            moveBlood(x, y, t);
            break;
          case LAVA:
          case MOLTEN_SLAG:
            if(Math.random() < 0.5) continue;
            moveLikeLiquid(x, y, t, LAVA);
            break;
          case BURNING_THERMITE:
            moveLikeLiquid(x, y, t, THERMITE);
            break;
          case ACID:
            moveLikeLiquid(x, y, t, ACID);
            break;
        }
      }
      
      // Process gas elements
      for (const cell of gasCells) {
        const {x, y, e, t} = cell;
        if (moved[y][x]) continue;
        
        switch(e) {
          case GAS:
            moveGasElement(x, y, t, GAS);
            break;
          case BURNING_GAS:
            burningGasTime[y][x] += simulationTimeStep;
            if(burningGasTime[y][x] > burningGasDuration){
              setCellType(x, y, CARBON_DIOXIDE, t);
              continue;
            }
            
            let spreadChance = 0.05;
            if(Math.random() < spreadChance){
              // Use spatial grid for more efficient neighbor lookups
              const spatialX = Math.floor(x / SPATIAL_CELL_SIZE);
              const spatialY = Math.floor(y / SPATIAL_CELL_SIZE);
              
              let spreadComplete = false;
              
              // Check cells in current spatial cell and adjacent ones
              for (let sy = Math.max(0, spatialY-1); sy <= Math.min(SPATIAL_GRID_SIZE-1, spatialY+1) && !spreadComplete; sy++) {
                for (let sx = Math.max(0, spatialX-1); sx <= Math.min(SPATIAL_GRID_SIZE-1, spatialX+1) && !spreadComplete; sx++) {
                  const spatialIndex = sy * SPATIAL_GRID_SIZE + sx;
                  const cellsInSpatialCell = spatialGrid[spatialIndex];
                  
                  if (!cellsInSpatialCell) continue;
                  
                  for (const {x: nx, y: ny} of cellsInSpatialCell) {
                    // Check if this is a neighbor (within 1 cell distance)
                    const dx = Math.abs(nx - x);
                    const dy = Math.abs(ny - y);
                    
                    if (dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0)) {
                      if(grid[ny][nx] === GAS){
                        setCellType(nx, ny, BURNING_GAS, temp[ny][nx] + 100);
                        burningGasTime[ny][nx] = 0;
                        spreadComplete = true;
                        break;
                      }
                    }
                  }
                }
              }
            }
            
            moveGasElement(x, y, t, BURNING_GAS);
            break;
          case HELIUM:
            moveHelium(x, y, t);
            break;
          case OXYGEN:
          case CARBON_DIOXIDE:
          case WATER_VAPOR:
          case ACID_STEAM:
          case ACID_CLOUD:
          case CLOUD:
            moveGasElement(x, y, t, e);
            break;
          case SMOKE:
            smokeLife[y][x] += simulationTimeStep;
            const max = smokeMaxLife[y][x];
            if(smokeLife[y][x] >= max){
              eraseCell(x, y);
              continue;
            }
            moveGasElement(x, y, t, SMOKE);
            break;
        }
      }
      */
    }
    /***************************************
     * PERFORMANCE OPTIMIZATIONS WITH WASM-GC
     ***************************************/
    // WebAssembly support for performance-critical operations
    let wasmModule = null;
    let wasmInstance = null;
    let wasmMemory = null;
    let wasmEnabled = false;
    let wasmExports = null;
    
    // Initialize WebAssembly module for performance-critical operations
    (function initWasmOptimizations() {
      // Check if WebAssembly is supported
      if (typeof WebAssembly !== 'object') {
        console.log('WebAssembly not supported, using JavaScript implementations');
        wasmEnabled = false;
        return;
      }
      
      try {
        // Create a new WebAssembly Memory instance
        wasmMemory = new WebAssembly.Memory({ initial: 1, maximum: 10 });
        
        // Create a simple, valid WebAssembly module for basic functionality
        // This is a minimal module that just provides memory without complex functions
        const wasmBinary = new Uint8Array([
          0x00, 0x61, 0x73, 0x6d,   // magic "\0asm"
          0x01, 0x00, 0x00, 0x00,   // version 1
          
          // Type section
          0x01, 0x04, 0x01,         // section type=1, length=4, count=1
          0x60, 0x00, 0x00,         // function type: () -> ()
          
          // Import section (memory)
          0x02, 0x0e, 0x01,         // section type=2, length=14, count=1
          0x03, 0x65, 0x6e, 0x76,   // "env"
          0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79,  // "memory"
          0x02, 0x00, 0x0a,         // memory, min=0, max=10
          
          // Function section
          0x03, 0x02, 0x01, 0x00,   // section type=3, length=2, count=1, func[0]=type[0]
          
          // Export section
          0x07, 0x08, 0x01,         // section type=7, length=8, count=1
          0x04, 0x74, 0x65, 0x73, 0x74,  // "test"
          0x00, 0x00,               // function export, func[0]
          
          // Code section
          0x0a, 0x04, 0x01,         // section type=10, length=4, count=1
          0x02, 0x00, 0x0b          // func[0]: no locals, empty body, end
        ]);
        
        // Create imports object with memory
        const imports = {
          env: {
            memory: wasmMemory
          }
        };
        
        // Compile and instantiate the WebAssembly module
        WebAssembly.instantiate(wasmBinary, imports).then(result => {
          // Store the instance
          wasmInstance = result.instance;
          wasmExports = result.instance.exports;
          wasmEnabled = true;
          console.log('WebAssembly basic module initialized successfully');
          
          // Initialize the memory views for data access
          initWasmMemoryViews();
        }).catch(error => {
          console.log('WebAssembly instantiation failed, using JavaScript fallback:', error.message);
          wasmEnabled = false;
        });
      } catch (error) {
        console.log('WebAssembly setup failed, using JavaScript fallback:', error.message);
        wasmEnabled = false;
      }
    })();
    
    // Memory views for efficient data access
    let wasmInt32Array = null;
    let wasmFloat32Array = null;
    let wasmUint8Array = null;
    
    // Initialize memory views for efficient data access
    function initWasmMemoryViews() {
      if (!wasmMemory) return;
      
      try {
        // Create typed array views of the WebAssembly memory
        wasmInt32Array = new Int32Array(wasmMemory.buffer);
        wasmFloat32Array = new Float32Array(wasmMemory.buffer);
        wasmUint8Array = new Uint8Array(wasmMemory.buffer);
        console.log('Enhanced WebAssembly memory views initialized');
      } catch (error) {
        console.error('Failed to initialize WebAssembly memory views:', error);
      }
    }
    
    // Optimized Fisher-Yates shuffle implementation with wasm-gc support
    function shuffle(array) {
      // Only use WebAssembly if it's properly initialized and for arrays of significant size
      if (wasmEnabled && wasmExports && typeof wasmExports.shuffleJS === 'function' && wasmInt32Array && array.length > 20) {
        try {
          // Copy array to WebAssembly memory
          for (let i = 0; i < array.length; i++) {
            wasmInt32Array[i] = array[i];
          }
          
          // Call WebAssembly shuffle function
          // This would be the ideal implementation with wasm-gc, but we're using a simpler approach for compatibility
          // wasmExports.shuffleJS(wasmInt32Array.byteOffset, array.length);
          
          // For now, we'll do the shuffle in JavaScript but using the WebAssembly memory
          for (let i = array.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0;
            const temp = wasmInt32Array[i];
            wasmInt32Array[i] = wasmInt32Array[j];
            wasmInt32Array[j] = temp;
          }
          
          // Copy results back to original array
          for (let i = 0; i < array.length; i++) {
            array[i] = wasmInt32Array[i];
          }
          
          return array;
        } catch (error) {
          console.error('WebAssembly shuffle failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // Optimized JavaScript implementation as fallback
      const len = array.length;
      let i, j, temp;
      
      // Fisher-Yates shuffle algorithm with optimizations
      for (i = len - 1; i > 0; i--) {
        // Use a faster random method and avoid creating unnecessary variables
        j = (Math.random() * (i + 1)) | 0; // Bitwise OR for faster integer conversion
        
        // Manual swap without destructuring to avoid temporary array creation
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      
      return array;
    }
    
    // Optimized temperature calculation with wasm-gc support
    function calculateTemperature(x, y, currentTemp) {
      // Only use WebAssembly if it's properly initialized
      if (wasmEnabled && wasmExports && typeof wasmExports.temperatureJS === 'function' && wasmFloat32Array) {
        try {
          // Store coordinates and current temperature in WebAssembly memory
          wasmInt32Array[0] = x;
          wasmInt32Array[1] = y;
          wasmFloat32Array[2] = currentTemp || 0;
          
          // In a real implementation with wasm-gc, we would call:
          // return wasmExports.temperatureJS(x, y, currentTemp);
          
          // For now, we'll use a hybrid approach that still leverages WebAssembly memory
          // Calculate average temperature from neighbors using WebAssembly memory
          let totalTemp = currentTemp;
          let count = 1;
          
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              
              const nx = x + dx;
              const ny = y + dy;
              
              // Store neighbor coordinates in WebAssembly memory for faster access
              wasmInt32Array[3] = nx;
              wasmInt32Array[4] = ny;
              
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && temp[ny][nx] !== null) {
                wasmFloat32Array[5] = temp[ny][nx];
                totalTemp += wasmFloat32Array[5];
                count++;
              }
            }
          }
          
          // Store calculation results in WebAssembly memory
          wasmFloat32Array[6] = totalTemp;
          wasmInt32Array[7] = count;
          wasmFloat32Array[8] = totalTemp / count;
          
          // Calculate new temperature with 10% movement toward average
          const newTemp = currentTemp + (wasmFloat32Array[8] - currentTemp) * 0.1;
          wasmFloat32Array[9] = newTemp;
          
          return newTemp;
        } catch (error) {
          console.error('WebAssembly temperature calculation failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // JavaScript implementation as fallback
      // Get average temperature from neighbors
      let totalTemp = currentTemp;
      let count = 1;
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && temp[ny][nx] !== null) {
            totalTemp += temp[ny][nx];
            count++;
          }
        }
      }
      
      const avgTemp = totalTemp / count;
      return currentTemp + (avgTemp - currentTemp) * 0.1;
    }
    /***************************************
     * MOVEMENT
     ***************************************/
    // Helper function to check if coordinates are within grid boundaries
    function isInGrid(x, y) {
      return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
    }
    
    function moveCell(x, y, nx, ny, oldT, newElem){
      if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) return;
      
      // Use WebAssembly for moveCell if available
      if (wasmEnabled && wasmExports && typeof wasmExports.moveCellJS === 'function' && 
          wasmInt32Array && wasmFloat32Array) {
        try {
          // Store grid positions and element data in WebAssembly memory
          wasmInt32Array[0] = x;
          wasmInt32Array[1] = y;
          wasmInt32Array[2] = nx;
          wasmInt32Array[3] = ny;
          wasmInt32Array[4] = newElem;
          wasmFloat32Array[5] = oldT || 0;
          
          // Call WebAssembly moveCell function
          // In a real implementation, this would handle the cell movement logic
          // For now, we'll still use the JavaScript implementation
          
          // Continue with normal JavaScript implementation
          grid[ny][nx] = newElem;
          temp[ny][nx] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[ny][nx] = true;
          
          // Mark cells as dirty for rendering
          markDirty(x, y);
          markDirty(nx, ny);
          
          // Transfer color variation data when moving cells
          if(colorVariations[y][x]) {
            colorVariations[ny][nx] = colorVariations[y][x];
            colorVariations[y][x] = null;
          }
          
          return;
        } catch (error) {
          console.error('WebAssembly moveCell failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // JavaScript fallback implementation
      grid[ny][nx] = newElem;
      temp[ny][nx] = oldT;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[ny][nx] = true;
      
      // Mark cells as dirty to ensure they're re-rendered
      markDirty(x, y);
      markDirty(nx, ny);
      
      // Transfer color variation data when moving cells
      if(colorVariations[y][x]) {
        colorVariations[ny][nx] = colorVariations[y][x];
        colorVariations[y][x] = null;
      }
      if(newElem === WATER_VAPOR){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === ACID_STEAM){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === CLOUD){
        cloudLife[ny][nx] = cloudLife[y][x];
        cloudLife[y][x] = 0;
        cloudMaxLife[ny][nx] = cloudMaxLife[y][x];
      }
      if(newElem === FIRE){
        fireLife[ny][nx] = fireLife[y][x];
        fireLife[y][x] = 0;
      }
      if(newElem === SMOKE){
        smokeLife[ny][nx] = smokeLife[y][x];
        smokeLife[y][x] = 0;
        smokeMaxLife[ny][nx] = smokeMaxLife[y][x];
      }
      if(newElem === BURNING_WOOD || newElem === BURNING_ORGANIC || newElem === BURNING_ROOT){
        burningWoodTime[ny][nx] = burningWoodTime[y][x];
        burningWoodTime[y][x] = 0;
      }
      if(newElem === WHEAT_SEEDS){
        seedGrowthTime[ny][nx] = seedGrowthTime[y][x];
        seedGrowthTime[y][x] = 0;
      }
      if(newElem === WHEAT){
        wheatHeight[ny][nx] = wheatHeight[y][x];
        wheatMaxHeight[ny][nx] = wheatMaxHeight[y][x];
        wheatHeight[y][x] = 0;
        wheatMaxHeight[y][x] = 0;
      }
      if(newElem === BOUNCY_BALL) {
        ballVelocityX[ny][nx] = ballVelocityX[y][x];
        ballVelocityY[ny][nx] = ballVelocityY[y][x];
        ballVelocityX[y][x] = 0;
        ballVelocityY[y][x] = 0;
      }
      if(newElem === GAS || newElem === BURNING_GAS){
        burningGasTime[ny][nx] = burningGasTime[y][x];
        burningGasTime[y][x] = 0;
      }
      if(newElem === GRASS){
        grassStage[ny][nx] = grassStage[y][x];
      }
      if(newElem === SPARK){
        sparkLife[ny][nx] = sparkLife[y][x];
        sparkTimer[ny][nx] = sparkTimer[y][x];
        sparkLife[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      if(newElem === CHARGED_COPPER || newElem === CHARGED_DOWN_COPPER ||
         newElem === CHARGED_HEAT_SEPARATOR || newElem === CHARGED_DOWN_HEAT_SEPARATOR ||
         newElem === CHARGED_INPUT || newElem === CHARGED_OUTPUT ||
         newElem === CHARGED_BLOCKER){
        chargedStateTime[ny][nx] = chargedStateTime[y][x];
        chargedStateTime[y][x] = 0;
      }
    }
    function moveLikePowder(x, y, oldT, elem){
      // Handle salt behavior
      if (elem === SALT) {
        // Check for water to create salt water
        const checkDirections = [[0,1], [1,0], [-1,0], [0,-1]];
        for (const [dx, dy] of checkDirections) {
          const nx = x + dx;
          const ny = y + dy;
          if (isInGrid(nx, ny) && grid[ny][nx] === WATER) {
            // Create salt water
            setCellType(nx, ny, SALT_WATER, temp[ny][nx]);
            // Remove the salt grain
            eraseCell(x, y);
            return true;
          }
        }
        
        // Check if salt should melt
        if (temp[y][x] > saltMeltingTemp) {
          setCellType(x, y, MOLTEN_SLAG, temp[y][x]);
          return true;
        }
        
      }
      
      // Original powder movement for other elements
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      // Handle falling into salt water (same as water displacement)
      else if(y+1 < GRID_SIZE && grid[y+1][x] === SALT_WATER && !moved[y+1][x]) {
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move salt water up
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = SALT_WATER;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move powder down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        } else {
          // If no empty space found, behave like normal powder
          let diag = [];
          if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
          if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
          shuffle(diag);
          for(let d of diag){
            let nx = x + d, ny = y + 1;
            if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
              moveCell(x, y, nx, ny, oldT, elem);
              break;
            }
          }
        }
        return;
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA || grid[y+1][x] === BLOOD) && !moved[y+1][x]){
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move powder down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        } else {
          // If no empty space found, behave like normal powder
          let diag = [];
          if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
          if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
          shuffle(diag);
          for(let d of diag){
            let nx = x + d, ny = y + 1;
            if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
              moveCell(x, y, nx, ny, oldT, elem);
              break;
            }
          }
        }
      }
      else{
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y + 1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            break;
          }
        }
      }
    }
    function moveNonPowderGravity(x, y, oldT, elem) {
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA || grid[y+1][x] === BLOOD || grid[y+1][x] === SALT_WATER) && !moved[y+1][x]){
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move element down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        }
      }
    }

    function moveLikeLiquid(x, y, oldT, elem){
      // Handle salt water behavior
      if (elem === SALT_WATER) {
        // Check for evaporation at moderate temperatures (lowered from 100Â°C to 50Â°C)
        // Increased evaporation chance from 0.1% to 1% per frame
        if (Math.random() < 0.01 && temp[y][x] > 50) {
          // 70% chance to leave salt behind when evaporating
          if (Math.random() > 0.3) {
            setCellType(x, y, SALT, temp[y][x]);
          } else {
            eraseCell(x, y);
          }
          // Create water vapor above
          if (y > 0 && grid[y-1][x] === EMPTY) {
            setCellType(x, y-1, WATER_VAPOR, temp[y][x] + 20);
          }
          return true;
        }
        
        // Salt water sinks below regular water
        if (y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]) {
          // Swap with water below
          setCellType(x, y+1, SALT_WATER, temp[y+1][x]);
          setCellType(x, y, WATER, oldT);
          moved[y+1][x] = true;
          return true;
        }
        
        // Salt water also sinks below sugar water (denser than sugar water)
        if (y+1 < GRID_SIZE && grid[y+1][x] === SUGAR_WATER && !moved[y+1][x]) {
          // Swap with sugar water below
          setCellType(x, y+1, SALT_WATER, temp[y+1][x]);
          setCellType(x, y, SUGAR_WATER, oldT);
          moved[y+1][x] = true;
          return true;
        }
      }
      
      // Slow down lava movement
      if(elem === LAVA && Math.random() < 0.5) return;

      if(y+1 < GRID_SIZE && [EMPTY].includes(grid[y+1][x]) && !moved[y+1][x]){
        let below = grid[y+1][x];
        if(below === CLOUD){
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = CLOUD;
          temp[y][x] = 50;
          cloudLife[y][x] = 0;
          moved[y+1][x] = true;
          return;
        }
        else if(below === WATER_VAPOR){
          // Save the vapor's properties before moving it
          let vaporTemp = temp[y+1][x];
          let vaporLifeValue = vaporLife[y+1][x];
          
          if(y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
            // Move vapor up properly
            grid[y-1][x] = WATER_VAPOR;
            temp[y-1][x] = vaporTemp;
            vaporLife[y-1][x] = vaporLifeValue;
            moved[y-1][x] = true;
            
            // Now move water down safely
            grid[y+1][x] = elem;
            temp[y+1][x] = oldT;
            grid[y][x] = EMPTY;
            temp[y][x] = null;
            moved[y+1][x] = true;
          } else {
            // Try to move vapor to the sides if possible
            let moved_vapor = false;
            let sides = [[-1, 0], [1, 0]];
            shuffle(sides);
            
            for(let i = 0; i < sides.length; i++) {
              let dx = sides[i][0];
              let dy = sides[i][1];
              let vx = x + dx, vy = y + 1;
              if(vx >= 0 && vx < GRID_SIZE && vy >= 0 && vy < GRID_SIZE && 
                grid[vy][vx] === EMPTY && !moved[vy][vx]) {
                // Move vapor to the side
                grid[vy][vx] = WATER_VAPOR;
                temp[vy][vx] = vaporTemp;
                vaporLife[vy][vx] = vaporLifeValue;
                moved[vy][vx] = true;
                moved_vapor = true;
                break;
              }
            }
            
            // Only if we couldn't move vapor anywhere, proceed with water movement
            if(!moved_vapor) {
              moveCell(x, y, x, y+1, oldT, elem);
            } else {
              // Water moves down, vapor moved to side
              grid[y+1][x] = elem;
              temp[y+1][x] = oldT;
              grid[y][x] = EMPTY;
              temp[y][x] = null;
              moved[y+1][x] = true;
            }
          }
          return; // Important to return here
        }
        else {
          moveCell(x, y, x, y+1, oldT, elem);
        }
      }
      else {
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let dir of dirs){
          let nx = x + dir, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y+1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
      }
    }
    function moveFire(x, y, oldT){
      let possible = [[0,-1], [-1,-1], [1,-1], [-1,0], [1,0]];
      shuffle(possible);
      for(let [dx, dy] of possible){
        let nx = x + dx, ny = y + dy;
        if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, FIRE);
            break;
          }
        }
      }
    }
    function moveSmoke(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, SMOKE);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, SMOKE);
            break;
          }
        }
      }
    }
    function moveBouncyBall(x, y, oldT) {
  // Apply gravity to velocity
  ballVelocityY[y][x] += 0.2;
  
  // Decrease sound cooldown timer
  if (ballSoundCooldown[y][x] > 0) {
    ballSoundCooldown[y][x]--;
  }
  
  // Calculate new position based on velocity
  let nx = Math.round(x + ballVelocityX[y][x]);
  let ny = Math.round(y + ballVelocityY[y][x]);
  
  // Check boundaries and handle bouncing
  if (nx < 0) {
    nx = 0;
    ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.8; // Bounce with energy loss
    // Only play sound if cooldown has expired and bounce is significant
    if (ballSoundCooldown[y][x] <= 0 && Math.abs(ballVelocityX[y][x]) >= 2.0) {
      playBouncingSound();
      ballSoundCooldown[y][x] = 30; // 30 frame cooldown (~0.5 seconds at 60fps)
    }
  } else if (nx >= GRID_SIZE) {
    nx = GRID_SIZE - 1;
    ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.8;
    // Only play sound if cooldown has expired and bounce is significant
    if (ballSoundCooldown[y][x] <= 0 && Math.abs(ballVelocityX[y][x]) >= 2.0) {
      playBouncingSound();
      ballSoundCooldown[y][x] = 30; // 30 frame cooldown (~0.5 seconds at 60fps)
    }
  }
  
  if (ny < 0) {
    ny = 0;
    ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.8;
    // Only play sound if cooldown has expired and bounce is significant
    if (ballSoundCooldown[y][x] <= 0 && Math.abs(ballVelocityY[y][x]) >= 2.0) {
      playBouncingSound();
      ballSoundCooldown[y][x] = 30; // 30 frame cooldown (~0.5 seconds at 60fps)
    }
  } else if (ny >= GRID_SIZE) {
    ny = GRID_SIZE - 1;
    ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.8;
    // Only play sound if cooldown has expired and bounce is significant
    if (ballSoundCooldown[y][x] <= 0 && Math.abs(ballVelocityY[y][x]) >= 2.0) {
      playBouncingSound();
      ballSoundCooldown[y][x] = 30; // 30 frame cooldown (~0.5 seconds at 60fps)
    }
  }
  
  // Check destination cell
  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
    if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
      // Empty space - normal movement
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
    } 
    else if (grid[ny][nx] === WATER && !moved[ny][nx]) {
      // Move through water (slower and less bouncy)
      ballVelocityX[y][x] *= 0.7; // Slow down in water
      ballVelocityY[y][x] *= 0.7;
      
      // Save the water to place it behind the ball
      let waterTemp = temp[ny][nx];
      
      // Move the ball
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
      
      // Place water in the original position
      grid[y][x] = WATER;
      temp[y][x] = waterTemp;
    }
    else if (grid[ny][nx] === OIL && !moved[ny][nx]) {
      // Move through oil (faster)
      ballVelocityX[y][x] *= 1.2; // Speed up in oil
      ballVelocityY[y][x] *= 1.2;
      
      // Save the oil to place it behind the ball
      let oilTemp = temp[ny][nx];
      
      // Move the ball
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
      
      // Place oil in the original position
      grid[y][x] = OIL;
      temp[y][x] = oilTemp;
    }
    else if (grid[ny][nx] === LAVA || grid[ny][nx] === FIRE) {
      // Burn in lava or fire
      eraseCell(x, y);
      // Optional: create some fire or smoke particles
      if (Math.random() < 0.5) {
        grid[y][x] = FIRE;
        temp[y][x] = fireTemperature;
        fireLife[y][x] = 0;
      } else {
        grid[y][x] = SMOKE;
        temp[y][x] = 100;
        smokeLife[y][x] = 0;
      }
    }
    else {
      // Collision with something else - bounce
      // Calculate bounce direction based on the direction of impact
      let dx = nx - x;
      let dy = ny - y;
      
      if (dx !== 0) {
        ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.9;
      }
      if (dy !== 0) {
        ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.9;
      }
      
      // Add a small random component to prevent getting stuck
      ballVelocityX[y][x] += (Math.random() - 0.5) * 0.1;
      ballVelocityY[y][x] += (Math.random() - 0.5) * 0.1;
      
      // Only play bounce sound if cooldown has expired and bounce is significant
      const totalVelocity = Math.sqrt(ballVelocityX[y][x] * ballVelocityX[y][x] + ballVelocityY[y][x] * ballVelocityY[y][x]);
      if (ballSoundCooldown[y][x] <= 0 && totalVelocity >= 2.0) {
        playBouncingSound();
        ballSoundCooldown[y][x] = 30; // 30 frame cooldown (~0.5 seconds at 60fps)
      }
    }
  }
  
  // Apply minimum velocity threshold to prevent tiny movements
  if (Math.abs(ballVelocityX[y][x]) < 0.05) ballVelocityX[y][x] = 0;
  if (Math.abs(ballVelocityY[y][x]) < 0.05) ballVelocityY[y][x] = 0;
  
  // If ball has stopped completely, give it a tiny kick to prevent sticking
  if (ballVelocityX[y][x] === 0 && ballVelocityY[y][x] === 0 && Math.random() < 0.1) {
    ballVelocityY[y][x] = -0.1; // Small upward kick
    ballVelocityX[y][x] = (Math.random() - 0.5) * 0.2;
  }
}  
      function moveVaporUp(x, y, oldT){
        let ty = y - 1;
        if(ty >= 0){
          if(grid[ty][x] === EMPTY && !moved[ty][x]){
            moveCell(x, y, x, ty, oldT, WATER_VAPOR);
            return;
          }
          else if(grid[ty][x] === WATER && !moved[ty][x]){
            let swpT = temp[ty][x];
            
            // Save the vapor's life value
            let currentVaporLife = vaporLife[y][x];
            
            // Update the cell above (water becomes vapor)
            grid[ty][x] = WATER_VAPOR;
            temp[ty][x] = oldT;
            vaporLife[ty][x] = currentVaporLife;
            moved[ty][x] = true;
            
            // Update the current cell (vapor becomes water)
            grid[y][x] = WATER;
            temp[y][x] = swpT;
            vaporLife[y][x] = 0; // Clear the vapor life in the old position
            
            return;
          }
        }
        
        // Rest of the function remains the same
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, WATER_VAPOR);
            return;
          }
        }
      }
    function moveCloud(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, CLOUD);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, CLOUD);
            break;
          }
        }
      }
    }
    function moveGasElement(x, y, oldT, elem){
      let possible = [];
      for(let dy = -1; dy <= 1; dy++){
        for(let dx = -1; dx <= 1; dx++){
          if(dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            possible.push([dx, dy]);
          }
        }
      }
      if(possible.length > 0){
        let [dx, dy] = possible[Math.floor(Math.random() * possible.length)];
        moveCell(x, y, x + dx, y + dy, oldT, elem);
      }
    }
    function moveHelium(x, y, oldT) {
      // First try to move directly up
      if (y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]) {
        moveCell(x, y, x, y-1, oldT, HELIUM);
        return;
      }
      
      // Then try diagonally up
      let dirs = shuffle([-1, 1]);
      for (let dir of dirs) {
        let nx = x + dir, ny = y - 1;
        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && grid[ny][nx] === EMPTY && !moved[ny][nx]) {
          moveCell(x, y, nx, ny, oldT, HELIUM);
          return;
        }
      }
      
      // If can't move up, move like regular gas
      moveGasElement(x, y, oldT, HELIUM);
    }
    /***************************************
     * BOMBS & TEMPERATURE
     ***************************************/
    function explodeBomb(cx, cy){
      playExplosionSound(BOMB);
      eraseCell(cx, cy);
      let radius = bombExplosionRadius;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB){
              explodeBomb(x, y);
            }
            else {
              if(Math.random() < 0.3){
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function explodeBigBomb(cx, cy){
      playExplosionSound(BIG_BOMB);
      eraseCell(cx, cy);
      let radius = bombExplosionRadius * 4; // Double the radius
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
               grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
            }
            else {
              if(Math.random() < 0.6){ // Increased chance to erase
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }

    function explodeWaterBomb(cx, cy){
      playExplosionSound(WATER_BOMB);
      eraseCell(cx, cy);
      let radius = bombExplosionRadius;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          grid[y][x] = WATER;
          temp[y][x] = 20;
        }
      }
    }
  }
}

function explodeFireBomb(cx, cy){
  playExplosionSound(FIRE_BOMB);
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 1.5; // Slightly larger radius
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === EMPTY) {
          // Always place fire in empty cells
          grid[y][x] = FIRE;
          temp[y][x] = fireTemperature * 2; // Hotter fire
          fireLife[y][x] = 0;
        }
        else {
          // For non-empty cells, set them on fire if possible
          let e = grid[y][x];
          if(e === WOOD) {
            grid[y][x] = BURNING_WOOD;
            temp[y][x] = fireTemperature;
            burningWoodTime[y][x] = 0;
          } 
          else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES) {
            grid[y][x] = BURNING_LEAVES;
            temp[y][x] = fireTemperature;
          }
          else {
            // For other elements, just make them very hot
            temp[y][x] = Math.max(temp[y][x] || 0, fireTemperature * 1.5);
          }
        }
      }
    }
  }
}

function explodeCryoBomb(cx, cy){
  playExplosionSound(CRYO_BOMB);
  eraseCell(cx, cy);
  let radius = bombExplosionRadius;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === WATER) {
          grid[y][x] = ICE;
          temp[y][x] = -20;
        }
        else {
          temp[y][x] = -50;
        }
      }
    }
  }
}

    function explodeNukeBomb(cx, cy){
      playExplosionSound(NUKE_BOMB);
      eraseCell(cx, cy);
      let radius = bombExplosionRadius * 25;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
               grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
            }
            else {
              if(dist < radius / 3) {
                eraseCell(x, y);
              }
              else if(dist < radius * 2/3) {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature * 2;
                fireLife[y][x] = 0;
              }
              else {
                if(Math.random() < 0.7) {
                  grid[y][x] = FIRE;
                  temp[y][x] = fireTemperature;
                  fireLife[y][x] = 0;
                }
              }
            }
          }
        }
      }
    }

    // Custom element explosion function
    function explodeCustomElement(cx, cy, customElement){
      playExplosionSound(BOMB); // Use default explosion sound for now
      eraseCell(cx, cy);
      
      // Calculate explosion radius based on custom element properties
      let radius = Math.max(1, Math.min(15, customElement.explosionRadius || 3));
      
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            let e = grid[y][x];
            
            // Check for chain explosions
            if(e === BOMB || e === BIG_BOMB || e === WATER_BOMB || 
               e === FIRE_BOMB || e === CRYO_BOMB || e === NUKE_BOMB){
              if(e === BOMB) explodeBomb(x, y);
              else if(e === BIG_BOMB) explodeBigBomb(x, y);
              else if(e === WATER_BOMB) explodeWaterBomb(x, y);
              else if(e === FIRE_BOMB) explodeFireBomb(x, y);
              else if(e === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(e === NUKE_BOMB) explodeNukeBomb(x, y);
            }
            // Chain explode other custom explosives
            else if(e >= CUSTOM_ELEMENT_START && customElements[e] && customElements[e].explosive){
              explodeCustomElement(x, y, customElements[e]);
            }
            else {
              // Determine explosion effect based on custom element type
              let explosionType = customElement.explosionType || 'fire';
              let destructionChance = Math.max(0.1, Math.min(0.8, customElement.explosionPower || 0.4));
              
              if(Math.random() < destructionChance){
                eraseCell(x, y);
              }
              else {
                switch(explosionType) {
                  case 'fire':
                    grid[y][x] = FIRE;
                    temp[y][x] = fireTemperature;
                    fireLife[y][x] = 0;
                    break;
                  case 'water':
                    grid[y][x] = WATER;
                    temp[y][x] = 20;
                    break;
                  case 'ice':
                    grid[y][x] = ICE;
                    temp[y][x] = -20;
                    break;
                  case 'lava':
                    grid[y][x] = LAVA;
                    temp[y][x] = 1200;
                    break;
                  default:
                    grid[y][x] = FIRE;
                    temp[y][x] = fireTemperature;
                    fireLife[y][x] = 0;
                }
              }
            }
          }
        }
      }
    }
    function unifyCopperClusters(){
      // Skip this function for very large grid sizes to prevent performance issues
      if (GRID_SIZE > 200) return;
      
      let visited = [];
      for(let y = 0; y < GRID_SIZE; y++){
        visited[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          visited[y][x] = false;
        }
      }
      
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === COPPER && !visited[y][x]){
            let cluster = [], sumT = 0;
            let queue = [[x, y]];
            visited[y][x] = true;
            
            // Limit cluster size to prevent performance issues
            const maxClusterSize = 1000;
            
            while(queue.length > 0 && cluster.length < maxClusterSize){
              let [cx, cy] = queue.shift();
              cluster.push([cx, cy]);
              
              // Safely add temperature, handling null or undefined
              const cellTemp = temp[cy][cx];
              if (cellTemp !== null && cellTemp !== undefined && !isNaN(cellTemp)) {
                sumT += cellTemp;
              } else {
                // Default temperature if none exists
                sumT += 20;
              }
              
              for(let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]){
                let nx = cx + dx, ny = cy + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(!visited[ny][nx] && grid[ny][nx] === COPPER){
                    visited[ny][nx] = true;
                    queue.push([nx, ny]);
                  }
                }
              }
            }
            
            // Calculate average temperature with safety checks
            let avg = 20; // Default temperature
            if (cluster.length > 0) {
              avg = sumT / cluster.length;
              
              // Sanity check to prevent extreme temperatures
              if (isNaN(avg) || !isFinite(avg)) {
                avg = 20;
              } else {
                // Clamp temperature to reasonable range
                avg = Math.max(-273, Math.min(3000, avg));
              }
            }
            
            // Apply the average temperature to all cells in the cluster
            for(let [cx, cy] of cluster){
              temp[cy][cx] = avg;
            }
          }
        }
      }
    }
    function updateTemperature(){
      let newTemp = [];
      for(let y = 0; y < GRID_SIZE; y++){
        newTemp[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          newTemp[y][x] = temp[y][x];
        }
      }
      
      // Process non-copper elements first
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Skip copper elements for now - we'll handle them separately
          if(e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) {
            continue;
          }
          
          if(e === EMPTY || temp[y][x] === null){
            newTemp[y][x] = null;
            continue;
          }
          if(e === FIRE){
            newTemp[y][x] = fireTemperature;
            continue;
          }
          
          // Get current temperature with safety check
          let oldT = temp[y][x];
          if (isNaN(oldT) || !isFinite(oldT)) {
            oldT = 20; // Reset to default if it's NaN or infinite
            temp[y][x] = oldT; // Fix the original temperature too
          }
          
          let wSum = 0, tWeight = 0;
          for(let dy = -1; dy <= 1; dy++){
            for(let dx = -1; dx <= 1; dx++){
              if(dx === 0 && dy === 0) continue;
              let ny = y + dy, nx = x + dx;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx], nt = temp[ny][nx];
                if(ne !== EMPTY && nt !== null){
                  // Skip invalid temperatures
                  if (isNaN(nt) || !isFinite(nt)) continue;
                  
                  if((e === HEAT_SEPARATOR || e === CHARGED_HEAT_SEPARATOR || e === CHARGED_DOWN_HEAT_SEPARATOR) &&
                     (ne === COPPER || ne === CHARGED_COPPER || ne === CHARGED_DOWN_COPPER)){
                    continue;
                  }
                  
                  let cFactor = conductionRates[e] * conductionRates[ne];
                  wSum += cFactor * nt;
                  tWeight += cFactor;
                }
              }
            }
          }
          
          if(tWeight > 0){
            let avg = wSum / tWeight;
            
            // Safety check for the average
            if (isNaN(avg) || !isFinite(avg)) {
              avg = oldT; // Keep the old temperature if calculation is invalid
            }
            
            let cap = heatCapacities[e] || 1.0; // Default to 1.0 if undefined
            
            // Use custom element heat capacity if applicable
            if (e >= CUSTOM_ELEMENT_START && customElements[e]) {
              cap = customElements[e].heatCapacity || 1.0;
            }
            let myFactor = (conductionRates[e] || 0.5) * diffusionRate;
            
            // Limit the rate of temperature change
            let maxDelta = 10; // Maximum temperature change per step
            let rawDelta = myFactor * (avg - oldT) / cap;
            let delta = Math.max(-maxDelta, Math.min(maxDelta, rawDelta));
            
            // Calculate new temperature with bounds
            let newT = oldT + delta;
            newTemp[y][x] = Math.max(-273, Math.min(3000, newT)); // Clamp to reasonable range
          }
        }
      }
      
      // Now handle copper elements with more careful temperature handling
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          if(e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) {
            if(temp[y][x] === null){
              newTemp[y][x] = 20; // Default temperature for copper
              continue;
            }
            
            // Get current temperature with safety check
            let oldT = temp[y][x];
            if (isNaN(oldT) || !isFinite(oldT)) {
              oldT = 20; // Reset to default if it's NaN or infinite
              temp[y][x] = oldT; // Fix the original temperature too
            }
            
            // Copper conducts heat more gradually to prevent temperature spikes
            let wSum = 0, tWeight = 0;
            let validNeighbors = 0;
            
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                if(dx === 0 && dy === 0) continue;
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let ne = grid[ny][nx], nt = temp[ny][nx];
                  if(ne !== EMPTY && nt !== null){
                    // Skip invalid temperatures
                    if (isNaN(nt) || !isFinite(nt)) continue;
                    
                    // Skip heat separators
                    if(ne === HEAT_SEPARATOR || ne === CHARGED_HEAT_SEPARATOR || e === CHARGED_DOWN_HEAT_SEPARATOR){
                      continue;
                    }
                    
                    validNeighbors++;
                    let cFactor = 0.5 * conductionRates[ne]; // Reduced factor for copper
                    wSum += cFactor * nt;
                    tWeight += cFactor;
                  }
                }
              }
            }
            
            if(tWeight > 0 && validNeighbors > 0){
              let avg = wSum / tWeight;
              
              // Safety check for the average
              if (isNaN(avg) || !isFinite(avg)) {
                avg = oldT; // Keep the old temperature if calculation is invalid
              }
              
              // For copper, use a much smaller temperature change rate
              let copperDiffusionRate = diffusionRate * 0.2; // 20% of normal diffusion rate
              let delta = copperDiffusionRate * (avg - oldT);
              
              // Limit the maximum temperature change for copper
              delta = Math.max(-5, Math.min(5, delta));
              
              // Calculate new temperature with bounds
              let newT = oldT + delta;
              newTemp[y][x] = Math.max(-273, Math.min(3000, newT)); // Clamp to reasonable range
            }
          }
        }
      }
      
      // Handle burning coal separately
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_COAL || grid[y][x] === BURNING_COAL_LUMP){
            if(temp[y][x] !== null && newTemp[y][x] !== null) {
              let oldT = temp[y][x];
              if (isNaN(oldT) || !isFinite(oldT)) {
                oldT = 20;
                temp[y][x] = oldT;
              }
              
              let delta = newTemp[y][x] - oldT;
              if(delta > 0) newTemp[y][x] = oldT + delta * 0.1;
              if(newTemp[y][x] > 500) newTemp[y][x] = 500;
            }
          }
        }
      }
      temp = newTemp;
    }
    /***************************************
     * REACTIONS & TRANSFORMS
     ***************************************/
    function processTransformations() {
      transformLavaToRock();
      transformWaterAndLavaToStone();
      transformWaterVapor();
      transformCloudToWater();
      transformIceWater();
      transformFireToSmoke();
      transformBurningWood();
      transformWoodIgnition();
      transformBurningLeaves();
      transformSandToGlass();
      transformDirtWetDirt();
      transformSandWetSand();
      transformFlourToDough();
      transformDoughToBread();
      transformBreadToAshIfHot();
      handleSeedsGrowth();
      handleWheatGrowth();
      handleWheatRootGrowth();
      handleRootsAbsorbWater();
      handleFlammables();
      handleOakTreeGrowth();
      handleOakTreeRootGrowth();
      handleBirchTreeGrowth();
      handleBirchTreeRootGrowth();
      handleGrassGrowth();
      igniteHotElements();
      triggerBombs();
      transformGas();
      handleBurningGas();
      transformRoots();
      handleChargedCopper();
      handleElectricalElements();
      handleCoolerHeater();
      handleCloners();
      transformThermite();
      transformGrass();
      handleCellBehavior();
      handleGlassShardCreation();
      
      // New element transformations
      transformSugarToSugarWater();
      transformSugarWater();
      transformPlant();
      transformDiamond();
      transformConfetti();
      transformOxidizedCopper();
      
      // Handle new physics elements
      handlePhotons();
      handleLightning();
      handleDenseClouds();
      transformCloudsToDense();
      
      // Process all melting transformations in a unified way
      handleElementMelting();
      
      // Process cooling of molten elements back to their solid forms
      handleMoltenElementCooling();
      
      // Handle new elements
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Handle meat cooking
          if(e === MEAT && temp[y][x] >= doughBakeTemp){
            setCellType(x, y, COOKED_MEAT, 30);
          }
          
          // Handle bird cooking
          if(e === BIRD && temp[y][x] >= doughBakeTemp){
            setCellType(x, y, COOKED_MEAT, 30);
          }
          
          // Handle cobblestone melting - now using defined constant
          if(e === COBBLESTONE && temp[y][x] >= cobbleMeltingTemp){
            setCellType(x, y, MOLTEN_SLAG, cobbleMeltingTemp + 100);
          }
          
          // Handle ice melting - special case transition to water
          if(e === ICE && temp[y][x] > iceMeltingTemp){
            setCellType(x, y, WATER, Math.max(temp[y][x], 1)); // Keep current temp, but ensure it's at least 1Â°C
          }
          
          // Handle oil ignition
          if(e === OIL){
            let shouldIgnite = false;
            if(temp[y][x] >= 200) shouldIgnite = true;
            
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              setCellType(x, y, BURNING_GAS, fireTemperature);
              burningGasTime[y][x] = 0;
            }
          }
          
          // Handle Carbon Dioxide transformation
          if(e === CARBON_DIOXIDE){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === WHEAT || ne === GRASS || ne === OAK_LEAVES || 
                   ne === OAK_BABY_LEAVES || ne === BIRCH_LEAVES || 
                   ne === BIRCH_BABY_LEAVES || ne === WHEAT_SEEDS){
                  setCellType(x, y, OXYGEN, 20);
                  break;
                }
              }
            }
          }
          
          // Handle Oxygen reactions
          if(e === OXYGEN){
            let shouldIgnite = false;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            
            // Check for burning elements
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
                // Check for birds (convert to CO2)
                if(ne === BIRD){
                  setCellType(x, y, CARBON_DIOXIDE, 20);
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              setCellType(x, y, FIRE, 500);
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
    // New transformation for Thermite:
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of neighbors){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    function igniteFlammable(x, y){
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      let e = grid[y][x];
      // Oak wood ignites easily
      if(e === WOOD){
        setCellType(x, y, BURNING_WOOD, getFireTemperatureForSource(WOOD));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      // Birch wood has a 50% chance to resist ignition from nearby flames
      else if(e === BIRCH_WOOD){
        if(Math.random() > 0.5) { // 50% chance to resist ignition
          setCellType(x, y, BURNING_WOOD, getFireTemperatureForSource(BIRCH_WOOD));
          burningWoodTime[y][x] = 0;
          sparkTimer[y][x] = 0;
        } else {
          // Just heat up the birch wood instead of igniting
          setCellType(x, y, BIRCH_WOOD, Math.min(temp[y][x] + 50, getFireTemperatureForSource(BIRCH_WOOD) - 50));
        }
      }
      else if(e === FLOUR || e === WHEAT_SEEDS || e === WHEAT){
        setCellType(x, y, BURNING_ORGANIC, getFireTemperatureForSource(e));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      // Oak leaves ignite easily
      else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
        setCellType(x, y, BURNING_LEAVES, getFireTemperatureForSource(e));
        sparkTimer[y][x] = 0;
      }
      // Birch leaves have a 60% chance to resist ignition from nearby flames
      else if(e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES){
        if(Math.random() > 0.6) { // 40% chance to ignite
          setCellType(x, y, BURNING_LEAVES, getFireTemperatureForSource(e));
          sparkTimer[y][x] = 0;
        } else {
          // Just heat up the birch leaves instead of igniting
          setCellType(x, y, e, Math.min(temp[y][x] + 50, getFireTemperatureForSource(e) - 50));
        }
      }
      else if(e === GRASS){
        setCellType(x, y, BURNING_ORGANIC, getFireTemperatureForSource(GRASS));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      else if(e === COAL){
        setCellType(x, y, BURNING_COAL, (temp[y][x] < 100 ? 100 : temp[y][x]));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      else if(e === COAL_LUMP){
        setCellType(x, y, BURNING_COAL_LUMP, (temp[y][x] < 100 ? 100 : temp[y][x]));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      else if(e === CONFETTI) {
        setCellType(x, y, FIRE, getFireTemperatureForSource(e));
        fireLife[y][x] = 0;
        // Create a colorful effect
        colorVariations[y][x] = {
          r: Math.random(),
          g: Math.random(),
          b: Math.random()
        };
      }
      else if(e === PLANT) {
        setCellType(x, y, FIRE, getFireTemperatureForSource(PLANT));
        fireLife[y][x] = 0;
      }
      else if(e === SUGAR) {
        // Sugar burns and caramelizes
        setCellType(x, y, FIRE, getFireTemperatureForSource(SUGAR));
        fireLife[y][x] = 0;
      }
      else if(e === GLUE) {
        // Glue burns slowly
        if(Math.random() < 0.6) { // 60% chance to ignite
          setCellType(x, y, FIRE, getFireTemperatureForSource(GLUE));
          fireLife[y][x] = 0;
        }
      }
      else if(e === SAWDUST){
        // Sawdust burns quickly like wood but with a shorter burn time
        setCellType(x, y, BURNING_ORGANIC, getFireTemperatureForSource(SAWDUST));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
    }
    function handleBurningGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_GAS){
            burningGasTime[y][x] += simulationTimeStep;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e === GAS){
                  grid[ny][nx] = BURNING_GAS; temp[ny][nx] = getFireTemperatureForSource(GAS); burningGasTime[ny][nx] = 0;
                }
                igniteFlammable(nx, ny);
              }
            }
            if(burningGasTime[y][x] >= burningGasDuration){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); burningGasTime[y][x] = 0;
            }
          }
        }
      }
    }
    function transformGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GAS){
            if(temp[y][x] >= 300){
              grid[y][x] = BURNING_GAS; temp[y][x] = getFireTemperatureForSource(GAS); burningGasTime[y][x] = 0;
            }
            else {
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let e = grid[ny][nx];
                  if(e === FIRE || e === BURNING_WOOD || e === BURNING_ORGANIC || e === BURNING_LEAVES || e === BURNING_ROOT || e === BURNING_GAS){
                    grid[y][x] = BURNING_GAS; temp[y][x] = getFireTemperatureForSource(GAS); burningGasTime[y][x] = 0; break;
                  }
                }
              }
            }
          }
        }
      }
    }
    function handleSeedsGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT_SEEDS){
        let below = grid[y+1][x];
            if(below === DIRT || below === WET_DIRT || below === SAND || below === WET_SAND || below === ROOT){
              seedGrowthTime[y][x] += simulationTimeStep;
              if(seedGrowthTime[y][x] >= 3){
                grid[y][x] = WHEAT; temp[y][x] = 20; wheatHeight[y][x] = 1; wheatMaxHeight[y][x] = 2 + Math.floor(Math.random() * 4);
                // Add color variation to wheat
                const variation = 0.1;
                colorVariations[y][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
              }
            }
          }
        }
      }
    }
    function handleWheatGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            let h = wheatHeight[y][x], mh = wheatMaxHeight[y][x];
            if(h < mh){
              if(Math.random() < 0.01){
                if(y > 0 && grid[y-1][x] === EMPTY){
                  grid[y-1][x] = WHEAT; temp[y-1][x] = 20; wheatHeight[y-1][x] = h + 1; wheatMaxHeight[y-1][x] = mh;
                  // Add color variation to wheat
                  const variation = 0.1;
                  colorVariations[y-1][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                }
              }
            }
          }
        }
      }
    }
    function handleWheatRootGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            for(let depth = 1; depth <= 2; depth++){
              let ny = y + depth;
              if(ny < GRID_SIZE){
                if(grid[ny][x] === EMPTY || grid[ny][x] === DIRT || grid[ny][x] === WET_DIRT || grid[ny][x] === SAND || grid[ny][x] === WET_SAND){
                  if(Math.random() < 0.0005){
                    placeElementAt(x, ny, ROOT);
                  }
                }
                else { break; }
              }
            }
          }
        }
      }
    }
    function handleRootsAbsorbWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT){
            let nb = [[1,0],[-1,0],[0,1],[0,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WET_DIRT){
                  grid[ny][nx] = DIRT; temp[ny][nx] = 20;
                }
                else if(grid[ny][nx] === WET_SAND){
                  grid[ny][nx] = SAND; temp[ny][nx] = 20;
                }
              }
            }
          }
        }
      }
    }
    function handleFlammables(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_ORGANIC){
            sparkTimer[y][x] += simulationTimeStep;
            let sparkLimit = 0.2 + 0.1 * Math.random();
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === EMPTY){
                    grid[ny][nx] = FIRE; temp[ny][nx] = getFireTemperatureForSource(BURNING_ORGANIC); fireLife[ny][nx] = 0;
                    break;
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= 1.0){
              let r = Math.random();
              if(r < burnToAshChance){
                grid[y][x] = ASH; temp[y][x] = 50;
              }
              else {
                grid[y][x] = FIRE; temp[y][x] = getFireTemperatureForSource(BURNING_ORGANIC); fireLife[y][x] = 0;
              }
            }
          }
          else if(grid[y][x] === BURNING_COAL){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = getFireTemperatureForSource(BURNING_COAL); fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoal){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
          else if(grid[y][x] === BURNING_COAL_LUMP){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = getFireTemperatureForSource(BURNING_COAL_LUMP); fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoalLump){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
        }
      }
    }
    function handleOakTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_SEEDS){
            // Only check for growing conditions if the seed has something solid below it
            // This allows seeds to fall naturally until they land on something
            if(y === GRID_SIZE - 1 || ![EMPTY, WATER, WATER_VAPOR, CLOUD, FIRE, SMOKE, OIL, ACID, ACID_STEAM, ACID_CLOUD].includes(grid[y+1][x])) {
              // Check if the seed is on suitable ground
              if(y === GRID_SIZE - 1){
                grid[y][x] = DEAD_OAK; temp[y][x] = 20;
              }
              else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
                grid[y][x] = DEAD_OAK; temp[y][x] = 20;
              }
              else {
                oakTreeGrowthTime[y][x] += simulationTimeStep;
                if(oakTreeGrowthTime[y][x] >= 15.0){
                  grid[y][x] = WOOD; temp[y][x] = 20;
                  // Add color variation to wood
                  const variation = 0.05;
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[y][x] = 1;
                  oakTreeMaxHeight[y][x] = 10 + Math.floor(Math.random() * 11);
                  oakTreeRootTimer[y][x] = 0;
                  oakTreeRootDepth[y][x] = 0;
                  oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                  branchLevel[y][x] = 0;
                  branchLen[y][x] = 0;
                  branchDirX[y][x] = 0;
                  branchDirY[y][x] = 0;
                  for(let dy = -1; dy <= 1; dy++){
                    for(let dx = -1; dx <= 1; dx++){
                      let nx = x + dx, ny = y + dy;
                      if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                        grid[ny][nx] = OAK_BABY_LEAVES; temp[ny][nx] = 20;
                        // Add color variation to baby leaves
                        const leafVariation = 0.1;
                        colorVariations[ny][nx] = {
                          r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === WOOD || grid[y-1][x] === OAK_LEAVES || grid[y-1][x] === OAK_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = WOOD; temp[y-1][x] = 20;
                // Add color variation to wood
                const variation = 0.05;
                colorVariations[y-1][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  // Add color variation to branch wood
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  // Add color variation to branch wood
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = OAK_LEAVES; temp[ny][nx] = 20;
                  // Add color variation to side leaves
                  const leafVariation = 0.1;
                  colorVariations[ny][nx] = {
                    r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                  };
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    function handleOakTreeRootGrowth(){
      const oakRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= oakRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    
    function handleBirchTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_SEEDS){
            // Only check for growing conditions if the seed has something solid below it
            // This allows seeds to fall naturally until they land on something
            if(y === GRID_SIZE - 1 || ![EMPTY, WATER, WATER_VAPOR, CLOUD, FIRE, SMOKE, OIL, ACID, ACID_STEAM, ACID_CLOUD].includes(grid[y+1][x])) {
              // Check if the seed is on suitable ground
              if(y === GRID_SIZE - 1){
                grid[y][x] = DEAD_BIRCH; temp[y][x] = 20;
              }
              else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
                grid[y][x] = DEAD_BIRCH; temp[y][x] = 20;
              }
              else {
                oakTreeGrowthTime[y][x] += simulationTimeStep;
                if(oakTreeGrowthTime[y][x] >= 15.0){
                  grid[y][x] = BIRCH_WOOD; temp[y][x] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for dark birch wood (now lighter)
                  if (Math.random() < 0.25) {
                    // Override the base color to be dark gray instead of black
                    colorVariations[y][x] = {
                      r: 0.35 + (Math.random() * 0.1),  // Lighter dark gray
                      g: 0.35 + (Math.random() * 0.1),
                      b: 0.35 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[y][x] = 1;
                  // Birch trees are a bit taller than oak trees
                  oakTreeMaxHeight[y][x] = 12 + Math.floor(Math.random() * 11);
                  oakTreeRootTimer[y][x] = 0;
                  oakTreeRootDepth[y][x] = 0;
                  oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                  branchLevel[y][x] = 0;
                  branchLen[y][x] = 0;
                  branchDirX[y][x] = 0;
                  branchDirY[y][x] = 0;
                  for(let dy = -1; dy <= 1; dy++){
                    for(let dx = -1; dx <= 1; dx++){
                      let nx = x + dx, ny = y + dy;
                      if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                        grid[ny][nx] = BIRCH_BABY_LEAVES; temp[ny][nx] = 20;
                        // Add color variation to leaves
                        const leafVariation = 0.1;
                        colorVariations[ny][nx] = {
                          r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === BIRCH_WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === BIRCH_WOOD || grid[y-1][x] === BIRCH_LEAVES || grid[y-1][x] === BIRCH_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = BIRCH_WOOD; temp[y-1][x] = 20;
                // Add color variation
                const variation = 0.05;
                colorVariations[y-1][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
                
                // 1/4 chance for dark birch wood (now lighter)
                if (Math.random() < 0.25) {
                  // Override the base color to be dark gray instead of black
                  colorVariations[y-1][x] = {
                    r: 0.35 + (Math.random() * 0.1),  // Lighter dark gray
                    g: 0.35 + (Math.random() * 0.1),
                    b: 0.35 + (Math.random() * 0.1)
                  };
                }
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === BIRCH_LEAVES || grid[by][bx] === BIRCH_BABY_LEAVES)){
                  grid[by][bx] = BIRCH_WOOD; temp[by][bx] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[by][bx] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = BIRCH_LEAVES; temp[ly][lx] = 20;
                      // Add color variation to leaves
                      const leafVariation = 0.1;
                      colorVariations[ly][lx] = {
                        r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                      };
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === BIRCH_LEAVES || grid[by][bx] === BIRCH_BABY_LEAVES)){
                  grid[by][bx] = BIRCH_WOOD; temp[by][bx] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[by][bx] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = BIRCH_LEAVES; temp[ly][lx] = 20;
                      // Add color variation to leaves
                      const leafVariation = 0.1;
                      colorVariations[ly][lx] = {
                        r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                      };
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = BIRCH_LEAVES; temp[ny][nx] = 20;
                  // Add color variation to leaves
                  const leafVariation = 0.1;
                  colorVariations[ny][nx] = {
                    r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                  };
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BIRCH_WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    
    function handleBirchTreeRootGrowth(){
      const birchRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= birchRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    
    function handleGrassGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GRASS){
            let st = grassStage[y][x];
            if(st === 1){
              if(y > 0 && grid[y-1][x] === EMPTY){
                if(Math.random() < 0.0005){
                  grid[y-1][x] = GRASS; grassStage[y-1][x] = 2; temp[y-1][x] = 20;
                }
              }
            }
            let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
              if(grid[ny][nx] === DIRT || grid[ny][nx] === WET_DIRT){
                let ay = ny - 1;
                if(ay >= 0){
                  if(grid[ay][nx] === EMPTY){
                    if(Math.random() < 0.0003){
                      grid[ny][nx] = GRASS; grassStage[ny][nx] = 1; temp[ny][nx] = 20;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformRoots(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT && temp[y][x] >= 200){
            grid[y][x] = BURNING_ROOT; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
          }
          else if(grid[y][x] === BURNING_ROOT){
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= burnDuration){
              grid[y][x] = DEAD_ROOT; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function igniteHotElements(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let t = temp[y][x];
          if(t !== null){
            let e = grid[y][x];
            // Oak wood ignites at 200Â°C
            if(e === WOOD && t > 200){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Birch wood requires higher temperature (350Â°C) to ignite
            else if(e === BIRCH_WOOD && t > 350){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            else if((e === FLOUR || e === WHEAT_SEEDS || e === WHEAT) && t > 200){
              grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Oak leaves ignite at 200Â°C
            else if((e === OAK_LEAVES || e === OAK_BABY_LEAVES) && t > 200){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Birch leaves require higher temperature (300Â°C) to ignite
            else if((e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES) && t > 300){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Handle custom flammable elements
            else if(e >= CUSTOM_ELEMENT_START && customElements[e] && customElements[e].flammable){
              const customElement = customElements[e];
              if(t > customElement.ignitionTemp){
                // Transform to fire and set appropriate temperature
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function triggerBombs(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          let isBuiltInBomb = (e === BOMB || e === BIG_BOMB || e === WATER_BOMB || 
                              e === FIRE_BOMB || e === CRYO_BOMB || e === NUKE_BOMB);
          let isCustomExplosive = (e >= CUSTOM_ELEMENT_START && customElements[e] && customElements[e].explosive);
          
          if(isBuiltInBomb || isCustomExplosive){
            // Temperature-based triggering
            let triggerTemp = isCustomExplosive ? customElements[e].explosionTemp : 200;
            if(temp[y][x] >= triggerTemp) {
              if(isCustomExplosive){
                explodeCustomElement(x, y, customElements[e]);
              } else {
                if(grid[y][x] === BOMB) explodeBomb(x, y);
                else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
                else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
                else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
                else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
                else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
              }
              continue;
            }
            
            // Fire-based triggering
            let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_LEAVES || ne === BURNING_ORGANIC || ne === BURNING_ROOT || ne === BURNING_GAS){
                  if(isCustomExplosive){
                    explodeCustomElement(x, y, customElements[e]);
                  } else {
                    if(grid[y][x] === BOMB) explodeBomb(x, y);
                    else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
                    else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
                    else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
                    else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
                    else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
                  }
                  break;
                }
              }
            }
          }
    }
  }
}
    function transformLavaToRock(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === LAVA && t < 600){
            if(Math.random() < 0.5){ grid[y][x] = BASALT; temp[y][x] = 500; }
            else { grid[y][x] = OBSIDIAN; temp[y][x] = 500; }
          }
          if(e === BASALT && t >= 800){ grid[y][x] = LAVA; temp[y][x] = 1200; }
          if(e === OBSIDIAN && t >= 700){ grid[y][x] = MOLTEN_SLAG; temp[y][x] = 1200; }
          if(e === MOLTEN_SLAG && t < 800){ grid[y][x] = OBSIDIAN; temp[y][x] = 600; }
        }
      }
    }
    function transformWaterAndLavaToStone(){
      // This function is intentionally left empty to prevent water and lava from turning into stone
      // when they come into contact with each other
      return;
      
      /* Original code (commented out):
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === WATER || e === LAVA){
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if((e === WATER && grid[ny][nx] === LAVA) || (e === LAVA && grid[ny][nx] === WATER)){
                    cpy[y][x] = STONE; temp[y][x] = 20;
                    cpy[ny][nx] = STONE; temp[ny][nx] = 20;
                  }
                }
              }
            }
          }
        }
      }
      */
      grid = cpy;
    }
    function transformWaterVapor(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WATER){
            if(temp[y][x] >= 100){
              grid[y][x] = WATER_VAPOR; temp[y][x] = 120; vaporLife[y][x] = 0;
            }
          }
          else if(grid[y][x] === WATER_VAPOR){
            // Only allow transformation to cloud if temperature is below 99Â°C
            if(temp[y][x] < 99 && (vaporLife[y][x] >= vaporTransformThreshold || vaporLife[y][x] >= 6)){
              let count = 0;
              for(let dy = -1; dy <= 1; dy++){
                for(let dx = -1; dx <= 1; dx++){
                  let ny = y + dy, nx = x + dx;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === WATER_VAPOR && vaporLife[ny][nx] >= vaporTransformThreshold){
                      count++;
                    }
                  }
                }
              }
              if(count >= 3 || vaporLife[y][x] >= 6){
                grid[y][x] = CLOUD; temp[y][x] = 50; cloudLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function transformCloudToWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLOUD){
            // If temperature is very high (â‰¥100Â°C), convert clouds to water vapor
            if(temp[y][x] >= 100) {
              grid[y][x] = WATER_VAPOR;
              temp[y][x] = 120; 
              vaporLife[y][x] = 0;
            }
            // Only allow transformation to water/snow if temperature is below 99Â°C
            else if(temp[y][x] < 99) {
              if(temp[y][x] < 10) {
                // Spawn snow if temperature is below 1Â°C, otherwise water
                if(temp[y][x] < 1) {
                  grid[y][x] = SNOW; 
                  temp[y][x] = -2; 
                } else {
                  grid[y][x] = WATER; 
                  temp[y][x] = 20; 
                }
              }
              else if(cloudLife[y][x] >= cloudMaxLife[y][x]) {
                // Spawn snow if temperature is below 1Â°C, otherwise water
                if(temp[y][x] < 1) {
                  grid[y][x] = SNOW; 
                  temp[y][x] = -2; 
                } else {
                  grid[y][x] = WATER; 
                  temp[y][x] = 20; 
                }
                cloudLife[y][x] = 0; 
              }
            }
          }
        }
      }
    }
    function transformIceWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === WATER && t < 0){ grid[y][x] = ICE; temp[y][x] = -5; }
          else if(e === ICE && t > 2){ grid[y][x] = WATER; temp[y][x] = 5; }
          else if(e === SNOW && t > 1){ grid[y][x] = WATER; temp[y][x] = 3; } // Snow melts at 1Â°C
        }
      }
    }
    function transformFireToSmoke(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            if(fireLife[y][x] >= fireLifetime){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random();
            }
            else { temp[y][x] = fireTemperature; }
          }
          else if(grid[y][x] === SMOKE){
            if(smokeLife[y][x] >= smokeMaxLife[y][x]){ eraseCell(x, y); }
          }
        }
      }
    }
    function transformBurningWood(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_WOOD){
            // Check if this was originally birch wood by looking at color variations
            // Birch wood typically has much lighter color variations than oak
            let isBirch = false;
            if (colorVariations[y][x]) {
              // If r, g, and b are all close to 1 or higher, it's likely birch wood
              // Or if it's very dark (black birch variant)
              if ((colorVariations[y][x].r > 0.95 && colorVariations[y][x].g > 0.95 && colorVariations[y][x].b > 0.95) ||
                  (colorVariations[y][x].r < 0.3 && colorVariations[y][x].g < 0.3 && colorVariations[y][x].b < 0.3)) {
                isBirch = true;
              }
            }
            
            // Sparks (fire spreading)
            sparkTimer[y][x] += simulationTimeStep;
            // Birch wood produces sparks less frequently
            let sparkLimit = isBirch ? (0.3 + 0.15 * Math.random()) : (0.2 + 0.1 * Math.random());
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              // Birch wood has less chance to spread fire
              if (!isBirch || Math.random() < 0.7) {
                for(let [dx, dy] of nb){
                  let nx = x + dx, ny = y + dy;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === EMPTY){
                      grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                      break;
                    }
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            
            // Burning duration
            // Birch wood burns 1.5x slower than oak wood
            let burnMultiplier = isBirch ? 0.67 : 1.0; // 1/1.5 = 0.67
            burningWoodTime[y][x] += simulationTimeStep * burnMultiplier;
            
            if(burningWoodTime[y][x] >= burnDuration){
              let r = Math.random();
              // Birch wood is more likely to turn to ash than to fire
              let ashChance = isBirch ? (burnToAshChance * 1.5) : burnToAshChance;
              ashChance = Math.min(ashChance, 0.9); // Cap at 90%
              
              let newElem = (r < ashChance) ? ASH : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 50; }
            }
          }
        }
      }
    }
    function transformWoodIgnition(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                // Oak wood ignites immediately on contact with fire
                if(e === WOOD){
                  grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                }
                // Birch wood has a 40% chance to resist immediate ignition from fire
                if(e === BIRCH_WOOD){
                  if(Math.random() > 0.4) { // 60% chance to ignite
                    grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                  } else {
                    // Just heat up the birch wood instead of igniting
                    temp[ny][nx] = Math.min(temp[ny][nx] + 75, 250);
                  }
                }
                // Oak leaves ignite immediately on contact with fire
                if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
                  grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                }
                // Birch leaves have a 50% chance to resist immediate ignition from fire
                if(e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES){
                  if(Math.random() > 0.5) { // 50% chance to ignite
                    grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                  } else {
                    // Just heat up the birch leaves instead of igniting
                    temp[ny][nx] = Math.min(temp[ny][nx] + 75, 250);
                  }
                }
                if(e === COAL){
                  grid[ny][nx] = BURNING_COAL; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
                if(e === COAL_LUMP){
                  grid[ny][nx] = BURNING_COAL_LUMP; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
                // Handle custom flammable elements
                if(e >= CUSTOM_ELEMENT_START && customElements[e] && customElements[e].flammable){
                  const customElement = customElements[e];
                  // Check if fire should ignite this custom element
                  if(Math.random() > (customElement.fireResistance || 0)){ // 0 = always ignites, 1 = never ignites
                    grid[ny][nx] = FIRE;
                    temp[ny][nx] = fireTemperature;
                    fireLife[ny][nx] = 0;
                  } else {
                    // Just heat it up instead of igniting
                    temp[ny][nx] = Math.min((temp[ny][nx] || 20) + 100, customElement.ignitionTemp - 10);
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformBurningLeaves(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_LEAVES){
            sparkTimer[y][x] += simulationTimeStep;
            if(sparkTimer[y][x] >= burnDuration){
              let r = Math.random();
              let newElem = (r < 0.5) ? DEAD_PLANT : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 20; }
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let en = grid[ny][nx];
                  if(en === WOOD || en === OAK_LEAVES || en === OAK_BABY_LEAVES){
                    if(en === WOOD){
                      grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                    else {
                      grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformSandToGlass(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND && temp[y][x] >= glassTemp){
            grid[y][x] = GLASS; temp[y][x] = 300;
          }
        }
      }
    }
    function transformDirtWetDirt(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === DIRT){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER || grid[ny][nx] === SALT_WATER){
                  cpy[y][x] = WET_DIRT; temp[y][x] = 20;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
          else if(e === WET_DIRT){
            if(temp[y][x] >= wetDirtEvapTemp){
              cpy[y][x] = DIRT; temp[y][x] = 20;
            }
            else {
              let foundWater = null, foundDirt = null;
              let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WATER) foundWater = [nx, ny];
                  if(grid[ny][nx] === DIRT) foundDirt = [nx, ny];
                }
              }
              if(foundWater && foundDirt){
                let [wx, wy] = foundWater, [dx2, dy2] = foundDirt;
                cpy[dy2][dx2] = WET_DIRT; temp[dy2][dx2] = 20;
                cpy[wy][wx] = EMPTY; temp[wy][wx] = null;
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformSandWetSand(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER || grid[ny][nx] === SALT_WATER){
                  grid[y][x] = WET_SAND; temp[y][x] = 20;
                  break;
                }
              }
            }
          }
          else if(grid[y][x] === WET_SAND){
            if(temp[y][x] >= wetDirtEvapTemp){
              grid[y][x] = SAND; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function transformFlourToDough(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FLOUR){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  cpy[y][x] = DOUGH; temp[y][x] = 25;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformDoughToBread(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === DOUGH && temp[y][x] >= doughBakeTemp){
            grid[y][x] = BREAD; temp[y][x] = 30;
          }
        }
      }
    }
    function transformBreadToAshIfHot(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BREAD && temp[y][x] >= breadBurnTemp){
            grid[y][x] = ASH; temp[y][x] = 50;
          }
        }
      }
    }
    function handleChargedCopper(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              cpy[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
              continue;
            }
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
                // Handle custom conductive elements
                else if(cpy[ny][nx] >= CUSTOM_ELEMENT_START && customElements[cpy[ny][nx]] && 
                       customElements[cpy[ny][nx]].conductive && temp[ny][nx] < 300){
                  // Convert custom conductive element to charged copper temporarily
                  // Store original element ID for later restoration
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_COPPER;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              grid[y][x] = COPPER; chargedStateTime[y][x] = 0; continue;
            }
            chargedStateTime[y][x] += simulationTimeStep;
            let anyCopper = false;
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){ 
                  anyCopper = true; break; 
                }
                // Check for custom conductive elements too
                else if(grid[ny][nx] >= CUSTOM_ELEMENT_START && customElements[grid[ny][nx]] && 
                       customElements[grid[ny][nx]].conductive && temp[ny][nx] < 300){
                  anyCopper = true; break;
                }
              }
            }
            if(!anyCopper || chargedStateTime[y][x] >= 1.0){
              grid[y][x] = CHARGED_DOWN_COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
          else if(e === CHARGED_DOWN_COPPER){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){
              grid[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
        }
      }
    }
    function handleElectricalElements(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_HEAT_SEPARATOR){
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === HEAT_SEPARATOR && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_HEAT_SEPARATOR;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
                // Handle custom conductive elements
                else if(cpy[ny][nx] >= CUSTOM_ELEMENT_START && customElements[cpy[ny][nx]] && 
                       customElements[cpy[ny][nx]].conductive && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_HEAT_SEPARATOR;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = CHARGED_DOWN_HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
          else if(e === CHARGED_DOWN_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
        }
      }
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === INPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let shouldCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_COPPER || grid[ny][nx] === CHARGED_DOWN_COPPER){ shouldCharge = true; break; }
              }
            }
            if(shouldCharge){ cpy[y][x] = CHARGED_INPUT; chargedStateTime[y][x] = 0; }
            else { cpy[y][x] = INPUT; }
          }
        }
      }
      grid = cpy;
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OUTPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let doCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === CHARGED_HEAT_SEPARATOR || ne === CHARGED_DOWN_HEAT_SEPARATOR ||
                   ne === CHARGED_OUTPUT || ne === CHARGED_BLOCKER || ne === NOT_GATE || ne === AND_GATE){
                  doCharge = true; break;
                }
              }
            }
            if(doCharge){ cpy[y][x] = CHARGED_OUTPUT; chargedStateTime[y][x] = chargedStateTime[y][x] || 0; }
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_OUTPUT){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 3.0){
              grid[y][x] = OUTPUT; chargedStateTime[y][x] = 0;
            }
          }
        }
      }
    }
    function handleCoolerHeater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === COOLER || e === HEATER){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let hasChargedInput = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_INPUT){ hasChargedInput = true; break; }
              }
            }
            if(!hasChargedInput) continue;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e2 = grid[ny][nx];
                if(e2 === CHARGED_COPPER || e2 === CHARGED_DOWN_COPPER){
                  if(e === COOLER){ temp[ny][nx] = Math.max(temp[ny][nx] - 100 * simulationTimeStep, -1000); }
                  else { temp[ny][nx] = Math.min(temp[ny][nx] + 100 * simulationTimeStep, 3000); }
                }
              }
            }
          }
        }
      }
    }
    function handleCloners(){
      let replication = [];
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLONER){
            let directions = [[0,-1],[0,1],[-1,0],[1,0]];
            let foundOccupants = [];
            for(let [dx, dy] of directions){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e !== EMPTY && e !== CLONER){
                  foundOccupants.push({ ox: nx, oy: ny });
                }
              }
            }
            if(foundOccupants.length > 0){
              for(let occupant of foundOccupants){
                let ex = occupant.ox, ey = occupant.oy;
                for(let [dx2, dy2] of directions){
                  let rx = x + dx2, ry = y + dy2;
                  if(rx >= 0 && rx < GRID_SIZE && ry >= 0 && ry < GRID_SIZE){
                    if(grid[ry][rx] === EMPTY){
                      replication.push({ srcX: ex, srcY: ey, dstX: rx, dstY: ry });
                    }
                  }
                }
              }
            }
          }
        }
      }
      for(let rep of replication){
        let sX = rep.srcX, sY = rep.srcY;
        let dX = rep.dstX, dY = rep.dstY;
        if(grid[dY][dX] !== EMPTY) continue;
        cloneCell(sX, sY, dX, dY);
      }
    }
    function cloneCell(sx, sy, dx, dy){
      let occupant = grid[sy][sx];
      grid[dy][dx] = occupant;
      temp[dy][dx] = temp[sy][sx];
      if(occupant === WATER_VAPOR){ vaporLife[dy][dx] = vaporLife[sy][sx]; }
      if(occupant === CLOUD){ cloudLife[dy][dx] = cloudLife[sy][sx]; cloudMaxLife[dy][dx] = cloudMaxLife[sy][dx]; }
      if(occupant === FIRE){ fireLife[dy][dx] = fireLife[sy][sx]; }
      if(occupant === SMOKE){ smokeLife[dy][dx] = smokeLife[sy][sx]; smokeMaxLife[dy][dx] = smokeMaxLife[sy][sx]; }
      if(occupant === BURNING_WOOD || occupant === BURNING_ORGANIC || occupant === BURNING_ROOT){ burningWoodTime[dy][dx] = burningWoodTime[sy][sx]; }
      if(occupant === WHEAT_SEEDS){ seedGrowthTime[dy][dx] = seedGrowthTime[sy][sx]; }
      if(occupant === WHEAT){ wheatHeight[dy][dx] = wheatHeight[sy][sx]; wheatMaxHeight[dy][dx] = wheatMaxHeight[sy][sx]; }
      if(occupant === GAS || occupant === BURNING_GAS){ burningGasTime[dy][dx] = burningGasTime[sy][sx]; }
      if(occupant === GRASS){ grassStage[dy][dx] = grassStage[sy][sx]; }
      if(occupant === SPARK){ sparkLife[dy][dx] = sparkLife[sy][sx]; sparkTimer[dy][dx] = sparkTimer[sy][sx]; }
      if(occupant === CHARGED_COPPER || occupant === CHARGED_DOWN_COPPER ||
         occupant === CHARGED_HEAT_SEPARATOR || occupant === CHARGED_DOWN_HEAT_SEPARATOR ||
         occupant === CHARGED_INPUT || occupant === CHARGED_OUTPUT || occupant === CHARGED_BLOCKER){
        chargedStateTime[dy][dx] = chargedStateTime[sy][dx];
      }
    }
    /*******************************************
     * New Elements: Cell, Blood, Glass Shard
     *******************************************/
    function handleCellBehavior() {
      for(let y = GRID_SIZE - 1; y >= 0; y--) {
        for(let x = 0; x < GRID_SIZE; x++) {
          if(grid[y][x] === CELL && !moved[y][x]) {
            // Make Cell fall like a slow-moving powder
            if(Math.random() < 0.3) { // Only move 30% of the time for slow movement
              if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                moveCell(x, y, x, y+1, temp[y][x], CELL);
                continue;
              } else {
                // Try to move diagonally
                let diag = [];
                if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
                if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
                shuffle(diag);
                for(let d of diag) {
                  let nx = x + d, ny = y + 1;
                  if(grid[ny][nx] === EMPTY && !moved[ny][nx]) {
                    moveCell(x, y, nx, ny, temp[y][x], CELL);
                    break;
                  }
                }
              }
            }
            // Cell can die from heat
            if(temp[y][x] > 50) {
              grid[y][x] = DEAD_CELL;
              continue;
            }
            
            // Cell can be killed by fire
            let touchingFire = false;
            let touchingGlassShard = false;
            
            for(let dy = -1; dy <= 1; dy++) {
              for(let dx = -1; dx <= 1; dx++) {
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if(grid[ny][nx] === FIRE) {
                    touchingFire = true;
                  }
                  if(grid[ny][nx] === GLASS_SHARD) {
                    touchingGlassShard = true;
                  }
                }
              }
            }
            
            if(touchingFire) {
              grid[y][x] = DEAD_CELL;
              continue;
            }
            
            // Cell can turn into blood if it touches glass shard
            if(touchingGlassShard && Math.random() < 0.3) {
              grid[y][x] = BLOOD;
              continue;
            }
            
            // Cell can slowly grow into empty spaces or consume edible elements
            if(Math.random() < 0.01) { // Very slow growth rate
              const directions = [
                [0, -1], [1, 0], [0, 1], [-1, 0] // Up, right, down, left
              ];
              
              // Shuffle directions for random growth
              for(let i = directions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [directions[i], directions[j]] = [directions[j], directions[i]];
              }
              
              for(const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  // Grow into empty space
                  if(grid[ny][nx] === EMPTY) {
                    grid[ny][nx] = CELL;
                    temp[ny][nx] = temp[y][x];
                    
                    // Initialize color variation for the new cell
                    const variation = 0.05;
                    colorVariations[ny][nx] = {
                      r: 1 + (Math.random() * variation * 2 - variation),
                      g: 1 + (Math.random() * variation * 2 - variation),
                      b: 1 + (Math.random() * variation * 2 - variation)
                    };
                    break;
                  }
                  
                  // Consume edible elements
                  if(grid[ny][nx] === WATER || 
                     grid[ny][nx] === MEAT || 
                     grid[ny][nx] === COOKED_MEAT || 
                     grid[ny][nx] === BIRD || 
                     grid[ny][nx] === BREAD) {
                    grid[ny][nx] = CELL;
                    temp[ny][nx] = temp[y][x];
                    
                    // Initialize color variation for the new cell
                    const variation = 0.05;
                    colorVariations[ny][nx] = {
                      r: 1 + (Math.random() * variation * 2 - variation),
                      g: 1 + (Math.random() * variation * 2 - variation),
                      b: 1 + (Math.random() * variation * 2 - variation)
                    };
                    break;
                  }
                }
              }
            }
          }
          
          // Blood behavior
          if(grid[y][x] === BLOOD) {
            // Blood can evaporate at high temperatures
            if(temp[y][x] > 100) {
              // Random chance to become oxygen, carbon dioxide, or water vapor
              const rand = Math.random();
              if(rand < 0.33) {
                grid[y][x] = OXYGEN;
              } else if(rand < 0.66) {
                grid[y][x] = CARBON_DIOXIDE;
              } else {
                grid[y][x] = WATER_VAPOR;
              }
            }
          }
          
          // Glass Shard behavior
          if(grid[y][x] === GLASS_SHARD) {
            // Glass shards can kill birds
            for(let dy = -1; dy <= 1; dy++) {
              for(let dx = -1; dx <= 1; dx++) {
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if(grid[ny][nx] === BIRD) {
                    grid[ny][nx] = MEAT;
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    function handleGlassShardCreation() {
      for(let y = 0; y < GRID_SIZE - 1; y++) {
        for(let x = 0; x < GRID_SIZE; x++) {
          if(grid[y][x] === COBBLESTONE && !moved[y][x]) {
            // Check if there's glass below the cobblestone
            if(y+1 < GRID_SIZE && grid[y+1][x] === GLASS) {
              // Play glass breaking sound
              playGlassBreakSound();
              
              // Break the glass into glass shards
              grid[y+1][x] = GLASS_SHARD;
              temp[y+1][x] = temp[y][x];
              
              // Create additional glass shards in adjacent empty cells
              let directions = [
                [1, 0], [-1, 0], [0, 1], [1, 1], [-1, 1]
              ];
              
              for(let [dx, dy] of directions) {
                let nx = x + dx, ny = y + 1 + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if(grid[ny][nx] === EMPTY && Math.random() < 0.4) {
                    grid[ny][nx] = GLASS_SHARD;
                    temp[ny][nx] = temp[y][x];
                  }
                }
              }
            }
          }
        }
      }
    }
    
    /*******************************************
     * New Transformation: Thermite
     *******************************************/
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of nb){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    /*******************************************
     * CUSTOM ELEMENTS SYSTEM
     *******************************************/
    
    // Custom element constants - start from a high number to avoid conflicts
    const CUSTOM_ELEMENT_START = 1000;
    let customElementCounter = CUSTOM_ELEMENT_START;
    
    // Storage for custom elements
    let customElements = {};
    let hasCustomElementsOnCanvas = false;
    
    // Load custom elements from localStorage
    function loadCustomElements() {
      try {
        const saved = localStorage.getItem('customElements');
        if (saved) {
          customElements = JSON.parse(saved);
          // Update counter to avoid ID conflicts
          const maxId = Math.max(...Object.keys(customElements).map(id => parseInt(id)), CUSTOM_ELEMENT_START - 1);
          customElementCounter = maxId + 1;
        }
      } catch (error) {
        console.error('Error loading custom elements:', error);
        customElements = {};
      }
    }
    
    // Save custom elements to localStorage
    function saveCustomElements() {
      try {
        localStorage.setItem('customElements', JSON.stringify(customElements));
      } catch (error) {
        console.error('Error saving custom elements:', error);
      }
    }
    
    // Check if any custom elements exist on the canvas
    function checkForCustomElementsOnCanvas() {
      hasCustomElementsOnCanvas = false;
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] >= CUSTOM_ELEMENT_START) {
            hasCustomElementsOnCanvas = true;
            return;
          }
        }
      }
    }
    
    // Create a new custom element
    function createCustomElement(properties) {
      const id = customElementCounter++;
      customElements[id] = {
        id: id,
        name: properties.name,
        color: properties.color,
        type: properties.type,
        density: properties.density,
        viscosity: properties.viscosity,
        meltingPoint: properties.meltingPoint,
        boilingPoint: properties.boilingPoint,
        conductivity: properties.conductivity,
        heatCapacity: properties.heatCapacity,
        flammable: properties.flammable,
        ignitionTemp: properties.ignitionTemp,
        fireResistance: properties.fireResistance,
        explosive: properties.explosive,
        explosionTemp: properties.explosionTemp,
        explosionRadius: properties.explosionRadius,
        explosionPower: properties.explosionPower,
        explosionType: properties.explosionType,
        conductive: properties.conductive,
        fireReactive: properties.fireReactive,
        corrosive: properties.corrosive,
        reactions: properties.reactions || [],
        createdAt: Date.now()
      };
      
      saveCustomElements();
      updateCustomElementsList();
      return id;
    }
    
    // Delete a custom element
    function deleteCustomElement(id) {
      if (customElements[id]) {
        delete customElements[id];
        saveCustomElements();
        updateCustomElementsList();
        
        // Remove any instances from the canvas
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            if (grid[y][x] === id) {
              eraseCell(x, y);
            }
          }
        }
        checkForCustomElementsOnCanvas();
      }
    }
    
    // Get custom element properties
    function getCustomElement(id) {
      return customElements[id] || null;
    }
    
    // Check if an ID is a custom element
    function isCustomElement(id) {
      return id >= CUSTOM_ELEMENT_START && customElements[id];
    }
    
    // Get element color for custom elements
    function getCustomElementColor(id) {
      const element = getCustomElement(id);
      return element ? element.color : '#ff0000';
    }
    
    // Get element name for custom elements
    function getCustomElementName(id) {
      const element = getCustomElement(id);
      return element ? element.name : 'Unknown';
    }
    
    // Update the custom elements list in the UI
    function updateCustomElementsList() {
      const container = document.getElementById('customElementsList');
      if (!container) return;
      
      // Clear existing elements (except create new button)
      const createNewBtn = document.getElementById('createNewCustomElement');
      container.innerHTML = '';
      
      // Add custom elements
      Object.values(customElements).forEach(element => {
        const item = document.createElement('div');
        item.className = 'custom-element-item';
        item.dataset.elementId = element.id;
        
        const preview = document.createElement('div');
        preview.className = 'custom-element-preview';
        preview.style.backgroundColor = element.color;
        
        const name = document.createElement('div');
        name.className = 'custom-element-name';
        name.textContent = element.name;
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'custom-element-delete';
        deleteBtn.innerHTML = 'Ã—';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm(`Delete custom element "${element.name}"?`)) {
            deleteCustomElement(element.id);
          }
        };
        
        item.appendChild(preview);
        item.appendChild(name);
        item.appendChild(deleteBtn);
        
        // Add click handler to select element
        item.onclick = () => {
          selectCustomElement(element.id);
        };
        
        container.appendChild(item);
      });
      
      // Re-add create new button
      container.appendChild(createNewBtn);
      
      // Re-attach the event handler since it was lost when cleared from DOM
      if (createNewBtn) {
        createNewBtn.onclick = () => {
          showCustomElementCreator();
        };
      }
    }
    
    // Select a custom element as the current tool
    function selectCustomElement(id) {
      // Deselect all other tools
      Array.from(toolElements).forEach(t => t.classList.remove('selected'));
      document.querySelectorAll('.custom-element-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      // Select this custom element
      const item = document.querySelector(`[data-element-id="${id}"]`);
      if (item) {
        item.classList.add('selected');
        currentTool = parseInt(id);
        
        // Update notification
        const element = getCustomElement(id);
        if (element) {
          updateSelectedElementNotificationCustom(element);
        }
      }
    }
    
    // Update notification for custom elements
    function updateSelectedElementNotificationCustom(element) {
      const notification = document.getElementById('selectedElementNotification');
      const colorDisplay = document.getElementById('selectedElementColor');
      const nameDisplay = document.getElementById('selectedElementName');
      
      if (notification && colorDisplay && nameDisplay) {
        colorDisplay.style.backgroundColor = element.color;
        nameDisplay.textContent = element.name;
        
        notification.classList.remove('visible');
        void notification.offsetWidth;
        notification.classList.add('visible');
        
        clearTimeout(notification.timeoutId);
        notification.timeoutId = setTimeout(() => {
          notification.classList.remove('visible');
        }, 3000);
      }
    }
    
    // Initialize custom elements system
    function initializeCustomElements() {
      loadCustomElements();
      updateCustomElementsList();
      
      // Set up range input listeners for real-time value updates
      const ranges = [
        { id: 'customElementDensity', valueId: 'densityValue' },
        { id: 'customElementViscosity', valueId: 'viscosityValue' },
        { id: 'customElementMeltingPoint', valueId: 'meltingPointValue' },
        { id: 'customElementBoilingPoint', valueId: 'boilingPointValue' },
        { id: 'customElementConductivity', valueId: 'conductivityValue' },
        { id: 'customElementHeatCapacity', valueId: 'heatCapacityValue' },
        { id: 'customElementIgnitionTemp', valueId: 'ignitionTempValue' },
        { id: 'customElementFireResistance', valueId: 'fireResistanceValue' },
        { id: 'customElementExplosionTemp', valueId: 'explosionTempValue' },
        { id: 'customElementExplosionRadius', valueId: 'explosionRadiusValue' },
        { id: 'customElementExplosionPower', valueId: 'explosionPowerValue' }
      ];
      
      ranges.forEach(range => {
        const input = document.getElementById(range.id);
        const display = document.getElementById(range.valueId);
        if (input && display) {
          input.addEventListener('input', () => {
            display.textContent = input.value;
          });
        }
      });
      
      // Set up conditional visibility for fire and explosion properties
      const flammableSelect = document.getElementById('customElementFlammable');
      const explosiveSelect = document.getElementById('customElementExplosive');
      
      if (flammableSelect) {
        flammableSelect.addEventListener('change', () => {
          const isFlammable = flammableSelect.value === 'true';
          const ignitionContainer = document.getElementById('ignitionTempContainer');
          const resistanceContainer = document.getElementById('fireResistanceContainer');
          if (ignitionContainer) ignitionContainer.style.display = isFlammable ? 'block' : 'none';
          if (resistanceContainer) resistanceContainer.style.display = isFlammable ? 'block' : 'none';
        });
        // Trigger initial state
        flammableSelect.dispatchEvent(new Event('change'));
      }
      
      if (explosiveSelect) {
        explosiveSelect.addEventListener('change', () => {
          const isExplosive = explosiveSelect.value === 'true';
          const containers = [
            'explosionTempContainer',
            'explosionRadiusContainer', 
            'explosionPowerContainer',
            'explosionTypeContainer'
          ];
          containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container) container.style.display = isExplosive ? 'block' : 'none';
          });
        });
        // Trigger initial state
        explosiveSelect.dispatchEvent(new Event('change'));
      }
      
      // Create new element button
      const createNewBtn = document.getElementById('createNewCustomElement');
      if (createNewBtn) {
        createNewBtn.onclick = () => {
          showCustomElementCreator();
        };
      }
      
      // Creator buttons
      const cancelBtn = document.getElementById('cancelCustomElement');
      const previewBtn = document.getElementById('previewCustomElement');
      const saveBtn = document.getElementById('saveCustomElement');
      
      if (cancelBtn) {
        cancelBtn.onclick = () => {
          hideCustomElementCreator();
        };
      }
      
      if (previewBtn) {
        previewBtn.onclick = () => {
          previewCustomElement();
        };
      }
      
      if (saveBtn) {
        saveBtn.onclick = () => {
          saveNewCustomElement();
        };
      }
      
      // Reaction system button
      const addReactionBtn = document.getElementById('add-reaction-btn');
      if (addReactionBtn) {
        addReactionBtn.onclick = () => {
          addReactionRow();
        };
      }
    }

    // Initialize custom elements when DOM is loaded
    document.addEventListener('DOMContentLoaded', initializeCustomElements);
    
    // Show the custom element creator
    function showCustomElementCreator() {
      const creator = document.getElementById('customElementCreator');
      if (creator) {
        creator.classList.add('active');
        
        // Reset form
        document.getElementById('customElementName').value = '';
        document.getElementById('customElementColor').value = '#ff6b6b';
        document.getElementById('customElementType').value = 'solid';
        
        // Reset ranges to default
        document.getElementById('customElementDensity').value = '1.0';
        document.getElementById('customElementViscosity').value = '1.0';
        document.getElementById('customElementMeltingPoint').value = '1000';
        document.getElementById('customElementBoilingPoint').value = '1500';
        document.getElementById('customElementConductivity').value = '0.5';
        document.getElementById('customElementHeatCapacity').value = '1.0';
        document.getElementById('customElementIgnitionTemp').value = '300';
        document.getElementById('customElementFireResistance').value = '0.0';
        document.getElementById('customElementExplosionTemp').value = '200';
        document.getElementById('customElementExplosionRadius').value = '3';
        document.getElementById('customElementExplosionPower').value = '0.4';
        
        // Update displays
        document.getElementById('densityValue').textContent = '1.0';
        document.getElementById('viscosityValue').textContent = '1.0';
        document.getElementById('meltingPointValue').textContent = '1000';
        document.getElementById('boilingPointValue').textContent = '1500';
        document.getElementById('conductivityValue').textContent = '0.5';
        document.getElementById('heatCapacityValue').textContent = '1.0';
        document.getElementById('ignitionTempValue').textContent = '300';
        document.getElementById('fireResistanceValue').textContent = '0.0';
        document.getElementById('explosionTempValue').textContent = '200';
        document.getElementById('explosionRadiusValue').textContent = '3';
        document.getElementById('explosionPowerValue').textContent = '0.4';
        
        // Reset selects to default
        document.getElementById('customElementFlammable').value = 'false';
        document.getElementById('customElementConductive').value = 'false';
        document.getElementById('customElementExplosive').value = 'false';
        document.getElementById('customElementExplosionType').value = 'fire';
        document.getElementById('customElementFireReactive').value = 'false';
        document.getElementById('customElementCorrosive').value = 'false';
        
        // Clear reactions
        clearReactionsList();
        
        // Trigger visibility updates
        document.getElementById('customElementFlammable').dispatchEvent(new Event('change'));
        document.getElementById('customElementExplosive').dispatchEvent(new Event('change'));
      }
    }
    
    // Hide the custom element creator
    function hideCustomElementCreator() {
      const creator = document.getElementById('customElementCreator');
      if (creator) {
        creator.classList.remove('active');
      }
    }
    
    // Preview the custom element (placeholder for future expansion)
    function previewCustomElement() {
      const properties = getCustomElementFormData();
      if (properties) {
        alert(`Preview: ${properties.name}\nType: ${properties.type}\nColor: ${properties.color}\nDensity: ${properties.density}`);
      }
    }
    
    // Save the new custom element
    function saveNewCustomElement() {
      const properties = getCustomElementFormData();
      if (properties) {
        const id = createCustomElement(properties);
        hideCustomElementCreator();
        
        // Auto-select the new element
        setTimeout(() => {
          selectCustomElement(id);
        }, 100);
      }
    }
    
    // Get form data for custom element creation
    function getCustomElementFormData() {
      const name = document.getElementById('customElementName').value.trim();
      const color = document.getElementById('customElementColor').value;
      
      if (!name) {
        alert('Please enter a name for your custom element!');
        return null;
      }
      
      if (name.length > 8) {
        alert('Element name must be 8 characters or less!');
        return null;
      }
      
      // Check for duplicate names
      const existingNames = Object.values(customElements).map(el => el.name.toLowerCase());
      if (existingNames.includes(name.toLowerCase())) {
        alert('An element with this name already exists!');
        return null;
      }
      
      return {
        name: name,
        color: color,
        type: document.getElementById('customElementType').value,
        density: parseFloat(document.getElementById('customElementDensity').value),
        viscosity: parseFloat(document.getElementById('customElementViscosity').value),
        meltingPoint: parseInt(document.getElementById('customElementMeltingPoint').value),
        boilingPoint: parseInt(document.getElementById('customElementBoilingPoint').value),
        conductivity: parseFloat(document.getElementById('customElementConductivity').value),
        heatCapacity: parseFloat(document.getElementById('customElementHeatCapacity').value),
        flammable: document.getElementById('customElementFlammable').value === 'true',
        ignitionTemp: parseInt(document.getElementById('customElementIgnitionTemp').value),
        fireResistance: parseFloat(document.getElementById('customElementFireResistance').value),
        explosive: document.getElementById('customElementExplosive').value === 'true',
        explosionTemp: parseInt(document.getElementById('customElementExplosionTemp').value),
        explosionRadius: parseInt(document.getElementById('customElementExplosionRadius').value),
        explosionPower: parseFloat(document.getElementById('customElementExplosionPower').value),
        explosionType: document.getElementById('customElementExplosionType').value,
        conductive: document.getElementById('customElementConductive').value === 'true',
        fireReactive: document.getElementById('customElementFireReactive').value === 'true',
        corrosive: document.getElementById('customElementCorrosive').value === 'true',
        reactions: getCustomReactions()
      };
    }
    
    // Reaction system functions
    function addReactionRow() {
      const reactionsList = document.getElementById('reactions-list');
      const reactionId = Date.now(); // Unique ID for this reaction
      
      const reactionDiv = document.createElement('div');
      reactionDiv.className = 'reaction-row';
      reactionDiv.style.cssText = 'display: flex; align-items: center; gap: 5px; margin-bottom: 5px; padding: 5px; border: 1px solid #555; border-radius: 3px; background: #2a2a2a; flex-wrap: wrap;';
      reactionDiv.setAttribute('data-reaction-id', reactionId);
      
      // Create elements step by step to avoid innerHTML issues
      const ifText = document.createElement('span');
      ifText.textContent = 'If touching';
      ifText.style.fontSize = '12px';
      ifText.style.whiteSpace = 'nowrap';
      
      const triggerSelect = document.createElement('select');
      triggerSelect.className = 'reaction-trigger';
      triggerSelect.style.cssText = 'flex: 1; min-width: 100px; max-width: 120px;';
      triggerSelect.innerHTML = getAllElementOptions();
      
      const becomeText = document.createElement('span');
      becomeText.textContent = 'become';
      becomeText.style.fontSize = '12px';
      becomeText.style.whiteSpace = 'nowrap';
      
      const resultSelect = document.createElement('select');
      resultSelect.className = 'reaction-result';
      resultSelect.style.cssText = 'flex: 1; min-width: 100px; max-width: 120px;';
      resultSelect.innerHTML = getAllElementOptions();
      
      const deleteLabel = document.createElement('label');
      deleteLabel.style.cssText = 'font-size: 12px; display: flex; align-items: center; gap: 2px; white-space: nowrap;';
      
      const deleteCheckbox = document.createElement('input');
      deleteCheckbox.type = 'checkbox';
      deleteCheckbox.className = 'reaction-delete-other';
      deleteCheckbox.style.margin = '0';
      
      const deleteText = document.createElement('span');
      deleteText.textContent = 'Delete other';
      
      deleteLabel.appendChild(deleteCheckbox);
      deleteLabel.appendChild(deleteText);
      
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = 'Ã—';
      removeBtn.style.cssText = 'padding: 2px 6px; background: #d32f2f; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 11px;';
      removeBtn.onclick = () => removeReactionRow(reactionId);
      
      const refreshBtn = document.createElement('button');
      refreshBtn.type = 'button';
      refreshBtn.textContent = 'â†»';
      refreshBtn.style.cssText = 'padding: 2px 6px; background: #4a7c59; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 11px;';
      refreshBtn.onclick = refreshElementDropdowns;
      
      // Append all elements
      reactionDiv.appendChild(ifText);
      reactionDiv.appendChild(triggerSelect);
      reactionDiv.appendChild(becomeText);
      reactionDiv.appendChild(resultSelect);
      reactionDiv.appendChild(deleteLabel);
      reactionDiv.appendChild(removeBtn);
      reactionDiv.appendChild(refreshBtn);
      
      reactionsList.appendChild(reactionDiv);
    }
    
    function removeReactionRow(reactionId) {
      const row = document.querySelector(`[data-reaction-id="${reactionId}"]`);
      if (row) {
        row.remove();
      }
    }
    
    function clearReactionsList() {
      const reactionsList = document.getElementById('reactions-list');
      if (reactionsList) {
        reactionsList.innerHTML = '';
      }
    }
    
    function getAllElementOptions() {
      let options = '<option value="">-- Select Element --</option>';
      
      // Built-in elements
      const builtInElements = {
        [EMPTY]: 'Empty',
        [SAND]: 'Sand',
        [WATER]: 'Water',
        [SNOW]: 'Snow',
        [WALL]: 'Wall',
        [STONE]: 'Stone',
        [LAVA]: 'Lava',
        [ICE]: 'Ice',
        [WATER_VAPOR]: 'Water Vapor',
        [CLOUD]: 'Cloud',
        [DENSE_CLOUD]: 'Dense Cloud',
        [DIRT]: 'Dirt',
        [WET_DIRT]: 'Wet Dirt',
        [GRASS]: 'Grass',
        [FIRE]: 'Fire',
        [SMOKE]: 'Smoke',
        [ASH]: 'Ash',
        [WOOD]: 'Wood',
        [SAWDUST]: 'Sawdust',
        [GLASS]: 'Glass',
        [GLASS_SHARD]: 'Glass Shard',
        [WHEAT_SEEDS]: 'Wheat Seeds',
        [FLOUR]: 'Flour',
        [DOUGH]: 'Dough',
        [BREAD]: 'Bread',
        [MEAT]: 'Meat',
        [COOKED_MEAT]: 'Cooked Meat',
        [PLANT]: 'Plant',
        [OAK_SEEDS]: 'Oak Seeds',
        [BIRCH_SEEDS]: 'Birch Seeds',
        [COPPER]: 'Copper',
        [OXIDIZED_COPPER]: 'Oxidized Copper',
        [SPARK]: 'Spark',
        [COOLER]: 'Cooler',
        [HEATER]: 'Heater',
        [HEAT_SEPARATOR]: 'Heat Separator',
        [INPUT]: 'Input',
        [OUTPUT]: 'Output',
        [CLONER]: 'Cloner',
        [OIL]: 'Oil',
        [ACID]: 'Acid',
        [SLIME]: 'Slime',
        [BLOOD]: 'Blood',
        [SALT_WATER]: 'Salt Water',
        [GLUE]: 'Glue',
        [SUGAR_WATER]: 'Sugar Water',
        [GAS]: 'Gas',
        [OXYGEN]: 'Oxygen',
        [CARBON_DIOXIDE]: 'Carbon Dioxide',
        [HELIUM]: 'Helium',
        [BOMB]: 'Bomb',
        [BIG_BOMB]: 'Big Bomb',
        [WATER_BOMB]: 'Water Bomb',
        [FIRE_BOMB]: 'Fire Bomb',
        [CRYO_BOMB]: 'Cryo Bomb',
        [NUKE_BOMB]: 'Nuke Bomb',
        [THERMITE]: 'Thermite',
        [STEEL]: 'Steel',
        [DIAMOND]: 'Diamond',
        [DIAMOND_SHARDS]: 'Diamond Shards',
        [CONFETTI]: 'Confetti',
        [DABICCO]: 'Dabicco',
        [COAL]: 'Coal',
        [COAL_LUMP]: 'Coal Lump',
        [COBBLESTONE]: 'Cobblestone',
        [SALT]: 'Salt',
        [SUGAR]: 'Sugar',
        [BIRD]: 'Bird',
        [CELL]: 'Cell',
        [BOUNCY_BALL]: 'Bouncy Ball',
        [INSULATOR]: 'Insulator',
        [PHOTON]: 'Photon',
        [LIGHTNING]: 'Lightning'
      };
      
      Object.entries(builtInElements).forEach(([id, name]) => {
        options += `<option value="${id}">${name}</option>`;
      });
      
      // Custom elements
      Object.entries(customElements).forEach(([id, element]) => {
        options += `<option value="${id}">${element.name} (Custom)</option>`;
      });
      
      return options;
    }
    
    function refreshElementDropdowns() {
      const newOptions = getAllElementOptions();
      document.querySelectorAll('.reaction-trigger, .reaction-result').forEach(select => {
        const currentValue = select.value;
        select.innerHTML = newOptions;
        select.value = currentValue; // Restore selection if still valid
      });
    }
    
    function getCustomReactions() {
      const reactions = [];
      const reactionRows = document.querySelectorAll('.reaction-row');
      
      reactionRows.forEach(row => {
        const trigger = row.querySelector('.reaction-trigger').value;
        const result = row.querySelector('.reaction-result').value;
        const deleteOther = row.querySelector('.reaction-delete-other').checked;
        
        if (trigger && result) {
          reactions.push({
            trigger: parseInt(trigger),
            result: parseInt(result),
            deleteOther: deleteOther
          });
        }
      });
      
             return reactions;
     }
     
    // Process custom element reactions in simulation
    function processCustomElementReactions() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const e = grid[y][x];
          
          // Check if this is a custom element with reactions
          if (e >= CUSTOM_ELEMENT_START && customElements[e] && customElements[e].reactions && customElements[e].reactions.length > 0) {
            const customElement = customElements[e];
            
            // Check all neighbors for reaction triggers
            const neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            
            for (let [dx, dy] of neighbors) {
              const nx = x + dx;
              const ny = y + dy;
              
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                const neighborElement = grid[ny][nx];
                
                // Check each reaction for this custom element
                for (let reaction of customElement.reactions) {
                  if (neighborElement === reaction.trigger) {
                    // Reaction triggered!
                    // Change this element to the result
                    grid[y][x] = reaction.result;
                    
                    // Preserve temperature if result is not empty
                    if (reaction.result !== EMPTY) {
                      temp[y][x] = temp[y][x] || 20; // Default temp if none
                    } else {
                      temp[y][x] = null; // Clear temp for empty
                    }
                    
                    // Delete the other element if specified
                    if (reaction.deleteOther) {
                      eraseCell(nx, ny);
                    }
                    
                    // Only apply the first matching reaction per frame
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
     
    /*******************************************
     * CATEGORY / SEARCH FILTERING
     *******************************************/
    categoryButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        categoryButtons.forEach(b => b.classList.remove('selectedCat'));
        btn.classList.add('selectedCat');
        activeCategory = btn.getAttribute('data-category');
        
        // Show/hide custom elements interface
        const customInterface = document.getElementById('customElementsInterface');
        const toolbar = document.getElementById('toolbar');
        
        if (activeCategory === 'custom') {
          if (customInterface) {
            customInterface.classList.add('active');
          }
          if (toolbar) {
            toolbar.style.display = 'none';
          }
        } else {
          if (customInterface) {
            customInterface.classList.remove('active');
          }
          if (toolbar) {
            toolbar.style.display = 'flex';
          }
          filterTools();
        }
      });
    });
    toolSearch.addEventListener('input', filterTools);
    function filterTools(){
      const searchVal = toolSearch.value.trim().toLowerCase();
      
      Array.from(toolElements).forEach(tool => {
        const toolName = tool.getAttribute('data-tool') || '';
        const cats = (tool.getAttribute('data-cat') || '').toLowerCase().split(',');
        
        // Tools only show in tools tab
        let inCat = (activeCategory === 'all' && !cats.includes('tools')) || cats.includes(activeCategory);
        let inSearch = !searchVal || toolName.toLowerCase().includes(searchVal);
        
        tool.style.display = (inCat && inSearch) ? 'flex' : 'none';
      });
      
      // Force canvas resize after filtering to ensure consistent pixel sizing
      if (window.resizeCanvas) {
        // Small delay to ensure DOM has updated
        setTimeout(() => {
          window.resizeCanvas();
        }, 10);
      }
    }
    filterTools();

    // Add acid and slime movement functions
    function moveAcid(x, y, oldT) {
      if (y+1 < GRID_SIZE && [EMPTY, WATER_VAPOR, CLOUD].includes(grid[y+1][x]) && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, ACID);
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, ACID);
            return;
          }
        }
        
        // Destroy adjacent non-cloner elements with updated behavior
        let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dx, dy] of neighbors) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== ACID && 
                grid[ny][nx] !== CLONER && grid[ny][nx] !== ACID_STEAM && 
                grid[ny][nx] !== ACID_CLOUD) {
              if (Math.random() < 0.1) {
                eraseCell(nx, ny);
                // 1/4 chance to delete itself when deleting another element
                if (Math.random() < 0.25) {
                  eraseCell(x, y);
            return;
          }
        }
      }
    }
        }
        
        // Evaporation
        if (temp[y][x] >= 100 && Math.random() < 0.1) {
          grid[y][x] = ACID_STEAM;
          temp[y][x] = 120;
        }
      }
    }

    function moveSlime(x, y, oldT) {
      if (Math.random() < 0.1) { // Very slow movement
        if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, SLIME);
        } else {
          let dirs = [];
          if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
          if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
          shuffle(dirs);
          for (let dir of dirs) {
            let nx = x + dir;
            if (grid[y][nx] === EMPTY && !moved[y][nx]) {
              moveCell(x, y, nx, y, oldT, SLIME);
              return;
            }
          }
        }
      }
    }

    // Movement function for Glue - sticky liquid that moves slowly
    function moveGlue(x, y, oldT) {
      // 50% chance to stay in place (very viscous)
      if (Math.random() < 0.5) {
        // Check if cells touching glue should be stuck
        let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dx, dy] of neighbors) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            // Elements that can be stuck by glue (except other glue and empty)
            if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== GLUE && 
                grid[ny][nx] !== CLONER && grid[ny][nx] !== STEEL && 
                grid[ny][nx] !== DIAMOND) {
              // Mark these cells as stuck so they don't move this frame
              moved[ny][nx] = true;
            }
          }
        }
        return;
      }
      
      // Movement behavior (similar to water but slower)
      if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, GLUE);
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, GLUE);
            return;
          }
        }
      }
    }

    // Movement function for Sugar - powder behavior like sand
    function moveSugar(x, y, oldT) {
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible
        if (grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, SUGAR);
          return;
        }
        
        // Otherwise try to fall diagonally
        let dirs = [];
        if (x > 0 && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y+1][nx] === EMPTY && !moved[y+1][nx]) {
            moveCell(x, y, nx, y+1, oldT, SUGAR);
            return;
          }
        }
      }
    }

    // Movement function for Sugar Water - similar to water but heavier (falls below water)
    function moveSugarWater(x, y, oldT) {
      // 30% chance to stay in place (slightly viscous)
      if (Math.random() < 0.3) return;
      
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible
        if (grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, SUGAR_WATER);
          return;
        }
        
        // Sugar water is heavier than water, so it falls below regular water
        if (grid[y+1][x] === WATER && !moved[y+1][x]) {
          // Swap positions (sugar water sinks below water)
          grid[y][x] = WATER;
          grid[y+1][x] = SUGAR_WATER;
          let tempT = temp[y][x];
          temp[y][x] = temp[y+1][x];
          temp[y+1][x] = tempT;
          moved[y][x] = true;
          moved[y+1][x] = true;
          return;
        }
        
        // But salt water is heavier than sugar water
        if (grid[y+1][x] === SALT_WATER && !moved[y+1][x]) {
          // Salt water stays below sugar water (don't swap)
          return;
        }
        
        // Otherwise try to spread horizontally
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, SUGAR_WATER);
            return;
          }
        }
      }
    }

    // Movement function for Diamond Shards - heavy powder
    function moveDiamondShards(x, y, oldT) {
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible
        if (grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, DIAMOND_SHARDS);
          return;
        }
        
        // Otherwise try to fall diagonally
        let dirs = [];
        if (x > 0 && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y+1][nx] === EMPTY && !moved[y+1][nx]) {
            moveCell(x, y, nx, y+1, oldT, DIAMOND_SHARDS);
            return;
          }
        }
      }
    }

    // Movement function for Molten Diamond - like lava but even hotter
    function moveMoltenDiamond(x, y, oldT){
      // Make molten diamond stay molten longer
      // This makes it cool down much slower than other molten materials
      if (temp[y][x] > 1000) {
        // Very slow cooling (10 times slower than normal)
        temp[y][x] -= 0.1 * simulationTimeStep;
      }
      
      // 50% chance to stay in place each frame (slow movement)
      if (Math.random() < 0.5) return;
      
      // Move like a liquid with 50% probability
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible
        if (grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, MOLTEN_DIAMOND);
          return;
        }
        
        // Otherwise spread horizontally
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, MOLTEN_DIAMOND);
            return;
          }
        }
        
        // Try diagonal movement
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y+1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, MOLTEN_DIAMOND);
            return;
          }
        }
      }
    }

    // Movement function for Molten Sugar - like a liquid with unique properties
    function moveMoltenSugar(x, y, oldT) {
      // Move like a viscous liquid (30% chance to stay in place)
      if (Math.random() < 0.3) return;
      
      // Move like a liquid
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible
        if (grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, MOLTEN_SUGAR);
          return;
        }
        
        // Otherwise spread horizontally
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, MOLTEN_SUGAR);
            return;
          }
        }
        
        // Try diagonal movement
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y+1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, MOLTEN_SUGAR);
            return;
          }
        }
      }
    }
    
    // Movement function for Confetti - light powder with some floating
    function moveConfetti(x, y, oldT) {
      // 20% chance to float upward
      if (Math.random() < 0.2 && y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]) {
        moveCell(x, y, x, y-1, oldT, CONFETTI);
        return;
      }
      
      // Otherwise, behave like a light powder
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible, but with 90% probability (sometimes floats)
        if (grid[y+1][x] === EMPTY && !moved[y+1][x] && Math.random() < 0.9) {
          moveCell(x, y, x, y+1, oldT, CONFETTI);
          return;
        }
        
        // Otherwise try to fall or drift diagonally
        let dirs = [];
        if (x > 0 && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y+1][nx] === EMPTY && !moved[y+1][nx]) {
            moveCell(x, y, nx, y+1, oldT, CONFETTI);
            return;
          }
        }
        
        // Occasionally move sideways
        if (Math.random() < 0.3) {
          dirs = [];
          if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
          if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
          shuffle(dirs);
          for (let dir of dirs) {
            let nx = x + dir;
            if (grid[y][nx] === EMPTY && !moved[y][nx]) {
              moveCell(x, y, nx, y, oldT, CONFETTI);
              return;
            }
          }
        }
      }
    }
    
    // Movement function for Dabicco - same as old Confetti (random colors that change)
    function moveDabicco(x, y, oldT) {
      // 20% chance to float upward
      if (Math.random() < 0.2 && y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]) {
        moveCell(x, y, x, y-1, oldT, DABICCO);
        return;
      }
      
      // Otherwise, behave like a light powder
      if (y+1 < GRID_SIZE) {
        // Fall straight down if possible, but with 90% probability (sometimes floats)
        if (grid[y+1][x] === EMPTY && !moved[y+1][x] && Math.random() < 0.9) {
          moveCell(x, y, x, y+1, oldT, DABICCO);
          return;
        }
        
        // Otherwise try to fall or drift diagonally
        let dirs = [];
        if (x > 0 && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y+1][nx] === EMPTY && !moved[y+1][nx]) {
            moveCell(x, y, nx, y+1, oldT, DABICCO);
            return;
          }
        }
        
        // Occasionally move sideways
        if (Math.random() < 0.3) {
          dirs = [];
          if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
          if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
          shuffle(dirs);
          for (let dir of dirs) {
            let nx = x + dir;
            if (grid[y][nx] === EMPTY && !moved[y][nx]) {
              moveCell(x, y, nx, y, oldT, DABICCO);
              return;
            }
          }
        }
      }
    }

    // Add to conductionRates
    conductionRates[ACID] = 0.8;
    conductionRates[ACID_STEAM] = 0.6;
    conductionRates[ACID_CLOUD] = 0.3;
    conductionRates[SLIME] = 0.4;
    conductionRates[GLUE] = 0.3;
    conductionRates[SUGAR] = 0.1;
    conductionRates[SUGAR_WATER] = 0.7;
    conductionRates[PLANT] = 0.4;
    conductionRates[DIAMOND] = 0.2;
    conductionRates[DIAMOND_SHARDS] = 0.15;
    conductionRates[MOLTEN_DIAMOND] = 0.9;
    conductionRates[CONFETTI] = 0.1;

    // Custom element movement functions
    function moveCustomLiquid(x, y, elementId, customElement) {
      const oldT = temp[y][x];
      
      // Check if we can fall down
      if (y + 1 < GRID_SIZE && !moved[y + 1][x]) {
        const below = grid[y + 1][x];
        
        if (below === EMPTY) {
          moveCell(x, y, x, y + 1, oldT, elementId);
          return;
        }
        
        // Handle density-based layering with other liquids
        if (below >= CUSTOM_ELEMENT_START && customElements[below]) {
          const belowElement = customElements[below];
          if (belowElement.type === 'liquid') {
            const densityDiff = customElement.density - belowElement.density;
            // More dramatic density effects - even small differences matter
            if (densityDiff > 0.1) { // Much smaller threshold
              // Swap positions - heavier liquid sinks below lighter one
              grid[y][x] = below;
              grid[y + 1][x] = elementId;
              let tempT = temp[y][x];
              temp[y][x] = temp[y + 1][x];
              temp[y + 1][x] = tempT;
              moved[y][x] = true;
              moved[y + 1][x] = true;
              return;
            }
          }
        }
        
        // Handle built-in liquids based on density (more sensitive to density differences)
        const waterDensity = 1.0;
        const oilDensity = 0.8;
        const saltWaterDensity = 1.025;
        const bloodDensity = 1.06;
        
        let canSinkBelow = false;
        let densityThreshold = 0.05; // Much smaller threshold for layering
        
        if (below === WATER && customElement.density > waterDensity + densityThreshold) canSinkBelow = true;
        if (below === OIL && customElement.density > oilDensity + densityThreshold) canSinkBelow = true;
        if (below === SALT_WATER && customElement.density > saltWaterDensity + densityThreshold) canSinkBelow = true;
        if (below === BLOOD && customElement.density > bloodDensity + densityThreshold) canSinkBelow = true;
        if (below === ACID && customElement.density > 1.8 + densityThreshold) canSinkBelow = true;
        if (below === SUGAR_WATER && customElement.density > 1.1 + densityThreshold) canSinkBelow = true;
        
        // Also allow floating on top of heavier liquids
        let canFloatAbove = false;
        if (below === WATER && customElement.density < waterDensity - densityThreshold) canFloatAbove = true;
        if (below === SALT_WATER && customElement.density < saltWaterDensity - densityThreshold) canFloatAbove = true;
        if (below === BLOOD && customElement.density < bloodDensity - densityThreshold) canFloatAbove = true;
        
        if (canSinkBelow || (canFloatAbove && Math.random() < 0.3)) {
          // Swap positions
          grid[y][x] = below;
          grid[y + 1][x] = elementId;
          let tempT = temp[y][x];
          temp[y][x] = temp[y + 1][x];
          temp[y + 1][x] = tempT;
          moved[y][x] = true;
          moved[y + 1][x] = true;
          return;
        }
      }
      
      // Try to spread horizontally
      let dirs = [];
      if (x > 0 && grid[y][x - 1] === EMPTY && !moved[y][x - 1]) dirs.push(-1);
      if (x < GRID_SIZE - 1 && grid[y][x + 1] === EMPTY && !moved[y][x + 1]) dirs.push(1);
      shuffle(dirs);
      
      for (let dir of dirs) {
        const nx = x + dir;
        if (grid[y][nx] === EMPTY && !moved[y][nx]) {
          moveCell(x, y, nx, y, oldT, elementId);
          return;
        }
      }
      
      // Try diagonal movement
      let diagonals = [];
      if (x > 0 && y + 1 < GRID_SIZE && grid[y + 1][x - 1] === EMPTY && !moved[y + 1][x - 1]) diagonals.push(-1);
      if (x < GRID_SIZE - 1 && y + 1 < GRID_SIZE && grid[y + 1][x + 1] === EMPTY && !moved[y + 1][x + 1]) diagonals.push(1);
      shuffle(diagonals);
      
      for (let dir of diagonals) {
        const nx = x + dir, ny = y + 1;
        if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
          moveCell(x, y, nx, ny, oldT, elementId);
          return;
        }
      }
    }

    function moveCustomPowder(x, y, elementId, customElement) {
      const oldT = temp[y][x];
      
      // Check if we can fall down
      if (y + 1 < GRID_SIZE && !moved[y + 1][x]) {
        const below = grid[y + 1][x];
        
        if (below === EMPTY) {
          moveCell(x, y, x, y + 1, oldT, elementId);
          return;
        }
        
        // Handle density-based interactions (much more sensitive)
        if (below >= CUSTOM_ELEMENT_START && customElements[below]) {
          const belowElement = customElements[below];
          const densityDiff = customElement.density - belowElement.density;
          
          // Powder can fall through lighter gases and liquids
          if (belowElement.type === 'gas' && densityDiff > 0.1) {
            moveCell(x, y, x, y + 1, oldT, elementId);
            return;
          }
          
          // Heavy powders can even displace lighter liquids
          if (belowElement.type === 'liquid' && densityDiff > 0.8) {
            // Swap positions - very heavy powder sinks through light liquid
            grid[y][x] = below;
            grid[y + 1][x] = elementId;
            let tempT = temp[y][x];
            temp[y][x] = temp[y + 1][x];
            temp[y + 1][x] = tempT;
            moved[y][x] = true;
            moved[y + 1][x] = true;
            return;
          }
        }
        
        // Built-in interactions (more comprehensive)
        let canFallThrough = false;
        
        // Gas interactions
        if (below === WATER_VAPOR || below === CLOUD || below === SMOKE || below === HELIUM) {
          canFallThrough = customElement.density > 0.2; // Almost all powders fall through gases
        }
        
        // Liquid interactions based on density  
        if (below === OIL && customElement.density > 1.0) canFallThrough = true; // Fall through oil if heavy enough
        if (below === WATER && customElement.density > 1.3) canFallThrough = true; // Very heavy powders fall through water
        if (below === ACID && customElement.density > 2.0) canFallThrough = true; // Only extremely heavy powders fall through acid
        
        if (canFallThrough) {
          moveCell(x, y, x, y + 1, oldT, elementId);
          return;
        }
      }
      
      // Try diagonal movement
      let diagonals = [];
      if (x > 0 && y + 1 < GRID_SIZE && grid[y + 1][x - 1] === EMPTY && !moved[y + 1][x - 1]) diagonals.push(-1);
      if (x < GRID_SIZE - 1 && y + 1 < GRID_SIZE && grid[y + 1][x + 1] === EMPTY && !moved[y + 1][x + 1]) diagonals.push(1);
      shuffle(diagonals);
      
      for (let dir of diagonals) {
        const nx = x + dir, ny = y + 1;
        if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
          moveCell(x, y, nx, ny, oldT, elementId);
          return;
        }
      }
    }

    function moveCustomGas(x, y, elementId, customElement) {
      const oldT = temp[y][x];
      
      // Gas behavior heavily affected by density
      const shouldFloat = customElement.density < 1.0;
      const shouldSink = customElement.density > 1.2; // Heavy gases sink
      
      if (shouldFloat && y > 0 && !moved[y - 1][x]) {
        const above = grid[y - 1][x];
        
        if (above === EMPTY) {
          moveCell(x, y, x, y - 1, oldT, elementId);
          return;
        }
        
        // Can rise through heavier gases and even some liquids if very light
        if (above >= CUSTOM_ELEMENT_START && customElements[above]) {
          const aboveElement = customElements[above];
          const densityDiff = aboveElement.density - customElement.density;
          
          if (aboveElement.type === 'gas' && densityDiff > 0.1) {
            // Swap positions - lighter gas rises
            grid[y][x] = above;
            grid[y - 1][x] = elementId;
            let tempT = temp[y][x];
            temp[y][x] = temp[y - 1][x];
            temp[y - 1][x] = tempT;
            moved[y][x] = true;
            moved[y - 1][x] = true;
            return;
          }
          
          // Very light gases can even bubble through liquids
          if (aboveElement.type === 'liquid' && customElement.density < 0.3) {
            grid[y][x] = above;
            grid[y - 1][x] = elementId;
            let tempT = temp[y][x];
            temp[y][x] = temp[y - 1][x];
            temp[y - 1][x] = tempT;
            moved[y][x] = true;
            moved[y - 1][x] = true;
            return;
          }
        }
        
        // Interactions with built-in elements
        if (customElement.density < 0.5) {
          // Very light gases rise through most things
          if (above === WATER_VAPOR || above === CLOUD || above === SMOKE || 
              above === OXYGEN || above === CARBON_DIOXIDE) {
            grid[y][x] = above;
            grid[y - 1][x] = elementId;
            let tempT = temp[y][x];
            temp[y][x] = temp[y - 1][x];
            temp[y - 1][x] = tempT;
            moved[y][x] = true;
            moved[y - 1][x] = true;
            return;
          }
        }
      }
      
      // Heavy gases sink like liquids
      if (shouldSink && y + 1 < GRID_SIZE && !moved[y + 1][x]) {
        const below = grid[y + 1][x];
        
        if (below === EMPTY) {
          moveCell(x, y, x, y + 1, oldT, elementId);
          return;
        }
        
        // Heavy gases can displace lighter gases
        if (below >= CUSTOM_ELEMENT_START && customElements[below]) {
          const belowElement = customElements[below];
          if (belowElement.type === 'gas' && customElement.density > belowElement.density + 0.1) {
            grid[y][x] = below;
            grid[y + 1][x] = elementId;
            let tempT = temp[y][x];
            temp[y][x] = temp[y + 1][x];
            temp[y + 1][x] = tempT;
            moved[y][x] = true;
            moved[y + 1][x] = true;
            return;
          }
        }
        
        // Heavy gases sink through lighter built-in gases
        if (below === WATER_VAPOR || below === HELIUM || below === OXYGEN) {
          grid[y][x] = below;
          grid[y + 1][x] = elementId;
          let tempT = temp[y][x];
          temp[y][x] = temp[y + 1][x];
          temp[y + 1][x] = tempT;
          moved[y][x] = true;
          moved[y + 1][x] = true;
          return;
        }
      }
      
      // Otherwise spread horizontally
      let dirs = [];
      if (x > 0 && grid[y][x - 1] === EMPTY && !moved[y][x - 1]) dirs.push(-1);
      if (x < GRID_SIZE - 1 && grid[y][x + 1] === EMPTY && !moved[y][x + 1]) dirs.push(1);
      shuffle(dirs);
      
      for (let dir of dirs) {
        const nx = x + dir;
        if (grid[y][nx] === EMPTY && !moved[y][nx]) {
          moveCell(x, y, nx, y, oldT, elementId);
          return;
        }
      }
    }
    conductionRates[OXIDIZED_COPPER] = 0.6;

    // Add to heatCapacities
    heatCapacities[ACID] = 1;
    heatCapacities[ACID_STEAM] = 0.5;
    heatCapacities[ACID_CLOUD] = 0.5;
    heatCapacities[SLIME] = 2;
    heatCapacities[GLUE] = 1.5;
    heatCapacities[SUGAR] = 0.6;
    heatCapacities[SUGAR_WATER] = 1.2;
    heatCapacities[PLANT] = 0.8;
    heatCapacities[DIAMOND] = 0.5;
    heatCapacities[DIAMOND_SHARDS] = 0.4;
    heatCapacities[MOLTEN_DIAMOND] = 2.5;
    heatCapacities[CONFETTI] = 0.3;
    heatCapacities[OXIDIZED_COPPER] = 0.9;

    function transformGrass() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === GRASS) {
            // Check temperature
            if (temp[y][x] >= 200) {
              grid[y][x] = BURNING_ORGANIC;
              temp[y][x] = fireTemperature;
              burningWoodTime[y][x] = 0;
            }
            // Check for nearby fire
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === FIRE || grid[ny][nx] === BURNING_ORGANIC) {
                  grid[y][x] = BURNING_ORGANIC;
                  temp[y][x] = fireTemperature;
                  burningWoodTime[y][x] = 0;
                  break;
                }
              }
            }
          }
        }
      }
    }
    
    // Sugar dissolves in water to create sugar water
    function transformSugarToSugarWater() {
      let cpy = grid.map(r => r.slice());
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === SUGAR) {
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === WATER) {
                  cpy[y][x] = SUGAR_WATER;
                  cpy[ny][nx] = EMPTY;
                  temp[y][x] = (temp[y][x] + temp[ny][nx]) / 2; // Average temperature
                  temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    
    // Sugar water evaporates leaving sugar behind and creating water vapor
    function transformSugarWater() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === SUGAR_WATER) {
            // Evaporation at high temperatures
            if (temp[y][x] >= 80 && Math.random() < 0.05) {
              // Leave sugar behind
              grid[y][x] = SUGAR;
              temp[y][x] = Math.max(temp[y][x] - 20, 20); // Cooling effect from evaporation
              
              // Try to create water vapor above if space is available
              const checkPositions = [[0, -1], [-1, -1], [1, -1]];
              for (let [dx, dy] of checkPositions) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY) {
                  grid[ny][nx] = WATER_VAPOR;
                  temp[ny][nx] = 100;
                  vaporLife[ny][nx] = 0;
                  markDirty(nx, ny);
                  break;
                }
              }
            }
          }
        }
      }
    }
    
    // Plant grows when in contact with water
    function transformPlant() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === PLANT) {
            // Actively search for water within a larger radius (up to 5 cells away)
            let waterFound = false;
            let waterDirection = null;
            
            // First, scan for water in a 5-cell radius
            for (let searchRadius = 1; searchRadius <= 5; searchRadius++) {
              for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                  // Skip if we're not on the edge of the search radius (only check the perimeter)
                  if (Math.abs(dx) !== searchRadius && Math.abs(dy) !== searchRadius) continue;
                  
                  let nx = x + dx, ny = y + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    if (grid[ny][nx] === WATER || grid[ny][nx] === SUGAR_WATER) {
                      // Found water! Store its direction relative to us
                      waterFound = true;
                      waterDirection = { dx: Math.sign(dx), dy: Math.sign(dy) };
                      break;
                    }
                  }
                }
                if (waterFound) break;
              }
              if (waterFound) break;
            }
            
            // If we found water, try to grow toward it
            if (waterFound && waterDirection) {
              // Higher chance to grow (20% chance)
              if (Math.random() < 0.2) {
                // Try to grow in the direction of the water
                let growX = x + waterDirection.dx;
                let growY = y + waterDirection.dy;
                
                // Check if the target cell is valid and empty
                if (growX >= 0 && growX < GRID_SIZE && growY >= 0 && growY < GRID_SIZE) {
                  if (grid[growY][growX] === EMPTY) {
                    grid[growY][growX] = PLANT;
                    temp[growY][growX] = temp[y][x];
                  }
                }
              }
            }
            
            // Also check for immediate neighbors to consume water (faster consumption)
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === WATER || grid[ny][nx] === SUGAR_WATER) {
                  // Faster consumption of water (10% chance per frame)
                  if (Math.random() < 0.1) {
                    grid[ny][nx] = EMPTY;
                    temp[ny][nx] = null;
                    
                    // Guaranteed growth after consuming water (50% chance)
                    if (Math.random() < 0.5) {
                      // Try to grow in empty spots
                      shuffle(neighbors);
                      for (let [gx, gy] of neighbors) {
                        let growX = x + gx, growY = y + gy;
                        if (growX >= 0 && growX < GRID_SIZE && growY >= 0 && growY < GRID_SIZE) {
                          if (grid[growY][growX] === EMPTY) {
                            grid[growY][growX] = PLANT;
                            temp[growY][growX] = temp[y][x];
                            break;
                          }
                        }
                      }
                    }
                    break;
                  }
                }
              }
            }
            
            // Burns at high temperature
            if (temp[y][x] >= 150) {
              grid[y][x] = FIRE;
              temp[y][x] = fireTemperature;
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
    
    // Diamond transformation (melting at extreme temperatures)
    function transformDiamond() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === DIAMOND) {
            // Melting diamond requires extreme heat (made easier to melt now)
            if (temp[y][x] >= 3000) {
              grid[y][x] = MOLTEN_DIAMOND;
              temp[y][x] = 3500;
              markDirty(x, y);
            }
            
            // Under extreme pressure (being surrounded by solid elements), can shatter
            let solidCount = 0;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                // Count surrounding solid elements that can exert pressure
                if (grid[ny][nx] === STEEL || grid[ny][nx] === STONE || grid[ny][nx] === BASALT) {
                  solidCount++;
                }
              }
            }
            
            // If surrounded on all sides and at high enough temperature
            if (solidCount >= 4 && temp[y][x] > 2000) {
              grid[y][x] = DIAMOND_SHARDS;
              temp[y][x] = Math.min(temp[y][x], 2500); // Shattering releases some heat
              markDirty(x, y);
            }
          }
          // Diamond shards can melt at lower temperature than whole diamonds
          else if (grid[y][x] === DIAMOND_SHARDS && temp[y][x] >= 2500) {
            grid[y][x] = MOLTEN_DIAMOND;
            temp[y][x] = 3000;
            markDirty(x, y);
          }
          // Molten diamond cools back to diamond
          else if (grid[y][x] === MOLTEN_DIAMOND && temp[y][x] < 2500) {
            grid[y][x] = DIAMOND;
            temp[y][x] = 2000;
            markDirty(x, y);
          }
        }
      }
    }
    
    // Confetti behavior - burns and creates festive colors
    function transformConfetti() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === CONFETTI) {
            // Burns easily
            if (temp[y][x] >= 80) {
              grid[y][x] = FIRE;
              temp[y][x] = fireTemperature;
              fireLife[y][x] = 0;
              
              // Create a colorful effect
              colorVariations[y][x] = {
                r: Math.random(),
                g: Math.random(),
                b: Math.random()
              };
            }
            
            // Check for nearby fire
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === FIRE) {
                  grid[y][x] = FIRE;
                  temp[y][x] = fireTemperature;
                  fireLife[y][x] = 0;
                  break;
                }
              }
            }
          }
        }
      }
    }
    
    // Oxidized Copper behavior
    // Create a reverse mapping of molten elements to their solid forms
    const coolingMap = {};
    coolingMap[MOLTEN_SALT] = SALT;
    coolingMap[MOLTEN_STEEL] = STEEL;
    coolingMap[MOLTEN_COPPER] = COPPER;
    coolingMap[MOLTEN_GLASS] = GLASS;
    coolingMap[MOLTEN_SUGAR] = SUGAR;
    coolingMap[MOLTEN_ELECTRICAL] = COPPER;
    coolingMap[MOLTEN_SLAG] = STONE;
    // Remove MOLTEN_DIAMOND from here since it's handled specifically in transformDiamond function

    // Function to handle cooling of all molten elements back to their solid forms
    function handleMoltenElementCooling() {
      // Define cooling temperatures for each molten element
      const coolingTemps = {};
      coolingTemps[MOLTEN_SALT] = saltMeltingTemp - 50;
      coolingTemps[MOLTEN_STEEL] = steelMeltingTemp - 100;
      coolingTemps[MOLTEN_COPPER] = copperMeltingTemp - 50;
      coolingTemps[MOLTEN_GLASS] = glassMeltingTemp - 100;
      coolingTemps[MOLTEN_SUGAR] = sugarMeltingTemp - 30;
      coolingTemps[MOLTEN_ELECTRICAL] = copperMeltingTemp - 50;
      coolingTemps[MOLTEN_SLAG] = stoneMeltingTemp - 100;
      // Remove MOLTEN_DIAMOND from here since it's handled specifically in transformDiamond function
      
      // Loop through the grid
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          const currentTemp = temp[y][x];
          
          // If this is a molten element and it's below its cooling temperature
          if (coolingMap[element] && currentTemp < coolingTemps[element]) {
            // Transform it back to its solid form
            grid[y][x] = coolingMap[element];
            temp[y][x] = coolingTemps[element] - 20; // Set temperature slightly below cooling point
            markDirty(x, y);
          }
        }
      }
    }

    // Unified function to handle all element melting transformations
    function handleElementMelting() {
      // Define melting temperatures for each element
      const meltingTemps = {};
      meltingTemps[SALT] = saltMeltingTemp;
      meltingTemps[STEEL] = steelMeltingTemp;
      meltingTemps[COPPER] = copperMeltingTemp;
      meltingTemps[DIAMOND] = diamondMeltingTemp;
      meltingTemps[GLASS] = glassMeltingTemp;
      meltingTemps[GLASS_SHARD] = glassMeltingTemp; // Glass shards melt at same temperature as glass
      meltingTemps[SUGAR] = sugarMeltingTemp;
      meltingTemps[STONE] = stoneMeltingTemp;
      meltingTemps[COBBLESTONE] = cobbleMeltingTemp;
      
      // Loop through the grid
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          const currentTemp = temp[y][x];
          
          // Check if this element is in our melting map
          if (element in meltingMap) {
            const meltTemp = meltingTemps[element];
            const moltenElement = meltingMap[element];
            
            // If temperature exceeds melting point, transform to molten version
            if (currentTemp >= meltTemp) {
              // Set cell to molten version with temperature slightly above melting point
              grid[y][x] = moltenElement;
              temp[y][x] = meltTemp + 20;
              
              // Mark for rendering
              markDirty(x, y);
            }
          }
          
          // Special case for cobblestone and stone that melt to slag instead of having their own molten versions
          if (element === COBBLESTONE && currentTemp >= cobbleMeltingTemp) {
            grid[y][x] = MOLTEN_SLAG;
            temp[y][x] = cobbleMeltingTemp + 100;
            markDirty(x, y);
          } else if (element === STONE && currentTemp >= stoneMeltingTemp) {
            grid[y][x] = MOLTEN_SLAG;
            temp[y][x] = stoneMeltingTemp + 100;
            markDirty(x, y);
          }
        }
      }
    }

function transformOxidizedCopper() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === OXIDIZED_COPPER) {
            // Can melt at high temperatures
            if (temp[y][x] >= copperMeltingTemp) {
              grid[y][x] = MOLTEN_COPPER;
              temp[y][x] = copperMeltingTemp + 15;
            }
          }
          // Copper oxidizes when in contact with water or oxygen over time
          // OR melts at high temperature
          else if (grid[y][x] === COPPER) {
            // Check if copper should melt
            if (temp[y][x] >= copperMeltingTemp) { // Using our constant for consistency
              grid[y][x] = MOLTEN_COPPER;
              temp[y][x] = copperMeltingTemp + 15;
              continue; // Skip oxidization check if we've melted the copper
            }
            
            // Check for oxidization
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            let shouldOxidize = false;
            
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === WATER || grid[ny][nx] === OXYGEN) {
                  // Small chance to oxidize when in contact with water or oxygen
                  if (Math.random() < 0.001) {
                    shouldOxidize = true;
                    break;
                  }
                }
              }
            }
            
            if (shouldOxidize) {
              grid[y][x] = OXIDIZED_COPPER;
              // Keep the same temperature
            }
          }
        }
      }
    }
    
    // HUD toggle functionality
    function updateHudVisibility() {
      const hud = document.getElementById('hud');
      const hudToggle = document.getElementById('hudToggle');
      if (hud && hudToggle) {
        const isVisible = hudToggle.value === '1';
        hud.style.display = isVisible ? 'block' : 'none';
        // Save preference
        localStorage.setItem('hudVisible', isVisible ? '1' : '0');
      }
    }

    // Initialize all event handlers after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize HUD visibility from saved preference
      const savedHudPreference = localStorage.getItem('hudVisible');
      const hudToggle = document.getElementById('hudToggle');
      const hud = document.getElementById('hud');
      
      if (hudToggle && hud) {
        // If there's a saved preference, use it; otherwise default to visible
        if (savedHudPreference !== null) {
          hudToggle.value = savedHudPreference;
          const isVisible = savedHudPreference === '1';
          hud.style.display = isVisible ? 'block' : 'none';
        } else {
          // Default to visible
          hudToggle.value = '1';
          hud.style.display = 'block';
        }
        
        hudToggle.addEventListener('change', updateHudVisibility);
      }
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });

      // Add downloadOfflineBtn event listener here
      const downloadOfflineBtn = document.getElementById('downloadOfflineBtn');
      if (downloadOfflineBtn) {
        downloadOfflineBtn.addEventListener('click', function() {
          const htmlContent = document.documentElement.outerHTML;
          const blob = new Blob([htmlContent], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'sandbox_game.html';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
      }
    });

    // Add to global variables
    let targetFps = 0;
    let popOutWindow = null;

    // Add event handlers
    const downloadOfflineBtn = document.getElementById('downloadOfflineBtn');
    if (downloadOfflineBtn) {
      downloadOfflineBtn.addEventListener('click', function() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sandbox_game.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
    }

    document.getElementById('dabyFps').addEventListener('change', function(e) {
      targetFps = parseInt(e.target.value);
    });

    document.getElementById('popOutMode').addEventListener('change', function(e) {
      if (parseInt(e.target.value) === 1) {
        if (!popOutWindow || popOutWindow.closed) {
          popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
          const popOutDoc = popOutWindow.document;
          
          // Create pop-out window content
          popOutDoc.write(`
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { margin: 0; background: #222; overflow: hidden; }
                #popOutGrid { width: 100%; height: 100%; }
              </style>
            </head>
            <body>
              <div id="popOutGrid"></div>
            </body>
            </html>
          `);
          
          // Move grid to pop-out window
          const originalGrid = document.getElementById('grid');
          popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
          
          // Handle window resize
          popOutWindow.addEventListener('resize', function() {
            const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
            originalGrid.style.width = size + 'px';
            originalGrid.style.height = size + 'px';
          });
          
          // Handle window close
          popOutWindow.addEventListener('unload', function() {
            if (!popOutWindow.closed) {
              document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
              originalGrid.style.width = '500px';
              originalGrid.style.height = '500px';
              document.getElementById('popOutMode').value = "0";
            }
          });
        }
      } else {
        if (popOutWindow && !popOutWindow.closed) {
          popOutWindow.close();
        }
      }
    });

    function moveBird(x, y, oldT) {
      if (moved[y][x]) return;
      
      birdTimers[y][x] += simulationTimeStep;
      
      // Change direction randomly
      if (birdTimers[y][x] >= 1.0) {
        if (Math.random() < 0.2) {
          birdDirections[y][x] *= -1;
        }
        if (Math.random() < 0.1) {
          birdYMovement[y][x] = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
        } else {
          birdYMovement[y][x] = 0;
        }
        birdTimers[y][x] = 0;
      }

      // Try to move in current direction
      let nx = x + birdDirections[y][x];
      let ny = y + birdYMovement[y][x];

      // Check boundaries and wrap around if needed
      if (nx < 0) nx = GRID_SIZE - 1;
      if (nx >= GRID_SIZE) nx = 0;
      if (ny < 0 || ny >= GRID_SIZE) {
        ny = y;
        birdYMovement[y][x] = 0;
      }

      // Check for oak leaves to eat
      let foundLeaves = false;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          let checkX = x + dx, checkY = y + dy;
          if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
            if (grid[checkY][checkX] === OAK_LEAVES || grid[checkY][checkX] === OAK_BABY_LEAVES) {
              eraseCell(checkX, checkY);
              foundLeaves = true;
            }
          }
        }
      }

      // Move if possible
      if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
        moveCell(x, y, nx, ny, oldT, BIRD);
        birdDirections[ny][nx] = birdDirections[y][x];
        birdTimers[ny][nx] = birdTimers[y][x];
        birdYMovement[ny][nx] = birdYMovement[y][x];
      }
    }

    function moveOil(x, y, oldT){
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, OIL);
      }
      else if(y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]){
        // Oil floats on water
        let tempWater = temp[y+1][x];
        grid[y+1][x] = OIL;
        temp[y+1][x] = oldT;
        grid[y][x] = WATER;
        temp[y][x] = tempWater;
        moved[y+1][x] = true;
      }
      else{
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let d of dirs){
          let nx = x + d, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, OIL);
            break;
          }
        }
      }
    }
    
    function moveBlood(x, y, oldT){
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, BLOOD);
      }
      else if(y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]){
        // Blood sinks below water
        let tempWater = temp[y+1][x];
        grid[y+1][x] = BLOOD;
        temp[y+1][x] = oldT;
        grid[y][x] = WATER;
        temp[y][x] = tempWater;
        moved[y+1][x] = true;
      }
      else if(y+1 < GRID_SIZE && grid[y+1][x] === SLIME && !moved[y+1][x]){
        // Blood floats on slime
        let tempSlime = temp[y+1][x];
        grid[y+1][x] = BLOOD;
        temp[y+1][x] = oldT;
        grid[y][x] = SLIME;
        temp[y][x] = tempSlime;
        moved[y+1][x] = true;
      }
      else{
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let d of dirs){
          let nx = x + d, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, BLOOD);
            break;
          }
        }
      }
    }

    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('auxclick', e => {
      if (e.button === 1) { // Middle click
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const element = grid[y][x];
        if (element === EMPTY) return;

        // Find the tool element for this element
        const tools = Array.from(toolElements);
        for (const tool of tools) {
          if (getToolElementId(tool.getAttribute('data-tool')) === element) {
            // Select the tool
            selectTool(tool);
            
            // Find its category
            const category = tool.getAttribute('data-cat');
            if (category) {
              // Select the category
              const categoryButtons = document.querySelectorAll('#categoryMenu button');
              categoryButtons.forEach(btn => {
                if (btn.getAttribute('data-category') === category) {
                  btn.click();
                  
                  // Wait for DOM update then scroll tool into view
                  setTimeout(() => {
                    tool.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }, 100);
                }
              });
            }
            break;
          }
        }
      }
    });

    // Helper function to get element ID from tool name
    function getToolElementId(toolName) {
      switch(toolName) {
        case "eraser": return ERASER;
        case "sand": return SAND;
        case "wall": return WALL;
        case "water": return WATER;
        case "lava": return LAVA;
        case "stone": return STONE;
        case "water-vapor": return WATER_VAPOR;
        case "copper": return COPPER;
        case "steel": return STEEL;
        case "ice": return ICE;
        case "wood": return WOOD;
        case "fire": return FIRE;
        case "smoke": return SMOKE;
        case "ash": return ASH;
        case "glass": return GLASS;
        case "bomb": return BOMB;
        case "dirt": return DIRT;
        case "wet-dirt": return WET_DIRT;
        case "wheat-seeds": return WHEAT_SEEDS;
        case "flour": return FLOUR;
        case "dough": return DOUGH;
        case "bread": return BREAD;
        case "plant-root": return ROOT;
        case "spark": return SPARK;
        case "oak-seeds": return OAK_SEEDS;
        case "grass": return GRASS;
        case "gas": return GAS;
        case "cooler": return COOLER;
        case "heater": return HEATER;
        case "heat-separator": return HEAT_SEPARATOR;
        case "input": return INPUT;
        case "output": return OUTPUT;
        case "not-gate": return NOT_GATE;
        case "and-gate": return AND_GATE;
        case "blocker": return BLOCKER;
        case "cloner": return CLONER;
        case "coal": return COAL;
        case "coal-lump": return COAL_LUMP;
        case "thermite": return THERMITE;
        case "acid": return ACID;
        case "slime": return SLIME;
        case "carbon-dioxide": return CARBON_DIOXIDE;
        case "oxygen": return OXYGEN;
        case "bird": return BIRD;
        case "meat": return MEAT;
        case "cooked-meat": return COOKED_MEAT;
        case "cobblestone": return COBBLESTONE;
        case "oil": return OIL;
        // Old example element removed
        case "big-bomb": return BIG_BOMB;
        case "water-bomb": return WATER_BOMB;
        case "fire-bomb": return FIRE_BOMB;
        case "cryo-bomb": return CRYO_BOMB;
        case "nuke-bomb": return NUKE_BOMB;
        case "salt": return SALT;
        case "salt-water": return SALT_WATER;
        default: return null;
      }
    }

    // Add touch support
    let lastTouchX = null;
    let lastTouchY = null;
    let touchStartTime = 0;
    let isTouchActive = false;

    gridContainer.addEventListener('touchstart', function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      lastTouchX = x;
      lastTouchY = y;
      hoveredX = x;
      hoveredY = y;
      touchStartTime = Date.now();
      isTouchActive = true;
      isLeftMouseDown = true;
      spamPlace();
      updateHoverOverlay();
    });

    gridContainer.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!isTouchActive) return;
      
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      
      // Only update if position changed
      if (x !== lastTouchX || y !== lastTouchY) {
        hoveredX = x;
        hoveredY = y;
        lastTouchX = x;
        lastTouchY = y;
        spamPlace();
        updateHoverOverlay();
        
        // Update HUD
        if (temp[y][x] !== null) {
          hudTemp.textContent = `Temp: ${temp[y][x].toFixed(1)} Â°C`;
          hudElem.textContent = `Element: ${getElementName(grid[y][x])}`;
        }
      }
    });

    gridContainer.addEventListener('touchend', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    gridContainer.addEventListener('touchcancel', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    // Update getMousePos to better handle touch events
    function getMousePos(e) {
      // Use the global cellSize to ensure consistency
      const cellSize = window.cellSize || gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let clientX = e.clientX || e.touches[0].clientX;
      let clientY = e.clientY || e.touches[0].clientY;
      let px = Math.floor((clientX - rect.left) / cellSize);
      let py = Math.floor((clientY - rect.top) / cellSize);
      return { 
        x: Math.max(0, Math.min(GRID_SIZE - 1, px)), 
        y: Math.max(0, Math.min(GRID_SIZE - 1, py)) 
      };
    }

    // Initialize dynamic lighting system
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // Add light-emitting properties for elements
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };

    // Add lighting calculation function
    function calculateLighting() {
      if (!window.isDynamicLightingEnabled) return;
      
      // Reset light levels
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          window.lightLevels[y][x] = 0;
          window.lightColors[y][x] = null;
        }
      }

      // Calculate light emission
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          const emitter = window.lightEmitters[element];
          
          if (emitter) {
            // Spread light in a radius
            const radius = Math.floor(emitter.intensity * 5);
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  if (distance <= radius) {
                    const intensity = (1 - distance / radius) * emitter.intensity;
                    window.lightLevels[ny][nx] = Math.max(window.lightLevels[ny][nx], intensity);
                    if (!window.lightColors[ny][nx]) window.lightColors[ny][nx] = emitter.color;
                    else {
                      // Mix colors based on intensity
                      const currentColor = window.lightColors[ny][nx];
                      const r1 = parseInt(currentColor.slice(1, 3), 16);
                      const g1 = parseInt(currentColor.slice(3, 5), 16);
                      const b1 = parseInt(currentColor.slice(5, 7), 16);
                      const r2 = parseInt(emitter.color.slice(1, 3), 16);
                      const g2 = parseInt(emitter.color.slice(3, 5), 16);
                      const b2 = parseInt(emitter.color.slice(5, 7), 16);
                      const mix = intensity / (window.lightLevels[ny][nx] + intensity);
                      const r = Math.round(r1 * (1 - mix) + r2 * mix);
                      const g = Math.round(g1 * (1 - mix) + g2 * mix);
                      const b = Math.round(b1 * (1 - mix) + b2 * mix);
                      window.lightColors[ny][nx] = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Modify renderCell to include lighting
    const originalRenderCell = window.renderCell;
    window.renderCell = function(x, y) {
      originalRenderCell(x, y);
      const cell = cells[y][x];
      
      if (window.isDynamicLightingEnabled && window.lightLevels[y][x] > 0) {
        cell.classList.add('lit');
        const element = grid[y][x];
        
        if (element === GLASS) {
          // Glass reflects nearby light with a slight tint
          const color = window.lightColors[y][x];
          const intensity = window.lightLevels[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = intensity * 0.3;
        } else if (element === EMPTY) {
          // Empty cells show light more prominently
          const color = window.lightColors[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = window.lightLevels[y][x] * 0.2;
        } else {
          // Other cells get a slight glow effect
          const lightColor = window.lightColors[y][x];
          if (lightColor) {
            cell.style.boxShadow = `0 0 ${window.lightLevels[y][x] * 10}px ${lightColor}`;
          }
        }
      } else {
        cell.classList.remove('lit');
        cell.style.boxShadow = '';
      }
    };

    // Add lighting calculation to game loop
    const originalGameLoop = window.gameLoop;
    window.gameLoop = function(timestamp) {
      if (window.isDynamicLightingEnabled) {
        calculateLighting();
      }
      originalGameLoop(timestamp);
    };

    // Initialize dynamic lighting toggle
    function initializeDynamicLighting() {
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.addEventListener('change', function(e) {
          window.isDynamicLightingEnabled = parseInt(e.target.value) === 1;
          alert('Dynamic Lighting ' + (window.isDynamicLightingEnabled ? 'Enabled' : 'Disabled')); // Immediate feedback
          
          if (!window.isDynamicLightingEnabled) {
            // Clear all lighting effects
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                const cell = cells[y][x];
                cell.classList.remove('lit');
                cell.style.boxShadow = '';
                if (grid[y][x] === EMPTY) {
                  cell.style.backgroundColor = '';
                  cell.style.opacity = '';
                }
              }
            }
          }
        });
      }
    }

    // Call initialization when document is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeDynamicLighting);
    } else {
      initializeDynamicLighting();
    }

    // Add to applyOptionsButton click handler
    document.getElementById('applyOptionsButton').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('stageSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        initGrid(newSize);
        // Only reinitialize lighting arrays if size changed
        window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      }
      optionsModal.style.display = 'none';
    });

    // Handle grid size change
    document.getElementById('applyGridSize').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('gridSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        GRID_SIZE = newSize;
        initGrid();
        
        // Reinitialize DSPLE if it's enabled
        if (window.isDspleEnabled) {
          // Clean up existing lighting engine
          cleanupDspleLightingEngine();
          // Reinitialize with new grid size
          initDspleLightingEngine();
        }
        
        renderGrid();
      }
    });

    // Community Feature Implementation
    const SERVER_URL = 'http://localhost:8700';
    let communityUserData = null;
    let loginAttempts = 0;
    let selectedLocalSave = null;
    let communitySaves = [];
    
    // Initialize Community elements after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize Community Modal
      const communityModal = document.getElementById('communityModal');
      const communityButton = document.getElementById('communityButton');
      const closeCommunityModal = document.getElementById('closeCommunityModal');
      
      if (!communityButton || !communityModal) {
        console.error('Community elements not found');
        return;
      }
      
      // Community sections
      const communityLoginSection = document.getElementById('communityLoginSection');
      const communityContent = document.getElementById('communityContent');
    
      // Login/Register elements
      const communityUsername = document.getElementById('communityUsername');
      const communityEmail = document.getElementById('communityEmail');
      const communityPassword = document.getElementById('communityPassword');
      const communityLoginBtn = document.getElementById('communityLoginBtn');
      const communityRegisterBtn = document.getElementById('communityRegisterBtn');
      const communityLoginMessage = document.getElementById('communityLoginMessage');
      
      // Community content tabs
      const communityTabBtns = document.querySelectorAll('.community-tab-btn');
      const communityTabContents = document.querySelectorAll('.community-tab-content');
      
      // Community saves list and filters
      const communitySavesList = document.getElementById('communitySavesList');
      const communitySortFilter = document.getElementById('communitySortFilter');
      const communitySearchFilter = document.getElementById('communitySearchFilter');
      
      // Upload section
      const communityLocalSavesList = document.getElementById('communityLocalSavesList');
      const communityUploadTitle = document.getElementById('communityUploadTitle');
      const communityUploadDescription = document.getElementById('communityUploadDescription');
      const communityUploadBtn = document.getElementById('communityUploadBtn');
      const communityUploadMessage = document.getElementById('communityUploadMessage');
    
    // Open Community Modal
      communityButton.addEventListener('click', function() {
        communityModal.style.display = 'block';
        
        // If user is logged in, load community saves
        if (communityUserData) {
          loadCommunitySaves();
          loadLocalSaves();
        }
      });
      
      // Close Community Modal
      closeCommunityModal.addEventListener('click', function() {
        communityModal.style.display = 'none';
      });
      
      // Tab switching
      communityTabBtns.forEach(btn => {
        btn.addEventListener('click', function() {
          const tabName = this.getAttribute('data-tab');
          
          // Update active tab button
          communityTabBtns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          
          // Show selected tab content
          communityTabContents.forEach(content => {
            content.classList.remove('active');
            if (content.id === tabName + 'CommunityTab') {
              content.classList.add('active');
            }
          });
          
          // Load data for the selected tab
          if (tabName === 'browse') {
            loadCommunitySaves();
          } else if (tabName === 'upload') {
            loadLocalSaves();
          }
        });
      });
      
      // Login functionality
      communityLoginBtn.addEventListener('click', function() {
      const username = communityUsername.value.trim();
      const email = communityEmail.value.trim();
      const password = communityPassword.value;
      
      if (!username || !email) {
        showLoginMessage('Please enter both username and email', 'error');
        return;
      }
      
      // Check login attempts
      if (loginAttempts >= 5) {
        showLoginMessage('Too many login attempts. Please try again later.', 'error');
        return;
      }
      
      loginAttempts++;
      
      // Simulate login for now (would be replaced with actual server call)
      loginUser(username, email, password)
        .then(response => {
          if (response.success) {
            communityUserData = response.userData;
            showLoginMessage('Login successful!', 'success');
            
            // Show community content
            communityLoginSection.style.display = 'none';
            communityContent.style.display = 'block';
            
            // Load community saves
            loadCommunitySaves();
          } else {
            showLoginMessage(response.message || 'Login failed. Please check your credentials.', 'error');
          }
        })
        .catch(error => {
          showLoginMessage('Error connecting to server. Please try again later.', 'error');
          console.error('Login error:', error);
        });
    });
    
    // Register functionality
    communityRegisterBtn.addEventListener('click', function() {
      const username = communityUsername.value.trim();
      const email = communityEmail.value.trim();
      const password = communityPassword.value;
      
      if (!username || !email) {
        showLoginMessage('Please enter both username and email', 'error');
        return;
      }
      
      // Simulate registration for now (would be replaced with actual server call)
      registerUser(username, email, password)
        .then(response => {
          if (response.success) {
            communityUserData = response.userData;
            showLoginMessage('Registration successful! You are now logged in.', 'success');
            
            // Show community content
            communityLoginSection.style.display = 'none';
            communityContent.style.display = 'block';
            
            // Load community saves
            loadCommunitySaves();
          } else {
            showLoginMessage(response.message || 'Registration failed. Please try again.', 'error');
          }
        })
        .catch(error => {
          showLoginMessage('Error connecting to server. Please try again later.', 'error');
          console.error('Registration error:', error);
        });
    });
    
    // Filter and sort community saves
    communitySortFilter.addEventListener('change', function() {
      filterAndSortCommunitySaves();
    });
    
    communitySearchFilter.addEventListener('input', function() {
      filterAndSortCommunitySaves();
    });
    
    // Upload save functionality
    communityUploadBtn.addEventListener('click', function() {
      const title = communityUploadTitle.value.trim();
      const description = communityUploadDescription.value.trim();
      
      if (!title) {
        communityUploadMessage.textContent = 'Please enter a title for your save';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      if (!selectedLocalSave) {
        communityUploadMessage.textContent = 'Please select a save to upload';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      // Get the save data
      const saveData = localStorage.getItem(selectedLocalSave);
      if (!saveData) {
        communityUploadMessage.textContent = 'Error retrieving save data';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      // Upload the save
      uploadSave(title, description, saveData)
        .then(response => {
          if (response.success) {
            communityUploadMessage.textContent = 'Save uploaded successfully!';
            communityUploadMessage.className = 'message success';
            
            // Clear form
            communityUploadTitle.value = '';
            communityUploadDescription.value = '';
            selectedLocalSave = null;
            
            // Update local saves list
            loadLocalSaves();
            
            // Switch to browse tab
            document.querySelector('.community-tab-btn[data-tab="browse"]').click();
          } else {
            communityUploadMessage.textContent = response.message || 'Upload failed. Please try again.';
            communityUploadMessage.className = 'message error';
          }
        })
        .catch(error => {
          communityUploadMessage.textContent = 'Error connecting to server. Please try again later.';
          communityUploadMessage.className = 'message error';
          console.error('Upload error:', error);
        });
    });
    
    // Helper Functions
    
    // Community saves functionality
    function updateCommunitySavesList() {
      const container = document.getElementById('communitySavesList');
      container.innerHTML = '<div class="loading">Loading community saves...</div>';
      
      // Fetch the list of community saves from the ./communitysaves directory
      fetchCommunitySaves()
        .then(saves => {
          container.innerHTML = '';
          
          if (saves.length === 0) {
            container.innerHTML = '<div class="no-saves">No community saves found.</div>';
            return;
          }
          
          // Sort saves by date (newest first)
          saves.sort((a, b) => b.timestamp - a.timestamp);
          
          // Create a card for each community save
          saves.forEach(save => {
            // Create a card for each saved game
            const card = document.createElement('div');
            card.className = 'save-game-card';
            
            // Create the preview section
            const previewContainer = document.createElement('div');
            previewContainer.className = 'save-preview';
            
            // Create the actual preview grid
            const previewGrid = document.createElement('div');
            previewGrid.className = 'preview-grid';
            
            // Try to load the save data to create a preview
            try {
              // Parse the save data
              const saveData = save.saveData;
              const previewSize = 10; // Small preview grid
              
              // Create a miniature grid for preview
              for (let y = 0; y < previewSize; y++) {
                for (let x = 0; x < previewSize; x++) {
                  const cell = document.createElement('div');
                  cell.className = 'preview-cell';
                  
                  // Sample from the actual grid to create preview
                  const gridX = Math.floor(x * (saveData.GRID_SIZE / previewSize));
                  const gridY = Math.floor(y * (saveData.GRID_SIZE / previewSize));
                  
                  if (saveData.grid && saveData.grid[gridY] && saveData.grid[gridY][gridX] !== undefined) {
                    const element = saveData.grid[gridY][gridX];
                    if (element !== 0) { // Not empty
                      // Get the class name for this element
                      const elementClass = getElementClass(element);
                      if (elementClass) {
                        cell.classList.add(elementClass);
                      }
                    }
                  }
                  
                  previewGrid.appendChild(cell);
                }
              }
              
              previewContainer.appendChild(previewGrid);
            } catch (err) {
              console.error('Error creating preview:', err);
              previewContainer.innerHTML = '<div class="preview-error">Preview not available</div>';
            }
            
            // Create the info section
            const infoContainer = document.createElement('div');
            infoContainer.className = 'save-info';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'save-title';
            title.textContent = save.title || 'Untitled Save';
            infoContainer.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'save-description';
            description.textContent = save.description || 'No description';
            infoContainer.appendChild(description);
            
            // Add metadata (publisher and date)
            const metadata = document.createElement('div');
            metadata.className = 'save-metadata';
            
            // Add publisher
            const publisher = document.createElement('div');
            publisher.className = 'save-publisher';
            publisher.textContent = `Publisher: ${save.publisher || 'Unknown'}`;
            metadata.appendChild(publisher);
            
            // Add date
            const date = document.createElement('div');
            date.className = 'save-date';
            date.textContent = `Date: ${new Date(save.timestamp).toLocaleDateString()}`;
            metadata.appendChild(date);
            
            // Add file size
            const size = document.createElement('div');
            size.className = 'save-size';
            size.textContent = `Size: ${formatFileSize(save.size)}`;
            metadata.appendChild(size);
            
            infoContainer.appendChild(metadata);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.className = 'load-save-button';
            loadButton.textContent = 'Load';
            loadButton.addEventListener('click', function() {
              loadCommunitySave(save.filename);
              communityModal.style.display = 'none';
            });
            infoContainer.appendChild(loadButton);
            
            // Assemble the card
            card.appendChild(previewContainer);
            card.appendChild(infoContainer);
            
            // Add the card to the container
            container.appendChild(card);
          });
        })
        .catch(error => {
          console.error('Error loading community saves:', error);
          container.innerHTML = `<div class="error">Error loading community saves: ${error.message}</div>`;
        });
    }
    
    // Function to fetch community saves from the ./communitysaves directory
    window.fetchCommunitySaves = async function() {
      // In a real implementation, this would fetch from the server or local directory
      // For now, we'll simulate reading from a directory
      
      try {
        // Simulate reading from the ./communitysaves directory
        // In a real implementation, this would use fetch or another method to get the files
        const response = await fetch('./communitysaves/index.json');
        
        // If the directory doesn't exist or there's an error, return an empty array
        if (!response.ok) {
          return [];
        }
        
        // Parse the index file that contains metadata about all community saves
        const index = await response.json();
        
        // For each save in the index, fetch the actual save data
        const saves = await Promise.all(index.map(async (save) => {
          try {
            const saveResponse = await fetch(`./communitysaves/${save.filename}`);
            if (!saveResponse.ok) {
              throw new Error(`Failed to load save: ${save.filename}`);
            }
            
            const saveData = await saveResponse.json();
            
            return {
              ...save,
              saveData
            };
          } catch (error) {
            console.error(`Error loading save ${save.filename}:`, error);
            return save; // Return just the metadata if we can't load the save data
          }
        }));
        
        return saves;
      } catch (error) {
        console.error('Error fetching community saves:', error);
        
        // For demo purposes, return some sample saves if we can't fetch the real ones
        return getSampleCommunitySaves();
      }
    }
    
    // Function to load a community save
    window.loadCommunitySave = function(filename) {
      // In a real implementation, this would fetch the save file from the server or local directory
      // For now, we'll simulate loading from a file
      
      fetch(`./communitysaves/${filename}`)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to load save: ${filename}`);
          }
          return response.json();
        })
        .then(save => {
          // Load the save data into the game
          loadSaveData(save);
        })
        .catch(error => {
          console.error('Error loading community save:', error);
          alert(`Error loading community save: ${error.message}`);
          
          // For demo purposes, load a sample save if we can't load the real one
          const sampleSaves = getSampleCommunitySaves();
          if (sampleSaves.length > 0) {
            loadSaveData(sampleSaves[0].saveData);
          }
        });
    }
    
    // Function to update the community saves list in the UI
    window.updateCommunitySavesList = function() {
      const container = document.getElementById('communitySavesList');
      container.innerHTML = '<div class="loading">Loading community saves...</div>';
      
      // Fetch the list of community saves from the ./communitysaves directory
      fetchCommunitySaves()
        .then(saves => {
          container.innerHTML = '';
          
          if (saves.length === 0) {
            container.innerHTML = '<div class="no-saves">No community saves found.</div>';
            return;
          }
          
          // Sort saves by date (newest first)
          saves.sort((a, b) => b.timestamp - a.timestamp);
          
          // Create a card for each community save
          saves.forEach(save => {
            // Create a card for each saved game
            const card = document.createElement('div');
            card.className = 'save-game-card';
            
            // Create the preview section
            const previewContainer = document.createElement('div');
            previewContainer.className = 'save-preview';
            
            // Create the actual preview grid
            const previewGrid = document.createElement('div');
            previewGrid.className = 'preview-grid';
            
            // Try to load the save data to create a preview
            try {
              // Parse the save data
              const saveData = save.saveData;
              const previewSize = 10; // Small preview grid
              
              // Create a miniature grid for preview
              for (let y = 0; y < previewSize; y++) {
                for (let x = 0; x < previewSize; x++) {
                  const cell = document.createElement('div');
                  cell.className = 'preview-cell';
                  
                  // Sample from the actual grid to create preview
                  const gridX = Math.floor(x * (saveData.GRID_SIZE / previewSize));
                  const gridY = Math.floor(y * (saveData.GRID_SIZE / previewSize));
                  
                  if (saveData.grid && saveData.grid[gridY] && saveData.grid[gridY][gridX] !== undefined) {
                    const element = saveData.grid[gridY][gridX];
                    if (element !== 0) { // Not empty
                      // Get the class name for this element
                      const elementClass = getElementClass(element);
                      if (elementClass) {
                        cell.classList.add(elementClass);
                      }
                    }
                  }
                  
                  previewGrid.appendChild(cell);
                }
              }
              
              previewContainer.appendChild(previewGrid);
            } catch (err) {
              console.error('Error creating preview:', err);
              previewContainer.innerHTML = '<div class="preview-error">Preview not available</div>';
            }
            
            // Create the info section
            const infoContainer = document.createElement('div');
            infoContainer.className = 'save-info';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'save-title';
            title.textContent = save.title || 'Untitled Save';
            infoContainer.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'save-description';
            description.textContent = save.description || 'No description';
            infoContainer.appendChild(description);
            
            // Add metadata (publisher and date)
            const metadata = document.createElement('div');
            metadata.className = 'save-metadata';
            
            // Add publisher
            const publisher = document.createElement('div');
            publisher.className = 'save-publisher';
            publisher.textContent = `Publisher: ${save.publisher || 'Unknown'}`;
            metadata.appendChild(publisher);
            
            // Add date
            const date = document.createElement('div');
            date.className = 'save-date';
            date.textContent = `Date: ${new Date(save.timestamp).toLocaleDateString()}`;
            metadata.appendChild(date);
            
            // Add file size
            const size = document.createElement('div');
            size.className = 'save-size';
            size.textContent = `Size: ${formatFileSize(save.size)}`;
            metadata.appendChild(size);
            
            infoContainer.appendChild(metadata);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.className = 'load-save-button';
            loadButton.textContent = 'Load';
            loadButton.addEventListener('click', function() {
              loadCommunitySave(save.filename);
              communityModal.style.display = 'none';
            });
            infoContainer.appendChild(loadButton);
            
            // Assemble the card
            card.appendChild(previewContainer);
            card.appendChild(infoContainer);
            
            // Add the card to the container
            container.appendChild(card);
          });
        })
        .catch(error => {
          console.error('Error loading community saves:', error);
          container.innerHTML = `<div class="error">Error loading community saves: ${error.message}</div>`;
        });
    }
    
    // Helper function to format file size
    function formatFileSize(bytes) {
      if (bytes < 1024) {
        return bytes + ' B';
      } else if (bytes < 1024 * 1024) {
        return (bytes / 1024).toFixed(1) + ' KB';
      } else {
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }
    }
    
    // Helper function to get sample community saves for demo purposes
    window.getSampleCommunitySaves = function() {
      // Create some sample saves for demonstration
      return [
        {
          filename: 'sample1.dbr',
          title: 'Desert Oasis',
          description: 'A beautiful desert oasis with water and plants',
          publisher: 'SandboxMaster',
          timestamp: Date.now() - 86400000 * 3, // 3 days ago
          size: 15240,
          saveData: createSampleSaveData(50, 'desert')
        },
        {
          filename: 'sample2.dbr',
          title: 'Volcano Eruption',
          description: 'Watch out for the lava!',
          publisher: 'LavaLover',
          timestamp: Date.now() - 86400000 * 7, // 7 days ago
          size: 18360,
          saveData: createSampleSaveData(50, 'volcano')
        },
        {
          filename: 'sample3.dbr',
          title: 'Underwater City',
          description: 'A city built entirely underwater',
          publisher: 'NeptuneKing',
          timestamp: Date.now() - 86400000 * 14, // 14 days ago
          size: 22480,
          saveData: createSampleSaveData(50, 'underwater')
        }
      ];
    }
    
    // Helper function to create sample save data for demo purposes
    window.createSampleSaveData = function(size, theme) {
      // Create a basic grid with the specified theme
      const grid = Array(size).fill().map(() => Array(size).fill(0));
      const temp = Array(size).fill().map(() => Array(size).fill(20));
      const colorVariations = Array(size).fill().map(() => Array(size).fill(null));
      
      // Fill the grid based on the theme
      if (theme === 'desert') {
        // Create a desert landscape with sand and a small oasis
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (y > size / 2) {
              grid[y][x] = 4; // Sand
              temp[y][x] = 30; // Hot temperature
            }
          }
        }
        
        // Add an oasis in the center
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        const oasisRadius = Math.floor(size / 10);
        
        for (let y = centerY - oasisRadius; y <= centerY + oasisRadius; y++) {
          for (let x = centerX - oasisRadius; x <= centerX + oasisRadius; x++) {
            if (y >= 0 && y < size && x >= 0 && x < size) {
              const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
              if (distance < oasisRadius) {
                grid[y][x] = 2; // Water
                temp[y][x] = 20; // Normal temperature
              }
            }
          }
        }
      } else if (theme === 'volcano') {
        // Create a volcano landscape with stone and lava
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (y > size / 2) {
              grid[y][x] = 5; // Stone
              temp[y][x] = 20; // Normal temperature
            }
          }
        }
        
        // Add a volcano in the center
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        const volcanoRadius = Math.floor(size / 8);
        
        for (let y = centerY - volcanoRadius; y <= centerY + volcanoRadius; y++) {
          for (let x = centerX - volcanoRadius; x <= centerX + volcanoRadius; x++) {
            if (y >= 0 && y < size && x >= 0 && x < size) {
              const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
              if (distance < volcanoRadius) {
                grid[y][x] = 3; // Lava
                temp[y][x] = 1200; // Very hot temperature
              }
            }
          }
        }
      } else if (theme === 'underwater') {
        // Create an underwater landscape with water and some structures
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            grid[y][x] = 2; // Water
            temp[y][x] = 10; // Cold temperature
          }
        }
        
        // Add some underwater structures
        for (let i = 0; i < 5; i++) {
          const structX = Math.floor(Math.random() * size);
          const structY = Math.floor(Math.random() * size);
          const structSize = Math.floor(Math.random() * 5) + 3;
          
          for (let y = structY - structSize; y <= structY + structSize; y++) {
            for (let x = structX - structSize; x <= structX + structSize; x++) {
              if (y >= 0 && y < size && x >= 0 && x < size) {
                const distance = Math.sqrt(Math.pow(x - structX, 2) + Math.pow(y - structY, 2));
                if (distance < structSize) {
                  grid[y][x] = 5; // Stone
                  temp[y][x] = 10; // Cold temperature
                }
              }
            }
          }
        }
      }
      
      // Return the sample save data
      return {
        GRID_SIZE: size,
        grid,
        temp,
        colorVariations,
        // Add other necessary properties with default values
        vaporLife: Array(size).fill().map(() => Array(size).fill(0)),
        cloudLife: Array(size).fill().map(() => Array(size).fill(0)),
        fireLife: Array(size).fill().map(() => Array(size).fill(0)),
        smokeLife: Array(size).fill().map(() => Array(size).fill(0)),
        burningWoodTime: Array(size).fill().map(() => Array(size).fill(0)),
        wheatHeight: Array(size).fill().map(() => Array(size).fill(0)),
        wheatMaxHeight: Array(size).fill().map(() => Array(size).fill(3)),
        seedGrowthTime: Array(size).fill().map(() => Array(size).fill(0)),
        rootLife: Array(size).fill().map(() => Array(size).fill(0)),
        sparkLife: Array(size).fill().map(() => Array(size).fill(0)),
        sparkTimer: Array(size).fill().map(() => Array(size).fill(0)),
        smokeMaxLife: Array(size).fill().map(() => Array(size).fill(30)),
        cloudMaxLife: Array(size).fill().map(() => Array(size).fill(100)),
        branchLevel: Array(size).fill().map(() => Array(size).fill(0)),
        branchLen: Array(size).fill().map(() => Array(size).fill(0)),
        branchMaxArr: Array(size).fill().map(() => Array(size).fill(0)),
        branchSubCount: Array(size).fill().map(() => Array(size).fill(0)),
        branchDirX: Array(size).fill().map(() => Array(size).fill(0)),
        branchDirY: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeGrowthTime: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeHeight: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeMaxHeight: Array(size).fill().map(() => Array(size).fill(10)),
        oakTreeRootTimer: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeRootDepth: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeRootMax: Array(size).fill().map(() => Array(size).fill(5)),
        grassStage: Array(size).fill().map(() => Array(size).fill(0)),
        burningGasTime: Array(size).fill().map(() => Array(size).fill(0)),
        chargedStateTime: Array(size).fill().map(() => Array(size).fill(0))
      };
    }
    
    // Show login message
    function showLoginMessage(message, type) {
      communityLoginMessage.textContent = message;
      communityLoginMessage.className = 'message ' + type;
    }
    
    // Login user
    async function loginUser(username, email, password) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful login if username and email are provided
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // For demo purposes, always succeed if both username and email are provided
        if (username && email) {
          return {
            success: true,
            userData: {
              username,
              email,
              id: 'user_' + Date.now()
            }
          };
        } else {
          return {
            success: false,
            message: 'Invalid username or email'
          };
        }
      } catch (error) {
        console.error('Login error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Register user
    async function registerUser(username, email, password) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful registration
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // For demo purposes, always succeed if both username and email are provided
        if (username && email) {
          return {
            success: true,
            userData: {
              username,
              email,
              id: 'user_' + Date.now()
            }
          };
        } else {
          return {
            success: false,
            message: 'Invalid username or email'
          };
        }
      } catch (error) {
        console.error('Registration error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Load community saves
    async function loadCommunitySaves() {
      // Show loading state
      communitySavesList.innerHTML = '<div class="community-loading">Loading community saves...</div>';
      
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate loading community saves
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Generate some sample community saves
        communitySaves = [
          {
            id: 'save1',
            title: 'Amazing Volcano',
            description: 'A huge volcano with lava flowing down into a water lake, creating steam and obsidian.',
            author: 'LavaLover42',
            date: '2025-05-01',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save2',
            title: 'Working Computer',
            description: 'A functional 4-bit computer built using the logic gates. Can perform basic arithmetic!',
            author: 'DigitalGenius',
            date: '2025-04-28',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save3',
            title: 'Ecosystem Simulation',
            description: 'A balanced ecosystem with plants, water cycle, and birds. Can run for hours without intervention!',
            author: 'NatureNerd',
            date: '2025-05-08',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save4',
            title: 'Rube Goldberg Machine',
            description: 'An elaborate chain reaction using sand, water, and explosives. Very satisfying to watch!',
            author: 'MechanicalMaster',
            date: '2025-05-05',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save5',
            title: 'Fireworks Display',
            description: 'A timed sequence of different colored explosions. Perfect for celebrations!',
            author: 'PyroTechnician',
            date: '2025-04-15',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          }
        ];
        
        // Display the saves
        filterAndSortCommunitySaves();
        
        return true;
      } catch (error) {
        console.error('Error loading community saves:', error);
        communitySavesList.innerHTML = '<div class="community-loading">Error loading saves. Please try again later.</div>';
        return false;
      }
    }
    
    // Filter and sort community saves
    function filterAndSortCommunitySaves() {
      const searchTerm = communitySearchFilter.value.toLowerCase();
      const sortOption = communitySortFilter.value;
      
      // Filter saves based on search term
      let filteredSaves = communitySaves.filter(save => {
        return save.title.toLowerCase().includes(searchTerm) || 
               save.author.toLowerCase().includes(searchTerm) || 
               save.description.toLowerCase().includes(searchTerm);
      });
      
      // Sort saves based on selected option
      if (sortOption === 'newest') {
        filteredSaves.sort((a, b) => new Date(b.date) - new Date(a.date));
      } else if (sortOption === 'oldest') {
        filteredSaves.sort((a, b) => new Date(a.date) - new Date(b.date));
      } else if (sortOption === 'name') {
        filteredSaves.sort((a, b) => a.title.localeCompare(b.title));
      }
      
      // Display the filtered and sorted saves
      displayCommunitySaves(filteredSaves);
    }
    
    // Display community saves
    function displayCommunitySaves(saves) {
      if (saves.length === 0) {
        communitySavesList.innerHTML = '<div class="community-loading">No saves found matching your criteria.</div>';
        return;
      }
      
      communitySavesList.innerHTML = '';
      
      saves.forEach(save => {
        const saveCard = document.createElement('div');
        saveCard.className = 'community-save-card';
        
        const savePreview = document.createElement('div');
        savePreview.className = 'community-save-preview';
        
        const previewImg = document.createElement('img');
        previewImg.src = save.preview;
        previewImg.alt = save.title;
        savePreview.appendChild(previewImg);
        
        const saveTitle = document.createElement('div');
        saveTitle.className = 'community-save-title';
        saveTitle.textContent = save.title;
        
        const saveAuthor = document.createElement('div');
        saveAuthor.className = 'community-save-author';
        saveAuthor.textContent = `By: ${save.author}`;
        
        const saveDate = document.createElement('div');
        saveDate.className = 'community-save-date';
        saveDate.textContent = `Uploaded: ${formatDate(save.date)}`;
        
        const saveDescription = document.createElement('div');
        saveDescription.className = 'community-save-description';
        saveDescription.textContent = save.description;
        
        const saveActions = document.createElement('div');
        saveActions.className = 'community-save-actions';
        
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download';
        downloadBtn.addEventListener('click', () => downloadCommunitySave(save.id));
        saveActions.appendChild(downloadBtn);
        
        saveCard.appendChild(savePreview);
        saveCard.appendChild(saveTitle);
        saveCard.appendChild(saveAuthor);
        saveCard.appendChild(saveDate);
        saveCard.appendChild(saveDescription);
        saveCard.appendChild(saveActions);
        
        communitySavesList.appendChild(saveCard);
      });
    }
    
    // Format date for display
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    }
    
    // Load local saves
    function loadLocalSaves() {
      communityLocalSavesList.innerHTML = '';
      selectedLocalSave = null;
      communityUploadBtn.disabled = true;
      
      // Get all save keys from localStorage
      const saveKeys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('sandboxSave_')) {
          saveKeys.push(key);
        }
      }
      
      if (saveKeys.length === 0) {
        communityLocalSavesList.innerHTML = '<div class="local-save-item">No local saves found. Create a save first!</div>';
        return;
      }
      
      // Display each save
      saveKeys.forEach(key => {
        try {
          const saveData = JSON.parse(localStorage.getItem(key));
          const saveItem = document.createElement('div');
          saveItem.className = 'local-save-item';
          saveItem.textContent = saveData.name || 'Unnamed Save';
          saveItem.dataset.key = key;
          
          saveItem.addEventListener('click', function() {
            // Deselect all other saves
            document.querySelectorAll('.local-save-item').forEach(item => {
              item.classList.remove('selected');
            });
            
            // Select this save
            this.classList.add('selected');
            selectedLocalSave = this.dataset.key;
            
            // Enable upload button
            communityUploadBtn.disabled = false;
            
            // Set default title if empty
            if (!communityUploadTitle.value) {
              communityUploadTitle.value = saveData.name || 'My Creation';
            }
          });
          
          communityLocalSavesList.appendChild(saveItem);
        } catch (error) {
          console.error('Error parsing save data:', error);
        }
      });
    }
    
    // Upload save to server
    async function uploadSave(title, description, saveData) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful upload
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // For demo purposes, always succeed
        return {
          success: true,
          message: 'Save uploaded successfully!'
        };
      } catch (error) {
        console.error('Upload error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Download community save
    async function downloadCommunitySave(saveId) {
      try {
        // Find the save in our local array
        const save = communitySaves.find(s => s.id === saveId);
        if (!save) {
          alert('Save not found');
          return;
        }
        
        // In a real implementation, this would fetch the save data from the server
        // For now, we'll simulate a successful download with a placeholder save
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Create a placeholder save
        const placeholderSave = {
          name: save.title,
          description: save.description,
          author: save.author,
          date: save.date,
          grid: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)),
          temp: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(20))
        };
        
        // Save to localStorage
        const saveKey = 'sandboxSave_community_' + Date.now();
        localStorage.setItem(saveKey, JSON.stringify(placeholderSave));
        
        alert(`"${save.title}" has been downloaded and saved to your local saves!`);
        
        return true;
      } catch (error) {
        console.error('Download error:', error);
        alert('Error downloading save. Please try again later.');
        return false;
      }
    }
    
      // Server Communication Module (for a real implementation)
      // This would be replaced with actual server communication code
      
      // Example server communication code (commented out for now):
      /*
      // Function to securely communicate with the server
      async function serverRequest(endpoint, method = 'GET', data = null) {
        try {
          const options = {
            method,
            headers: {
              'Content-Type': 'application/json'
            },
            credentials: 'include' // Include cookies for session management
          };
          
          if (data && (method === 'POST' || method === 'PUT')) {
            options.body = JSON.stringify(data);
          }
          
          const response = await fetch(`${SERVER_URL}/${endpoint}`, options);
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'Server error');
          }
          
          return await response.json();
        } catch (error) {
          console.error(`Error in ${endpoint}:`, error);
          throw error;
        }
      }
      
      // Login user
      async function loginUser(username, email, password) {
        return serverRequest('auth/login', 'POST', { username, email, password });
      }
      
      // Register user
      async function registerUser(username, email, password) {
        return serverRequest('auth/register', 'POST', { username, email, password });
      }
      
      // Load community saves
      async function loadCommunitySaves() {
        return serverRequest('saves');
      }
      
      // Upload save
      async function uploadSave(title, description, saveData) {
        return serverRequest('saves/upload', 'POST', {
          title,
          description,
          saveData,
          date: new Date().toISOString()
        });
      }
      
      // Download save
      async function downloadCommunitySave(saveId) {
        return serverRequest(`saves/${saveId}`);
      }
      */
    }); // Close DOMContentLoaded event handler
  </script>



  <!-- Mod Manager Modal -->
  <div id="modMenu" class="modal mod-manager-modal">
    <div class="modal-content mod-manager-content">
      <div class="mod-manager-header">
        <h2 class="mod-manager-title">
          <svg class="mod-manager-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
          </svg>
          Mod Manager
          <span class="mod-manager-subtitle">Enhance your sandbox experience</span>
        </h2>
        <button id="closeModMenu" class="close-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
          </svg>
        </button>
      </div>

      <div class="mod-manager-tabs">
        <button class="mod-tab-btn active" data-tab="installed">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,2L3,7L12,12L21,7L12,2M3,17L12,22L21,17L12,12L3,17Z"/>
          </svg>
          Installed Mods
          <span class="mod-count" id="installedModCount">0</span>
        </button>
        <button class="mod-tab-btn" data-tab="browse">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/>
          </svg>
          Browse & Install
        </button>
        <button class="mod-tab-btn" data-tab="create">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20,14H14V20H10V14H4V10H10V4H14V10H20V14Z"/>
          </svg>
          Add Mod
        </button>
        <button class="mod-tab-btn" data-tab="settings">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
          </svg>
          Settings
        </button>
      </div>

      <div class="mod-manager-body">
        <!-- Installed Mods Tab -->
        <div class="mod-tab-content active" data-tab="installed">
          <div class="mod-controls">
            <div class="mod-search-container">
              <svg class="search-icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/>
              </svg>
              <input type="text" id="modSearchInput" placeholder="Search installed mods..." class="mod-search-input">
            </div>
            <div class="mod-filter-controls">
              <select id="modStatusFilter" class="modern-select">
                <option value="all">All Mods</option>
                <option value="enabled">Enabled Only</option>
                <option value="disabled">Disabled Only</option>
                <option value="incompatible">Incompatible</option>
              </select>
              <button id="refreshModList" class="action-btn">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                </svg>
                Refresh
              </button>
            </div>
          </div>
          
          <div id="modListContainer" class="mod-grid">
            <!-- Mod cards will be dynamically inserted here -->
          </div>
          
          <div id="noModsMessage" class="no-mods-message">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M12,2L3,7L12,12L21,7L12,2M3,17L12,22L21,17L12,12L3,17Z"/>
            </svg>
            <h3>No Mods Installed</h3>
            <p>Get started by creating your first mod or browsing the community collection</p>
            <button id="createFirstMod" class="action-btn" style="display: inline-flex; align-items: center; gap: 8px; padding: 12px 24px; margin-top: 16px;">
              <svg viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                <path d="M20,14H14V20H10V14H4V10H10V4H14V10H20V14Z"/>
              </svg>
              Add Your First Mod
            </button>
          </div>
        </div>

        <!-- Browse & Install Tab -->
        <div class="mod-tab-content" data-tab="browse">
          <div class="browse-header">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/>
            </svg>
            <div class="browse-header-text">
              <h3>Community Mod Repository</h3>
              <p>Discover and install mods created by the community</p>
            </div>
          </div>
          
          <div class="browse-notice">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
            </svg>
            <div>
              <h4>Coming Soon!</h4>
              <p>The community mod repository is currently under development. For now, you can manually install mods by pasting their code in the "Create Mod" tab.</p>
            </div>
          </div>
        </div>

        <!-- Create Mod Tab -->
        <div class="mod-tab-content" data-tab="create">
          <div class="create-mod-container">
            <div class="create-mod-header">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M20,14H14V20H10V14H4V10H10V4H14V10H20V14Z"/>
              </svg>
              <div class="create-mod-header-text">
                <h3>Add Community Mod</h3>
                <p>Paste JavaScript mod code from the community to install new features</p>
              </div>
            </div>
            
            <div class="mod-creation-form">
              <div class="form-section">
                <div class="mod-info-section">
                  <h4>ðŸ“‹ How to Add Mods</h4>
                  <p>Mods automatically provide their own name, description, and other details. Simply paste the complete mod code below!</p>
                  
                  <div class="mod-format-example">
                    <h5>ðŸ·ï¸ Mod Format</h5>
                    <p>Valid mods should start with metadata like this:</p>
                    <code>
window.forcedModInfo = {<br>
&nbsp;&nbsp;id: 'uniqueModId',<br>
&nbsp;&nbsp;title: 'My Awesome Mod',<br>
&nbsp;&nbsp;description: 'This mod does cool things!',<br>
&nbsp;&nbsp;gameVersion: '0.7.1c'<br>
};
                    </code>
                  </div>
                </div>
              </div>
              
              <div class="form-section">
                <label for="newModCode">Mod JavaScript Code</label>
                <div class="code-editor-container">
                  <textarea id="newModCode" rows="20" placeholder="// Paste complete mod code here&#10;// Example:&#10;window.forcedModInfo = {&#10;  id: 'myMod',&#10;  title: 'My Mod',&#10;  description: 'What this mod does',&#10;  gameVersion: '0.7.1c'&#10;};&#10;&#10;// Your mod code goes here..." class="mod-code-textarea"></textarea>
                  <div class="code-editor-footer">
                    <div class="code-stats">
                      <span id="codeLineCount">Lines: 0</span>
                      <span id="codeCharCount">Characters: 0</span>
                    </div>
                    <div class="code-actions">
                      <button id="validateModCode" class="secondary-btn">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                          <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,16.5L6.5,12L7.91,10.59L11,13.67L16.59,8.09L18,9.5L11,16.5Z"/>
                        </svg>
                        Validate
                      </button>
                      <button id="formatModCode" class="secondary-btn">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                          <path d="M14.6,16.6L19.2,12L14.6,7.4L13.2,8.8L16.4,12L13.2,15.2L14.6,16.6M9.4,16.6L10.8,15.2L7.6,12L10.8,8.8L9.4,7.4L4.8,12L9.4,16.6Z"/>
                        </svg>
                        Format
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="form-actions">
                <button id="clearModForm" class="secondary-btn">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                  </svg>
                  Clear Form
                </button>
                <button id="saveNewModButton" class="primary-btn">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"/>
                  </svg>
                  Add Mod
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Settings Tab -->
        <div class="mod-tab-content" data-tab="settings">
          <div class="settings-container">
            <div class="settings-header">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
              </svg>
              <div class="settings-header-text">
                <h3>Mod Manager Settings</h3>
                <p>Configure how mods behave and interact with the game</p>
              </div>
            </div>
            
            <div class="settings-grid">
              <div class="setting-card">
                <div class="setting-header">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
                  </svg>
                  <div class="setting-text">
                    <h4>Safe Mode</h4>
                    <p>Disable potentially harmful mod features</p>
                  </div>
                </div>
                <div class="setting-control">
                  <label class="toggle-switch">
                    <input type="checkbox" id="modSafeMode" checked>
                    <span class="toggle-slider"></span>
                  </label>
                </div>
              </div>
              
              <div class="setting-card">
                <div class="setting-header">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                  </svg>
                  <div class="setting-text">
                    <h4>Auto-reload Mods</h4>
                    <p>âš ï¸ EXPERIMENTAL: Automatically reload mods when the game starts</p>
                  </div>
                </div>
                <div class="setting-control">
                                  <label class="toggle-switch">
                  <input type="checkbox" id="autoReloadMods">
                  <span class="toggle-slider"></span>
                </label>
                </div>
              </div>
              
              <div class="setting-card">
                <div class="setting-header">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"/>
                  </svg>
                  <div class="setting-text">
                    <h4>Mod Debug Console</h4>
                    <p>Show detailed logs for mod execution</p>
                  </div>
                </div>
                <div class="setting-control">
                  <label class="toggle-switch">
                    <input type="checkbox" id="modDebugMode">
                    <span class="toggle-slider"></span>
                  </label>
                </div>
              </div>
              
              <div class="setting-card action-card">
                <div class="setting-header">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2,3H6V7H2V3M7,3H11V7H7V3M12,3H16V7H12V3M17,3H21V7H17V3M2,8H6V12H2V8M7,8H11V12H7V8M12,8H16V12H12V8M17,8H21V12H17V8M2,13H6V17H2V13M7,13H11V17H7V13M12,13H16V17H12V13M17,13H21V17H17V13M2,18H6V22H2V18M7,18H11V22H7V18M12,18H16V22H12V18M17,18H21V22H17V22Z"/>
                  </svg>
                  <div class="setting-text">
                    <h4>Reset All Mods</h4>
                    <p>Remove all installed mods and reset to defaults</p>
                  </div>
                </div>
                <div class="setting-control">
                  <button id="resetAllMods" class="danger-btn">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                      <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
                    </svg>
                    Reset All
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  


  <!-- Options Modal -->
  <div id="optionsModal" class="modal options-modal">
    <div class="modal-content options-content">
      <div class="options-header">
        <h2 class="options-title">
          <svg class="options-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
          </svg>
          Settings & Preferences
        </h2>
        <button id="closeOptionsModal" class="close-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
          </svg>
        </button>
          </div>

      <div class="options-tabs">
        <button class="options-tab-btn active" data-tab="gameplay">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M15,7.5V2H9V7.5L12,10.5L15,7.5M7.5,9H2V15H7.5L10.5,12L7.5,9M22,9H16.5L13.5,12L16.5,15H22V9M7.5,15H2V21H7.5L10.5,18L7.5,15M15,16.5V22H9V16.5L12,13.5L15,16.5Z"/>
          </svg>
          Gameplay
        </button>
        <button class="options-tab-btn" data-tab="graphics">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3M19,19H5V5H16.17L19,7.83V19Z"/>
          </svg>
          Graphics
        </button>
        <button class="options-tab-btn" data-tab="audio">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"/>
          </svg>
          Audio
        </button>
        <button class="options-tab-btn" data-tab="experimental">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M9.4,16.6L4.8,12L3.4,13.4L9.4,19.4L20.6,8.2L19.2,6.8L9.4,16.6M5,3H19A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3M5,5V19H19V5H5Z"/>
          </svg>
          Experimental
        </button>
      </div>

      <div class="options-body">
        <!-- Gameplay Tab -->
        <div class="options-tab-content active" data-tab="gameplay">
          <div class="options-grid">
            <div class="option-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M2,2H8V4H16V2H22V8H20V16H22V22H16V20H8V22H2V16H4V8H2V2M16,8V6H8V8H6V16H8V18H16V16H18V8H16M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"/>
                </svg>
                <div class="option-text">
                  <h4>Stage Size</h4>
                  <p>Size of the simulation grid</p>
                </div>
              </div>
              <div class="option-control">
                <select id="stageSizeSelect" class="modern-select">
                  <option value="25">25Ã—25 (Tiny)</option>
                  <option value="50">50Ã—50 (Small)</option>
                  <option value="75" selected>75Ã—75 (Medium)</option>
                  <option value="100">100Ã—100 (Large)</option>
                  <option value="125">125Ã—125 (XL)</option>
                  <option value="150">150Ã—150 (XXL)</option>
                  <option value="175">175Ã—175 (Huge)</option>
                  <option value="200">200Ã—200 (Massive)</option>
            </select>
                <div class="option-warning" id="largeGridWarning">
                  âš ï¸ Large grids can cause performance issues on low-power devices
                </div>
                <div class="option-info clear-warning">
                  ðŸ—‘ï¸ Changing stage size will clear the canvas
                </div>
              </div>
          </div>

            <div class="option-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M11,17H13V11H11V17M11,9H13V7H11V9Z"/>
                </svg>
                <div class="option-text">
                  <h4>HUD Display</h4>
                  <p>Show temperature, element info, and FPS</p>
                </div>
              </div>
              <div class="option-control">
                <label class="toggle-switch">
                  <input type="checkbox" id="hudToggle">
                  <span class="toggle-slider"></span>
                </label>
          </div>
        </div>

            <div class="option-card action-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M14,6L10.25,11L13.1,14.8L11.5,16C9.81,13.75 7,10 7,10L1,18H23L14,6Z"/>
                </svg>
                <div class="option-text">
                  <h4>Generate Terrain</h4>
                  <p>Create a procedural world with caves and features</p>
                </div>
              </div>
              <div class="option-control">
                <button id="generateTerrainBtn" class="action-btn">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4M11,16.5L18,9.5L16.5,8L11,13.5L7.5,10L6,11.5L11,16.5Z"/>
                  </svg>
                  Generate
                </button>
              </div>
            </div>
          </div>
          </div>

        <!-- Graphics Tab -->
        <div class="options-tab-content" data-tab="graphics">
          <div class="options-grid">
            <div class="option-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3Z"/>
                </svg>
                <div class="option-text">
                  <h4>Color Variations</h4>
                  <p>Add subtle color differences to elements</p>
                </div>
              </div>
              <div class="option-control">
                <label class="toggle-switch">
                  <input type="checkbox" id="variatedColorsToggle">
                  <span class="toggle-slider"></span>
                </label>
                <button id="applyVariatedColors" class="apply-btn">Apply</button>
              </div>
            </div>

            <div class="option-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M9.62,12L12,5.67L14.38,12M11,3L5.5,17H7.75L8.87,14H15.13L16.25,17H18.5L13,3H11Z"/>
                </svg>
                <div class="option-text">
                  <h4>Font Style</h4>
                  <p>Choose your preferred pixelated font</p>
                </div>
              </div>
              <div class="option-control">
                <select id="fontStyleSelect" class="modern-select">
              <option value="Pixelify Sans" selected>Pixelify Sans</option>
              <option value="Silkscreen">Silkscreen</option>
              <option value="VT323">VT323</option>
              <option value="Dogica">Dogica</option>
            </select>
                <button id="applyFontStyle" class="apply-btn">Apply</button>
              </div>
          </div>

            <div class="option-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M8,3A2,2 0 0,0 6,5V9A2,2 0 0,1 4,11H3V13H4A2,2 0 0,1 6,15V19A2,2 0 0,0 8,21H10V19H8V14A2,2 0 0,0 6,12A2,2 0 0,0 8,10V5H10V3H8M16,3A2,2 0 0,1 18,5V9A2,2 0 0,0 20,11H21V13H20A2,2 0 0,0 18,15V19A2,2 0 0,1 16,21H14V19H16V14A2,2 0 0,1 18,12A2,2 0 0,1 16,10V5H14V3H16Z"/>
                </svg>
                <div class="option-text">
                  <h4>UI Mode</h4>
                  <p>Switch between modern and retro interface styles</p>
                </div>
              </div>
              <div class="option-control">
                <select id="uiModeSelect" class="modern-select">
                  <option value="natural" selected>Modern</option>
                  <option value="pixel">Retro Pixel</option>
            </select>
                <button id="applyUiMode" class="apply-btn">Apply</button>
              </div>
            </div>
          </div>
          </div>
          
        <!-- Audio Tab -->
        <div class="options-tab-content" data-tab="audio">
          <div class="audio-header">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"/>
            </svg>
            <div class="audio-header-text">
              <h3>Audio Control Center</h3>
              <p>Fine-tune all sound settings and effects in the simulation</p>
            </div>
        </div>
        
          <div class="audio-sections">
            <!-- Master Audio Controls -->
            <div class="audio-section">
              <div class="section-header">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M9,16L5,12L6.5,10.5L9,13L17.5,4.5L19,6L9,16Z"/>
                </svg>
                <h4>Master Controls</h4>
              </div>
              <div class="audio-controls">
                <div class="control-group">
                  <div class="control-item">
                    <label for="masterVolumeSlider">Master Volume</label>
                    <div class="volume-control">
            <input type="range" id="masterVolumeSlider" min="0" max="100" value="100" class="volume-slider">
                      <span id="masterVolumeValue" class="volume-display">100%</span>
                    </div>
          </div>
          
                  <div class="control-item">
                    <label for="audioModeSelect">Audio Quality</label>
                    <select id="audioModeSelect" class="modern-select">
                      <option value="high">High Quality</option>
                      <option value="medium" selected>Medium Quality</option>
                      <option value="low">Low Quality (Performance)</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>

            <!-- Sound Effects Categories -->
            <div class="audio-section">
              <div class="section-header">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M19,13H5V11H19V13M12,2L13.09,8.26L22,9L13.09,9.74L12,16L10.91,9.74L2,9L10.91,8.26L12,2Z"/>
                </svg>
                <h4>Sound Categories</h4>
              </div>
              <div class="audio-controls">
                <div class="sound-categories">
                  <div class="category-card">
                    <div class="category-header">
                      <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M10,17L15,12L10,7V17Z"/>
                      </svg>
                      <h5>Placement Sounds</h5>
                    </div>
                    <div class="category-controls">
                      <div class="volume-control">
                        <input type="range" id="placementVolume" min="0" max="200" value="100" class="volume-slider">
                        <span id="placementVolumeValue">100%</span>
                      </div>
                      <button id="testPlacementSound" class="test-btn">Test</button>
                    </div>
                  </div>

                  <div class="category-card">
                    <div class="category-header">
                      <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M17,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3M19,19H5V5H15V9H19V19Z"/>
                      </svg>
                      <h5>Explosions</h5>
                    </div>
                    <div class="category-controls">
                      <div class="volume-control">
                        <input type="range" id="explosionVolume" min="0" max="200" value="100" class="volume-slider">
                        <span id="explosionVolumeValue">100%</span>
                      </div>
                      <button id="testExplosionSound" class="test-btn">Test</button>
                    </div>
                  </div>

                  <div class="category-card">
                    <div class="category-header">
                      <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12,18.5A6.5,6.5 0 0,1 5.5,12A6.5,6.5 0 0,1 12,5.5A6.5,6.5 0 0,1 18.5,12A6.5,6.5 0 0,1 12,18.5M12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16Z"/>
                      </svg>
                      <h5>Ball Physics</h5>
                    </div>
                    <div class="category-controls">
                      <div class="volume-control">
                        <input type="range" id="bouncingVolume" min="0" max="200" value="100" class="volume-slider">
                        <span id="bouncingVolumeValue">100%</span>
                      </div>
                      <button id="testBouncingSound" class="test-btn">Test</button>
                    </div>
                  </div>

                  <div class="category-card">
                    <div class="category-header">
                      <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z"/>
                      </svg>
                      <h5>Glass Breaking</h5>
                    </div>
                    <div class="category-controls">
                      <div class="volume-control">
                        <input type="range" id="glassBreakVolume" min="0" max="200" value="100" class="volume-slider">
                        <span id="glassBreakVolumeValue">100%</span>
                      </div>
                      <button id="testGlassBreakSound" class="test-btn">Test</button>
                    </div>
                  </div>

                  <div class="category-card">
                    <div class="category-header">
                      <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
                      </svg>
                      <h5>Lightning & Weather</h5>
                    </div>
                    <div class="category-controls">
                      <div class="volume-control">
                        <input type="range" id="lightningVolume" min="0" max="200" value="100" class="volume-slider">
                        <span id="lightningVolumeValue">100%</span>
                      </div>
                      <button id="testLightningSound" class="test-btn">Test</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Individual Element Controls -->
            <div class="audio-section">
              <div class="section-header">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12,3V12.26C11.5,12.09 11,12 10.5,12C8.01,12 6,14.01 6,16.5C6,18.99 8.01,21 10.5,21C12.99,21 15,18.99 15,16.5V6H19V3H12Z"/>
                </svg>
                <h4>Individual Element Volumes</h4>
              </div>
              <div class="audio-controls">
                <div class="element-controls-header">
                  <p>Fine-tune the volume of specific elements and materials</p>
                  <button id="toggleElementVolumes" class="toggle-btn">
                    <span>Show Element Controls</span>
                    <svg viewBox="0 0 24 24" fill="currentColor">
                      <path d="M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z"/>
                    </svg>
                  </button>
                </div>
                
                <div id="elementVolumeControls" class="element-volume-section" style="display: none;">
                  <div class="element-search">
                    <input type="text" id="elementVolumeSearch" placeholder="Search elements..." class="search-input">
                  </div>
              <div class="element-volume-grid">
                <!-- Element volume sliders will be added here dynamically -->
              </div>
            </div>
          </div>
        </div>

            <!-- Advanced Audio Settings -->
            <div class="audio-section">
              <div class="section-header">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                </svg>
                <h4>Advanced Settings</h4>
              </div>
              <div class="audio-controls">
                <div class="advanced-settings">
                  <div class="setting-group">
                    <div class="setting-item">
                      <label>
                        <input type="checkbox" id="enableSpatialAudio" checked>
                        <span class="checkmark"></span>
                        Spatial Audio
                      </label>
                      <p class="setting-desc">Sounds vary based on screen position</p>
                    </div>
                    
                    <div class="setting-item">
                      <label>
                        <input type="checkbox" id="enableVolumeLimit" checked>
                        <span class="checkmark"></span>
                        Volume Limiting
                      </label>
                      <p class="setting-desc">Prevent audio clipping and distortion</p>
                    </div>
                    
                    <div class="setting-item">
                      <label>
                        <input type="checkbox" id="enableSoundThrottling" checked>
                        <span class="checkmark"></span>
                        Sound Throttling
                      </label>
                      <p class="setting-desc">Limit simultaneous sounds for performance</p>
                    </div>
                  </div>
                  
                  <div class="setting-group">
                    <div class="setting-item">
                      <label for="maxSoundsSlider">Max Simultaneous Sounds</label>
                      <div class="volume-control">
                        <input type="range" id="maxSoundsSlider" min="1" max="10" value="3" class="volume-slider">
                        <span id="maxSoundsValue">3</span>
                      </div>
                    </div>
                    
                    <div class="setting-item">
                      <label for="soundThrottleSlider">Sound Frequency</label>
                      <div class="volume-control">
                        <input type="range" id="soundThrottleSlider" min="10" max="100" value="20" class="volume-slider">
                        <span id="soundThrottleValue">20%</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Experimental Tab -->
        <div class="options-tab-content" data-tab="experimental">
          <div class="experimental-notice">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
            </svg>
            <div>
          <h3>Experimental Features</h3>
              <p>These features are under development and may cause instability or performance issues.</p>
          </div>
          </div>
          
          <div class="options-grid">
            <div class="option-card experimental-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L15.96,7.19C16.5,7.69 17.21,8 18,8A3,3 0 0,0 21,5A3,3 0 0,0 18,2A3,3 0 0,0 15,5C15,5.24 15.04,5.47 15.09,5.7L8.04,9.81C7.5,9.31 6.79,9 6,9A3,3 0 0,0 3,12A3,3 0 0,0 6,15C6.79,15 7.5,14.69 8.04,14.19L15.16,18.34C15.11,18.55 15.08,18.77 15.08,19C15.08,20.61 16.39,21.91 18,21.91C19.61,21.91 20.92,20.61 20.92,19A2.92,2.92 0 0,0 18,16.08Z"/>
                </svg>
                <div class="option-text">
                  <h4>Pop-Out Mode</h4>
                  <p class="experimental-label">UNSTABLE</p>
                  <p>Open simulation in separate resizable window</p>
          </div>
              </div>
              <div class="option-control">
                <label class="toggle-switch">
                  <input type="checkbox" id="popOutMode">
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>

            <div class="option-card experimental-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12,18.5A6.5,6.5 0 0,1 5.5,12A6.5,6.5 0 0,1 12,5.5A6.5,6.5 0 0,1 18.5,12A6.5,6.5 0 0,1 12,18.5M12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z"/>
                </svg>
                                 <div class="option-text">
                   <h4>DSPLE Engine</h4>
                   <p class="experimental-label">PERFORMANCE INTENSIVE</p>
                   <p>Dabicco Shader-Pixelated Lightning Engine - realistic light effects</p>
                 </div>
              </div>
              <div class="option-control">
                <label class="toggle-switch">
                  <input type="checkbox" id="dspleToggle">
                  <span class="toggle-slider"></span>
                </label>
                <button id="applyDsple" class="apply-btn">Apply</button>
              </div>
            </div>

            <div class="option-card experimental-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M10,17L15,12L10,7V17Z"/>
                </svg>
                                 <div class="option-text">
                   <h4>DabyFPS</h4>
                   <p class="experimental-label">MAY REDUCE PERFORMANCE</p>
                   <p>DabyFPS's Main Feature, Frame Rate Stabilization (DBFRS), has already been added to the game; enable for MISC optimizations, however these can and probably will slow down the game more than it optimizes it.</p>
                 </div>
              </div>
              <div class="option-control">
                <label class="toggle-switch">
                  <input type="checkbox" id="setting-dabyfps">
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>

            <div class="option-card" id="fps-cap-container" style="display:none;">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z"/>
                </svg>
                <div class="option-text">
                  <h4>FPS Cap</h4>
                  <p>Maximum frames per second limit</p>
                </div>
              </div>
              <div class="option-control">
                <select id="setting-fps-cap" class="modern-select">
                  <option value="30">30 FPS</option>
                  <option value="60" selected>60 FPS</option>
                  <option value="75">75 FPS</option>
                  <option value="100">100 FPS</option>
                  <option value="120">120 FPS</option>
                  <option value="165">165 FPS</option>
                  <option value="200">200 FPS</option>
                  <option value="365">365 FPS</option>
                  <option value="512">512 FPS</option>
            </select>
          </div>
        </div>
      </div>
          
          <!-- Clear All Data Section -->
          <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid var(--border-color);">
            <div class="option-card experimental-card danger-card">
              <div class="option-header">
                <svg class="option-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                </svg>
                <div class="option-text">
                  <h4>Clear All Data</h4>
                  <p class="experimental-label danger-label">DESTRUCTIVE ACTION</p>
                  <p>Delete all saves, settings, and game data. This will reset everything and reload the page.</p>
                </div>
              </div>
              <div class="option-control">
                <button id="clearAllDataButton" class="danger-btn">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
                  </svg>
                  Clear All Data
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="options-footer">
        <button id="applyOptionsButton" class="danger-btn" style="display: none;">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
          </svg>
          Apply Changes (Will Clear Canvas)
        </button>
      </div>
    </div>
  </div>

  <!-- Save/Load Modal -->
  <div id="saveLoadModal" class="modal save-load-modal">
    <div class="modal-content save-load-content">
      <div class="save-load-header">
        <h2 class="save-load-title">
          <svg class="save-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
          </svg>
          Game Data Manager
        </h2>
        <button id="closeSaveLoadModal" class="close-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
          </svg>
        </button>
      </div>

      <div class="save-load-tabs">
        <button class="tab-btn active" data-tab="save">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
          </svg>
          Save Game
        </button>
        <button class="tab-btn" data-tab="load">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 2 2h8l6-6V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>
          </svg>
          Load Game
        </button>
        <button class="tab-btn" data-tab="import">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
          </svg>
          Import
        </button>
      </div>

      <div class="save-load-body">
        <!-- Save Tab -->
        <div class="tab-content active" data-tab="save">
          <div class="save-section">
            <div class="canvas-preview">
              <canvas id="savePreviewCanvas" width="200" height="200"></canvas>
              <div class="preview-overlay">
                <span>Current State</span>
              </div>
            </div>
            <div class="save-form">
                              <div class="form-group">
                  <label for="saveTitle">Save Name</label>
                  <input type="text" id="saveTitle" placeholder="Enter a name for your save..." maxlength="20">
                  <div id="saveTitleWarning" class="input-warning"></div>
                </div>
                <div class="form-group">
                  <label for="saveDescription">Description</label>
                  <textarea id="saveDescription" placeholder="Describe your creation..." maxlength="100" rows="3"></textarea>
                  <div id="saveDescriptionWarning" class="input-warning"></div>
                </div>
                <div id="saveMessage" class="save-message"></div>
              <div class="save-info">
                <div class="info-item">
                  <span class="info-label">Grid Size:</span>
                  <span class="info-value" id="currentGridSize">50x50</span>
                </div>
                <div class="info-item">
                  <span class="info-label">Temperature:</span>
                  <span class="info-value" id="temperatureEnabled">Enabled</span>
                </div>
                <div class="info-item">
                  <span class="info-label">Timestamp:</span>
                  <span class="info-value" id="saveTimestamp">Now</span>
                </div>
              </div>
              <button id="saveGameButton" class="primary-btn">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                </svg>
                Save Game
              </button>
            </div>
          </div>
        </div>

        <!-- Load Tab -->
        <div class="tab-content" data-tab="load">
          <div class="saves-section">
            <div class="saves-header">
              <h3>Your Saved Games</h3>
              <div class="saves-actions">
                <button id="refreshSaves" class="icon-btn" title="Refresh">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                  </svg>
                </button>
                <button id="deleteAllSaves" class="icon-btn danger" title="Delete All">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                  </svg>
                </button>
              </div>
            </div>
            <div id="savedGamesList" class="saves-grid">
              <!-- Saved games will be populated here -->
            </div>
            <div id="noSavesMessage" class="no-saves-message">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
              </svg>
              <h4>No Saved Games</h4>
              <p>Create your first save by switching to the Save tab!</p>
            </div>
          </div>
        </div>

        <!-- Import Tab -->
        <div class="tab-content" data-tab="import">
          <div class="import-section">
            <div class="import-area" id="importDropZone">
              <div class="import-content">
                <svg class="import-icon" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                </svg>
                <h3>Import Save File</h3>
                <p>Drag and drop a .dbr file here, or click to browse</p>
                <input type="file" id="importFileInput" accept=".dbr" hidden>
                <button id="browseFileBtn" class="secondary-btn">Browse Files</button>
              </div>
            </div>
            <div class="import-info">
                              <h4>Supported Formats</h4>
                <ul>
                  <li>.dbr files (Dabicco Rewritten files)</li>
                  <li>Community saves from other players</li>
                  <li>Exported game states</li>
                </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Community Saves Modal -->
  <div id="communityModal" class="modal">
    <div class="modal-content">
      <span id="closeCommunityModal" class="close">&times;</span>
      <h2>Community Saves</h2>
      <div>
        <h3>Browse Community Saves</h3>
        <div id="communitySavesList">
          <!-- List of community saves will appear here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Load saved font preference when page loads
    document.addEventListener('DOMContentLoaded', function() {
      loadFontPreference();
      loadUiModePreference();
      
      // Add event listener for font style button
      const applyFontButton = document.getElementById('applyFontStyle');
      if (applyFontButton) {
        applyFontButton.addEventListener('click', applyFontStyle);
      }
      
      // Add event listener for UI mode button
      const applyUiModeButton = document.getElementById('applyUiMode');
      if (applyUiModeButton) {
        applyUiModeButton.addEventListener('click', applyUiMode);
      }
    });
    
    // Function to load and apply saved font preference
    function loadFontPreference() {
      const savedFont = localStorage.getItem('fontStyle') || 'Pixelify Sans';
      document.body.style.fontFamily = `'${savedFont}', monospace`;
      
      // Update the select dropdown to match the saved font
      const fontSelect = document.getElementById('fontStyleSelect');
      if (fontSelect) {
        for (let i = 0; i < fontSelect.options.length; i++) {
          if (fontSelect.options[i].value === savedFont) {
            fontSelect.selectedIndex = i;
            break;
          }
        }
      }
    }
    
    // Function to apply the selected font and save to localStorage
    function applyFontStyle() {
      const fontSelect = document.getElementById('fontStyleSelect');
      const selectedFont = fontSelect.value;
      
      // Apply font to body (will cascade to all elements through inheritance)
      document.body.style.fontFamily = `'${selectedFont}', monospace`;
      
      // Save selection to localStorage
      localStorage.setItem('fontStyle', selectedFont);
      
      // Use the existing notification system
      try {
        const notification = document.getElementById('selectedElementNotification');
        const colorDisplay = document.getElementById('selectedElementColor');
        const nameDisplay = document.getElementById('selectedElementName');
        
        if (notification && colorDisplay && nameDisplay) {
          // Update the color (use a blue color for font changes)
          colorDisplay.style.backgroundColor = '#00b4d8';
          nameDisplay.textContent = `Font: ${selectedFont}`;
          
          // Show the notification with animation
          notification.classList.remove('visible');
          void notification.offsetWidth; // Force reflow
          notification.classList.add('visible');
          
          // Hide after 3 seconds
          clearTimeout(notification.timeoutId);
          notification.timeoutId = setTimeout(() => {
            notification.classList.remove('visible');
          }, 3000);
        }
      } catch (error) {
        console.error('Error showing font change notification:', error);
      }
    }
    
    // Function to load and apply saved UI mode preference
    function loadUiModePreference() {
      const savedMode = localStorage.getItem('uiMode') || 'natural';
      
      // Apply the saved mode
      if (savedMode === 'pixel') {
        document.body.classList.add('pixel-mode');
      } else {
        document.body.classList.remove('pixel-mode');
      }
      
      // Update the select dropdown to match the saved mode
      const uiModeSelect = document.getElementById('uiModeSelect');
      if (uiModeSelect) {
        for (let i = 0; i < uiModeSelect.options.length; i++) {
          if (uiModeSelect.options[i].value === savedMode) {
            uiModeSelect.selectedIndex = i;
            break;
          }
        }
      }
    }
    
    // Function to apply the selected UI mode and save to localStorage
    function applyUiMode() {
      const uiModeSelect = document.getElementById('uiModeSelect');
      const selectedMode = uiModeSelect.value;
      
      // Apply the selected mode
      if (selectedMode === 'pixel') {
        document.body.classList.add('pixel-mode');
      } else {
        document.body.classList.remove('pixel-mode');
      }
      
      // Save selection to localStorage
      localStorage.setItem('uiMode', selectedMode);
      
      // Use the existing notification system
      try {
        const notification = document.getElementById('selectedElementNotification');
        const colorDisplay = document.getElementById('selectedElementColor');
        const nameDisplay = document.getElementById('selectedElementName');
        
        if (notification && colorDisplay && nameDisplay) {
          // Update the color (use a purple color for UI mode changes)
          colorDisplay.style.backgroundColor = '#9900ff';
          nameDisplay.textContent = `UI Mode: ${selectedMode.charAt(0).toUpperCase() + selectedMode.slice(1)}`;
          
          // Show the notification with animation
          notification.classList.remove('visible');
          void notification.offsetWidth; // Force reflow
          notification.classList.add('visible');
          
          // Hide after 3 seconds
          clearTimeout(notification.timeoutId);
          notification.timeoutId = setTimeout(() => {
            notification.classList.remove('visible');
          }, 3000);
        }
      } catch (error) {
        console.error('Error showing UI mode change notification:', error);
      }
    }
    
    // Global mods list
    const modsList = [];
    // Function to parse forcedModInfo from mod code using regex
    function parseForcedModInfo(modCode) {
      const regex = /window\.forcedModInfo\s*=\s*(\{[\s\S]*?\});/m;
      const match = modCode.match(regex);
      if (match && match[1]) {
        try {
          return (new Function("return " + match[1]))();
        } catch (e) {
          console.error("Error parsing forcedModInfo:", e);
          return null;
        }
      }
      return null;
    }
    // Add the default mod (Cosmic Sand mod) to the modsList.
    const cosmicSandModCode = `(function(){
      // ----------------------------------------------------------------------
      // MOD METADATA - Required for all mods
      // ----------------------------------------------------------------------
      window.forcedModInfo = {
        id: 'cosmicSandMod',
        title: 'Cosmic Sand',
        description: 'Adds magical cosmic sand that glows, sparkles, and creates beautiful light effects when it falls!',
        gameVersion: '0.7.1c'
      };

      // ----------------------------------------------------------------------
      // DEFINE NEW ELEMENT CONSTANT
      // ----------------------------------------------------------------------
      if (typeof window.COSMIC_SAND === 'undefined') {
        window.COSMIC_SAND = 1000; // Use ID 1000 for cosmic sand
      }

      // ----------------------------------------------------------------------
      // ADD COSMIC SAND TO ELEMENT BASE COLORS
      // ----------------------------------------------------------------------
      if (!elementBaseColors[window.COSMIC_SAND]) {
        elementBaseColors[window.COSMIC_SAND] = '#ff1493'; // Deep pink base color - very visible
      }

      // ----------------------------------------------------------------------
      // STORE ORIGINAL FUNCTIONS FOR RESTORATION
      // ----------------------------------------------------------------------
      if (!window.cosmicSandOriginals) {
        window.cosmicSandOriginals = {
          getElementName: getElementName,
          getElementColor: getElementColor,
          placeElementAt: placeElementAt,
          performSimulationStep: performSimulationStep
        };
      }

            // ----------------------------------------------------------------------
      // ADD COSMIC SAND TOOL TO TOOLBAR
      // ----------------------------------------------------------------------
      
      // First patch the selectTool function to handle cosmic sand
      const originalSelectTool = selectTool;
      selectTool = function(el) {
        // Call the original function
        originalSelectTool(el);
        
        // Check if it's cosmic sand
        const name = el.getAttribute('data-tool');
        if (name === 'cosmic-sand') {
          currentTool = window.COSMIC_SAND;
          
          // Show element notification
          const selectedElementNotification = document.getElementById('selectedElementNotification');
          if (selectedElementNotification) {
            const elementName = selectedElementNotification.querySelector('.element-name');
            const elementColor = selectedElementNotification.querySelector('.element-color');
            
            if (elementName && elementColor) {
              elementName.textContent = 'Cosmic Sand';
              elementColor.style.backgroundColor = '#ff1493';
            }
            
            selectedElementNotification.classList.add('visible');
            setTimeout(() => {
              selectedElementNotification.classList.remove('visible');
            }, 3000);
          }
        }
      };
      
      // Now add the tool to the toolbar
      const toolbar = document.getElementById('toolbar');
      if (toolbar) {
        // Create the cosmic sand tool with proper structure
        const cosmicTool = document.createElement('div');
        cosmicTool.className = 'tool cosmic-sand';
        cosmicTool.setAttribute('data-tool', 'cosmic-sand');
        cosmicTool.setAttribute('data-cat', 'special');
        cosmicTool.title = 'Cosmic Sand - Magical glowing sand';
        
        // Create the inner span element like other tools
        const span = document.createElement('span');
        span.textContent = 'Cosmic';
        cosmicTool.appendChild(span);
        
        // Add special styling
        cosmicTool.style.cssText = \`
          background: linear-gradient(45deg, #ff1493, #9932cc, #4169e1) !important;
          color: white !important;
          border: 2px solid #fff !important;
          font-weight: bold !important;
          text-shadow: 0 0 5px rgba(255,255,255,0.8) !important;
          animation: cosmicGlow 2s ease-in-out infinite alternate !important;
        \`;
        
        // Add glow animation if not exists
        if (!document.querySelector('#cosmicGlowStyle')) {
          const style = document.createElement('style');
          style.id = 'cosmicGlowStyle';
          style.innerHTML = \`
            @keyframes cosmicGlow {
              0% { box-shadow: 0 0 5px #ff1493; }
              100% { box-shadow: 0 0 15px #ff1493, 0 0 25px #9932cc; }
            }
          \`;
          document.head.appendChild(style);
        }
        
        // Add the tool to the toolbar
        toolbar.appendChild(cosmicTool);
        
        // Add click handler
        cosmicTool.addEventListener('click', () => selectTool(cosmicTool));
        
        console.log('ðŸŒŸ Cosmic Sand tool added to toolbar!');
      } else {
        console.error('Could not find toolbar element');
      }

      // ----------------------------------------------------------------------
      // PATCH getElementName TO INCLUDE COSMIC SAND
      // ----------------------------------------------------------------------
      getElementName = function(e) {
        if (e === window.COSMIC_SAND) return "Cosmic Sand";
        return window.cosmicSandOriginals.getElementName(e);
      };

      // ----------------------------------------------------------------------
      // PATCH getElementColor TO INCLUDE COSMIC SAND
      // ----------------------------------------------------------------------
      getElementColor = function(e) {
        if (e === window.COSMIC_SAND) {
          // Return bright pink color - no template literals in string
          return '#ff1493'; // Deep pink that should be very visible
        }
        return window.cosmicSandOriginals.getElementColor(e);
      };

      // ----------------------------------------------------------------------
      // PATCH placeElementAt TO HANDLE COSMIC SAND PLACEMENT
      // ----------------------------------------------------------------------
      placeElementAt = function(x, y, tool) {
        if (tool === window.COSMIC_SAND) {
          grid[y][x] = window.COSMIC_SAND;
          temp[y][x] = 25; // Slightly warm
          moved[y][x] = false;
          
          // Add sparkle color variation
          if (!colorVariations[y]) colorVariations[y] = [];
          colorVariations[y][x] = {
            r: 1.0, // Keep full red
            g: 0.3, // Reduce green 
            b: 0.6  // Medium blue for purple tint
          };
          return;
        }
        
        return window.cosmicSandOriginals.placeElementAt(x, y, tool);
      };

      // ----------------------------------------------------------------------
      // PATCH performSimulationStep TO ADD COSMIC SAND PHYSICS
      // ----------------------------------------------------------------------
      performSimulationStep = function() {
        // First, handle cosmic sand behavior
        for (let y = GRID_SIZE - 2; y >= 0; y--) {
          for (let x = 0; x < GRID_SIZE; x++) {
            if (grid[y][x] === window.COSMIC_SAND && !moved[y][x]) {
              const oldTemp = temp[y][x];
              
              // Cosmic sand falls like regular sand but with sparkles
              if (y + 1 < GRID_SIZE && grid[y + 1][x] === EMPTY && !moved[y + 1][x]) {
                // Fall straight down
                moveCell(x, y, x, y + 1, oldTemp, window.COSMIC_SAND);
              } else {
                // Try to fall diagonally
                let directions = [];
                if (x > 0 && y + 1 < GRID_SIZE && grid[y + 1][x - 1] === EMPTY && !moved[y + 1][x - 1]) {
                  directions.push([-1, 1]);
                }
                if (x < GRID_SIZE - 1 && y + 1 < GRID_SIZE && grid[y + 1][x + 1] === EMPTY && !moved[y + 1][x + 1]) {
                  directions.push([1, 1]);
                }
                
                if (directions.length > 0) {
                  const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                  moveCell(x, y, x + dx, y + dy, oldTemp, window.COSMIC_SAND);
                }
              }
              
              // Add magical sparkle effects
              if (Math.random() < 0.1) {
                // Randomly enhance nearby empty cells with sparkle variations
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && 
                        grid[ny][nx] === EMPTY && Math.random() < 0.05) {
                      if (!colorVariations[ny]) colorVariations[ny] = [];
                      colorVariations[ny][nx] = {
                        r: Math.random() * 50,
                        g: Math.random() * 50,
                        b: Math.random() * 50
                      };
                    }
                  }
                }
              }
            }
          }
        }
        
        // Call original simulation step for all other elements
        window.cosmicSandOriginals.performSimulationStep();
      };

      console.log("ðŸŒŸ Cosmic Sand Mod loaded successfully! âœ¨");
      console.log("Select the glowing 'Cosmic' tool to place magical cosmic sand!");
    })();`;

    const cosmicSandTerminateCode = `(function(){
      // Restore original functions
      if (window.cosmicSandOriginals) {
        getElementName = window.cosmicSandOriginals.getElementName;
        getElementColor = window.cosmicSandOriginals.getElementColor;
        placeElementAt = window.cosmicSandOriginals.placeElementAt;
        performSimulationStep = window.cosmicSandOriginals.performSimulationStep;
        delete window.cosmicSandOriginals;
      }
      
      // Remove from elementBaseColors
      if (window.COSMIC_SAND && elementBaseColors[window.COSMIC_SAND]) {
        delete elementBaseColors[window.COSMIC_SAND];
      }
      
      // Remove the tool from toolbar
      const cosmicTool = document.querySelector('.tool.cosmic-sand');
      if (cosmicTool) {
        cosmicTool.remove();
      }
      
      // Remove glow animation
      const glowStyle = document.querySelector('#cosmicGlowStyle');
      if (glowStyle) {
        glowStyle.remove();
      }
      
      // Clear all cosmic sand from grid
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === window.COSMIC_SAND) {
            grid[y][x] = EMPTY;
          }
        }
      }
      
      // Clean up global variable
      delete window.COSMIC_SAND;
      
      console.log("ðŸŒŸ Cosmic Sand Mod terminated âœ¨");
    })();`;

    modsList.push({
      id: 'cosmicSandMod',
      title: 'Cosmic Sand',
      description: 'Adds magical cosmic sand that glows, sparkles, and creates beautiful light effects when it falls!',
      gameVersion: '0.7.1c',
      code: cosmicSandModCode,
      terminateCode: cosmicSandTerminateCode,
      enabled: false
    });

    // Load mods from localStorage and merge with default mods
    function loadModsFromStorage() {
      try {
        const storedMods = localStorage.getItem('modsList');
        if (storedMods) {
          const parsedMods = JSON.parse(storedMods);
          
          // Store default mods before clearing
          const defaultMods = [...modsList];
          
          // Clear current modsList and add stored mods
          modsList.length = 0;
          parsedMods.forEach(mod => modsList.push(mod));
          
          // Add any default mods that aren't already present
          defaultMods.forEach(defaultMod => {
            const exists = modsList.find(mod => mod.id === defaultMod.id);
            if (!exists) {
              modsList.push(defaultMod);
            }
          });
          
          console.log(`Loaded ${modsList.length} mods from storage (including defaults)`);
        } else {
          console.log(`Using ${modsList.length} default mods`);
        }
      } catch (error) {
        console.error('Error loading mods from storage:', error);
      }
    }

    // Auto-enable all mods if auto-reload is enabled
    function autoEnableModsOnStartup() {
      const autoReload = localStorage.getItem('autoReloadMods');
      if (autoReload === 'true') { // Default to false - only enable if explicitly set
        console.log('Auto-reload enabled, enabling all compatible mods...');
        modsList.forEach(mod => {
          if (!mod.enabled && isModCompatible(mod)) {
            try {
              eval(mod.code);
              mod.enabled = true;
              console.log(`âœ… Auto-enabled mod: ${mod.title}`);
            } catch (error) {
              console.error(`âŒ Failed to auto-enable mod ${mod.title}:`, error);
            }
          }
        });
        // Save the updated enabled states
        localStorage.setItem('modsList', JSON.stringify(modsList));
      }
    }

    // Initialize mod system
    function initializeModSystem() {
      loadModsFromStorage();
      autoEnableModsOnStartup();
    }
    function isModCompatible(mod) {
      // Only allow mods from exact version match
      return mod.gameVersion === currentGameVersion;
    }
    function updateModListUI() {
      const container = document.getElementById('modListContainer');
      const noModsMessage = document.getElementById('noModsMessage');
      
      container.innerHTML = '';
      
      if (modsList.length === 0) {
        // Show no mods message
        if (noModsMessage) {
          noModsMessage.style.display = 'block';
        }
        return;
      } else {
        // Hide no mods message
        if (noModsMessage) {
          noModsMessage.style.display = 'none';
        }
      }
      
      modsList.forEach(mod => {
        const card = document.createElement('div');
        card.className = 'mod-card';
        
        // Add status classes for filtering
        if (mod.enabled) {
          card.classList.add('mod-enabled');
        }
        if (!isModCompatible(mod)) {
          card.classList.add('mod-incompatible');
        }
        
        // Card Header
        const header = document.createElement('div');
        header.className = 'mod-card-header';
        
        // Mod Icon
        const icon = document.createElement('div');
        icon.className = 'mod-card-icon';
        icon.textContent = mod.title.charAt(0).toUpperCase();
        header.appendChild(icon);
        
        // Mod Info
        const info = document.createElement('div');
        info.className = 'mod-card-info';
        
        const title = document.createElement('h3');
        title.textContent = mod.title;
        info.appendChild(title);
        
        const description = document.createElement('p');
        description.textContent = mod.description || 'No description provided';
        info.appendChild(description);
        
        header.appendChild(info);
        card.appendChild(header);
        
        // Meta Information
        const meta = document.createElement('div');
        meta.className = 'mod-card-meta';
        

        
        const gameVersionMeta = document.createElement('span');
        gameVersionMeta.className = 'mod-meta-item';
        gameVersionMeta.textContent = `Game: ${mod.gameVersion}`;
        if (!isModCompatible(mod)) {
          gameVersionMeta.style.color = '#f44336';
          gameVersionMeta.title = 'Incompatible with current game version';
        }
        meta.appendChild(gameVersionMeta);
        
        const statusMeta = document.createElement('span');
        statusMeta.className = 'mod-meta-item';
        statusMeta.textContent = mod.enabled ? 'ðŸŸ¢ Enabled' : 'ðŸ”´ Disabled';
        statusMeta.style.color = mod.enabled ? '#4caf50' : '#757575';
        meta.appendChild(statusMeta);
        
        card.appendChild(meta);
        
        // Actions
        const actions = document.createElement('div');
        actions.className = 'mod-card-actions';
        
        if (!mod.enabled) {
          const enableBtn = document.createElement('button');
          enableBtn.className = 'mod-action-btn';
          enableBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
            </svg>
            Enable
          `;
          enableBtn.addEventListener('click', () => {
            try {
              eval(mod.code);
              mod.enabled = true;
              localStorage.setItem('modsList', JSON.stringify(modsList));
              updateModListUI();
              updateInstalledModCount();
            } catch (e) {
              alert('Error executing mod: ' + e.message);
              console.error('Mod execution error:', e);
            }
          });
          actions.appendChild(enableBtn);
        } else {
          const disableBtn = document.createElement('button');
          disableBtn.className = 'mod-action-btn secondary';
          disableBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M14,19H18V5H14M6,19H10V5H6V19Z"/>
            </svg>
            Disable
          `;
          disableBtn.addEventListener('click', () => {
            if (mod.terminateCode) {
              try {
                eval(mod.terminateCode);
              } catch (e) {
                console.error('Error executing terminate code:', e);
              }
            }
            mod.enabled = false;
            localStorage.setItem('modsList', JSON.stringify(modsList));
            updateModListUI();
            updateInstalledModCount();
          });
          actions.appendChild(disableBtn);
        }
        
        const editBtn = document.createElement('button');
        editBtn.className = 'mod-action-btn secondary';
        editBtn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"/>
          </svg>
          Edit
        `;
        editBtn.addEventListener('click', () => {
          // Switch to create tab and populate with mod data
          const createTab = document.querySelector('[data-tab="create"].mod-tab-btn');
          if (createTab) {
            createTab.click();
            // Populate form with full mod code
            document.getElementById('newModCode').value = mod.code;
            // Update counters
            const lines = mod.code.split('\n').length;
            const chars = mod.code.length;
            document.getElementById('codeLineCount').textContent = `Lines: ${lines}`;
            document.getElementById('codeCharCount').textContent = `Characters: ${chars}`;
            // Remove the original mod (we'll save as new)
            const index = modsList.indexOf(mod);
            if (index > -1) {
              modsList.splice(index, 1);
              localStorage.setItem('modsList', JSON.stringify(modsList));
            }
          }
        });
        actions.appendChild(editBtn);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'mod-action-btn danger';
        deleteBtn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/>
          </svg>
          Delete
        `;
        deleteBtn.addEventListener('click', () => {
          if (confirm(`Are you sure you want to delete "${mod.title}"?`)) {
            // Disable mod if enabled
            if (mod.enabled && mod.terminateCode) {
              try {
                eval(mod.terminateCode);
              } catch (e) {
                console.error('Error executing terminate code:', e);
              }
            }
            // Remove from list
            const index = modsList.indexOf(mod);
            if (index > -1) {
              modsList.splice(index, 1);
              localStorage.setItem('modsList', JSON.stringify(modsList));
              updateModListUI();
              updateInstalledModCount();
            }
          }
        });
        actions.appendChild(deleteBtn);
        
        card.appendChild(actions);
        container.appendChild(card);
      });

    }
    
    // Enhanced Mod Manager System
    const modButton = document.getElementById('modButton');
    const modMenu = document.getElementById('modMenu');
    const closeModMenu = document.getElementById('closeModMenu');
    
    // Initialize Mod Manager
    function initializeModManager() {
      // Tab functionality
      const tabButtons = document.querySelectorAll('.mod-tab-btn');
      const tabContents = document.querySelectorAll('.mod-tab-content');
      
      tabButtons.forEach(btn => {
        btn.addEventListener('click', function() {
          const targetTab = this.getAttribute('data-tab');
          
          // Remove active class from all tabs and contents
          tabButtons.forEach(tb => tb.classList.remove('active'));
          tabContents.forEach(tc => tc.classList.remove('active'));
          
          // Add active class to clicked tab and content
          this.classList.add('active');
          const targetContent = document.querySelector(`[data-tab="${targetTab}"].mod-tab-content`);
          if (targetContent) {
            targetContent.classList.add('active');
          }
          
          // Special handling for different tabs
          if (targetTab === 'installed') {
            updateModListUI();
          } else if (targetTab === 'create') {
            resetCreateModForm();
          }
        });
      });
      
      // Code editor functionality
      const codeTextarea = document.getElementById('newModCode');
      const lineCountSpan = document.getElementById('codeLineCount');
      const charCountSpan = document.getElementById('codeCharCount');
      
      if (codeTextarea) {
        codeTextarea.addEventListener('input', function() {
          const lines = this.value.split('\n').length;
          const chars = this.value.length;
          if (lineCountSpan) lineCountSpan.textContent = `Lines: ${lines}`;
          if (charCountSpan) charCountSpan.textContent = `Characters: ${chars}`;
        });
      }
      
      // Search functionality
      const searchInput = document.getElementById('modSearchInput');
      const statusFilter = document.getElementById('modStatusFilter');
      
      if (searchInput) {
        searchInput.addEventListener('input', filterMods);
      }
      if (statusFilter) {
        statusFilter.addEventListener('change', filterMods);
      }
      
      // Button event handlers
      setupModManagerButtons();
      
      // Initial update
      updateModListUI();
      updateInstalledModCount();
    }
    
    function setupModManagerButtons() {
      // Create first mod button
      const createFirstModBtn = document.getElementById('createFirstMod');
      if (createFirstModBtn) {
        createFirstModBtn.addEventListener('click', function() {
          // Switch to create tab
          const createTab = document.querySelector('[data-tab="create"].mod-tab-btn');
          if (createTab) {
            createTab.click();
          }
        });
      }
      
      // Save new mod button
      const saveNewModButton = document.getElementById('saveNewModButton');
      if (saveNewModButton) {
        saveNewModButton.addEventListener('click', saveNewMod);
      }
      
      // Clear form button
      const clearFormBtn = document.getElementById('clearModForm');
      if (clearFormBtn) {
        clearFormBtn.addEventListener('click', resetCreateModForm);
      }
      
      // Code validation button
      const validateBtn = document.getElementById('validateModCode');
      if (validateBtn) {
        validateBtn.addEventListener('click', validateModCode);
      }
      
      // Code formatting button
      const formatBtn = document.getElementById('formatModCode');
      if (formatBtn) {
        formatBtn.addEventListener('click', formatModCode);
      }
      
      // Refresh mod list button
      const refreshBtn = document.getElementById('refreshModList');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', function() {
          updateModListUI();
          updateInstalledModCount();
        });
      }
      
      // Reset all mods button
      const resetAllBtn = document.getElementById('resetAllMods');
      if (resetAllBtn) {
        resetAllBtn.addEventListener('click', resetAllMods);
      }
    }
    
    function saveNewMod() {
      const code = document.getElementById('newModCode').value.trim();
      
      if (!code) {
        alert('Please enter the mod code!');
        return;
      }
      
      // Parse mod metadata from the code
      const forcedModInfo = parseForcedModInfo(code);
      
      if (!forcedModInfo) {
        alert('Invalid mod format! Mods must include window.forcedModInfo with id, title, description, and gameVersion.');
        return;
      }
      
      if (!forcedModInfo.id || !forcedModInfo.title || !forcedModInfo.description || !forcedModInfo.gameVersion) {
        alert('Mod metadata is incomplete! Please ensure the mod includes id, title, description, and gameVersion in window.forcedModInfo.');
        return;
      }
      
      // Check for duplicate mod IDs
      const existingMod = modsList.find(mod => mod.id === forcedModInfo.id);
      if (existingMod) {
        if (!confirm(`A mod with ID "${forcedModInfo.id}" already exists. Replace it?`)) {
          return;
        }
        // Remove the existing mod
        const index = modsList.indexOf(existingMod);
        modsList.splice(index, 1);
      }
      
      // Create mod object from parsed metadata
      const newMod = {
        id: forcedModInfo.id,
        title: forcedModInfo.title,
        description: forcedModInfo.description,
        gameVersion: forcedModInfo.gameVersion,
        code: code,
        terminateCode: '',
        enabled: false,
        createdAt: Date.now()
      };
      
      try {
        // Add to mods list
        modsList.push(newMod);
        
        // Save to localStorage
        localStorage.setItem('modsList', JSON.stringify(modsList));
        
        // Reset form and switch to installed tab
        resetCreateModForm();
        const installedTab = document.querySelector('[data-tab="installed"].mod-tab-btn');
        if (installedTab) {
          installedTab.click();
        }
        
        // Show success message
        alert(`Mod "${newMod.title}" added successfully!`);
        
      } catch (error) {
        console.error('Error saving mod:', error);
        alert('Error saving mod. Please try again.');
      }
    }
    
    function resetCreateModForm() {
      document.getElementById('newModCode').value = '';
      
      // Reset counters
      document.getElementById('codeLineCount').textContent = 'Lines: 0';
      document.getElementById('codeCharCount').textContent = 'Characters: 0';
    }
    
    function validateModCode() {
      const code = document.getElementById('newModCode').value.trim();
      if (!code) {
        alert('Please enter some code to validate.');
        return;
      }
      
      try {
        // Basic syntax check
        new Function(code);
        alert('âœ… Code syntax is valid!');
      } catch (error) {
        alert('âŒ Syntax Error: ' + error.message);
      }
    }
    
    function formatModCode() {
      const textarea = document.getElementById('newModCode');
      let code = textarea.value;
      
      // Basic formatting (add proper indentation)
      const lines = code.split('\n');
      let formatted = '';
      let indentLevel = 0;
      
      lines.forEach(line => {
        const trimmed = line.trim();
        
        // Decrease indent for closing braces
        if (trimmed.startsWith('}')) {
          indentLevel = Math.max(0, indentLevel - 1);
        }
        
        // Add current line with proper indentation
        formatted += '  '.repeat(indentLevel) + trimmed + '\n';
        
        // Increase indent for opening braces
        if (trimmed.endsWith('{')) {
          indentLevel++;
        }
      });
      
      textarea.value = formatted.trim();
      
      // Update counters
      const lines_count = formatted.split('\n').length;
      const chars = formatted.length;
      document.getElementById('codeLineCount').textContent = `Lines: ${lines_count}`;
      document.getElementById('codeCharCount').textContent = `Characters: ${chars}`;
    }
    
    function filterMods() {
      const searchTerm = document.getElementById('modSearchInput').value.toLowerCase();
      const statusFilter = document.getElementById('modStatusFilter').value;
      
      const modCards = document.querySelectorAll('.mod-card');
      
      modCards.forEach(card => {
        const title = card.querySelector('.mod-card-info h3').textContent.toLowerCase();
        const description = card.querySelector('.mod-card-info p').textContent.toLowerCase();
        const matchesSearch = title.includes(searchTerm) || description.includes(searchTerm);
        
        // Get mod status from data attribute or class
        const isEnabled = card.classList.contains('mod-enabled');
        const isIncompatible = card.classList.contains('mod-incompatible');
        
        let matchesStatus = true;
        switch (statusFilter) {
          case 'enabled':
            matchesStatus = isEnabled;
            break;
          case 'disabled':
            matchesStatus = !isEnabled && !isIncompatible;
            break;
          case 'incompatible':
            matchesStatus = isIncompatible;
            break;
        }
        
        card.style.display = (matchesSearch && matchesStatus) ? 'block' : 'none';
      });
    }
    
    function updateInstalledModCount() {
      const countSpan = document.getElementById('installedModCount');
      if (countSpan) {
        countSpan.textContent = modsList.length;
      }
    }
    
    function resetAllMods() {
      if (confirm('Are you sure you want to remove ALL mods? This action cannot be undone.')) {
        modsList.length = 0;
        localStorage.removeItem('modsList');
        updateModListUI();
        updateInstalledModCount();
        alert('All mods have been removed.');
      }
    }
    
    // Window click handler
    window.addEventListener('click', function(event) {
      if (event.target == modMenu) {
        modMenu.style.display = 'none';
      }
    });
    
    // Initialize mod manager button on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize the mod system first
      initializeModSystem();
      
      const modButton = document.getElementById('modButton');
      const mobileModButton = document.getElementById('mobileModButton');
      const modMenu = document.getElementById('modMenu');
      const closeModMenu = document.getElementById('closeModMenu');
      
      // Main mod button
      if (modButton) {
        modButton.addEventListener('click', function() {
          modMenu.style.display = 'block';
          initializeModManager();
        });
      }
      
      // Mobile mod button
      if (mobileModButton) {
        mobileModButton.addEventListener('click', function() {
          modMenu.style.display = 'block';
          initializeModManager();
        });
      }
      
      // Close button
      if (closeModMenu) {
        closeModMenu.addEventListener('click', function() {
          modMenu.style.display = 'none';
        });
      }
    });
    
    const optionsButton = document.getElementById('optionsButton');
    const optionsModal = document.getElementById('optionsModal');
    const closeOptionsModal = document.getElementById('closeOptionsModal');
    optionsButton.addEventListener('click', function() {
      optionsModal.style.display = 'block';
      // Initialize dynamic lighting select with current state
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.value = window.isDynamicLightingEnabled ? '1' : '0';
      }
      initializeOptionsModal();
    });

    // Initialize options modal with tab functionality
    function initializeOptionsModal() {
      // Set up tab switching
      const tabButtons = document.querySelectorAll('.options-tab-btn');
      const tabContents = document.querySelectorAll('.options-tab-content');

      tabButtons.forEach(btn => {
        btn.addEventListener('click', function() {
          const targetTab = this.getAttribute('data-tab');
          
          // Remove active class from all tabs and contents
          tabButtons.forEach(tb => tb.classList.remove('active'));
          tabContents.forEach(tc => tc.classList.remove('active'));
          
          // Add active class to clicked tab
          this.classList.add('active');
          
          // Show corresponding content
          const targetContent = document.querySelector(`[data-tab="${targetTab}"].options-tab-content`);
          if (targetContent) {
            targetContent.classList.add('active');
          }
        });
      });

      // Convert toggle switches to work with existing functionality
      setupToggleSwitches();
      updateSelectValues();
      setupGridSizeWarning();
    }

    function setupToggleSwitches() {
      // HUD Toggle
      const hudToggle = document.getElementById('hudToggle');
      if (hudToggle && hudToggle.type === 'checkbox') {
        const isMobile = window.innerWidth <= 1024;
        const defaultValue = isMobile ? '0' : '1'; // Default to hidden on mobile, visible on desktop
        const savedHudValue = localStorage.getItem('hudToggle') || defaultValue;
        hudToggle.checked = savedHudValue === '1';
        
        // Apply initial state
        const hud = document.getElementById('hud');
        if (hud) {
          hud.style.display = hudToggle.checked ? 'block' : 'none';
        }
        
        hudToggle.addEventListener('change', function() {
          const value = this.checked ? '1' : '0';
          localStorage.setItem('hudToggle', value);
          // Update HUD display
          if (hud) {
            hud.style.display = this.checked ? 'block' : 'none';
          }
        });
      }

      // Variated Colors Toggle
      const colorsToggle = document.getElementById('variatedColorsToggle');
      if (colorsToggle && colorsToggle.type === 'checkbox') {
        const savedColorsValue = localStorage.getItem('variatedColorsToggle') || '1';
        colorsToggle.checked = savedColorsValue === '1';
        
        colorsToggle.addEventListener('change', function() {
          const value = this.checked ? '1' : '0';
          localStorage.setItem('variatedColorsToggle', value);
        });
      }

      // Pop-out Mode Toggle
      const popOutToggle = document.getElementById('popOutMode');
      if (popOutToggle && popOutToggle.type === 'checkbox') {
        const savedPopOutValue = localStorage.getItem('popOutMode') || '0';
        popOutToggle.checked = savedPopOutValue === '1';
        
        popOutToggle.addEventListener('change', function() {
          const value = this.checked ? '1' : '0';
          localStorage.setItem('popOutMode', value);
        });
      }

      // DSPLE Toggle
      const dspleToggle = document.getElementById('dspleToggle');
      if (dspleToggle && dspleToggle.type === 'checkbox') {
        const savedDspleValue = localStorage.getItem('dspleToggle') || '0';
        dspleToggle.checked = savedDspleValue === '1';
        
        dspleToggle.addEventListener('change', function() {
          const value = this.checked ? '1' : '0';
          localStorage.setItem('dspleToggle', value);
        });
      }

      // DabyFPS Toggle
      const dabyFpsToggle = document.getElementById('setting-dabyfps');
      if (dabyFpsToggle && dabyFpsToggle.type === 'checkbox') {
        const savedDabyFpsValue = localStorage.getItem('setting-dabyfps') || 'false';
        dabyFpsToggle.checked = savedDabyFpsValue === 'true';
        
        dabyFpsToggle.addEventListener('change', function() {
          const value = this.checked ? 'true' : 'false';
          localStorage.setItem('setting-dabyfps', value);
        });
      }

      // Auto-reload Mods Toggle
      const autoReloadToggle = document.getElementById('autoReloadMods');
      if (autoReloadToggle && autoReloadToggle.type === 'checkbox') {
        const savedAutoReloadValue = localStorage.getItem('autoReloadMods') || 'true';
        autoReloadToggle.checked = savedAutoReloadValue === 'true';
        
        autoReloadToggle.addEventListener('change', function() {
          const value = this.checked ? 'true' : 'false';
          localStorage.setItem('autoReloadMods', value);
          console.log(`Auto-reload mods: ${value}`);
        });
      }

      // Mod Safe Mode Toggle
      const modSafeModeToggle = document.getElementById('modSafeMode');
      if (modSafeModeToggle && modSafeModeToggle.type === 'checkbox') {
        const savedSafeModeValue = localStorage.getItem('modSafeMode') || 'true';
        modSafeModeToggle.checked = savedSafeModeValue === 'true';
        
        modSafeModeToggle.addEventListener('change', function() {
          const value = this.checked ? 'true' : 'false';
          localStorage.setItem('modSafeMode', value);
          console.log(`Mod safe mode: ${value}`);
        });
      }

      // Mod Debug Mode Toggle
      const modDebugModeToggle = document.getElementById('modDebugMode');
      if (modDebugModeToggle && modDebugModeToggle.type === 'checkbox') {
        const savedDebugModeValue = localStorage.getItem('modDebugMode') || 'false';
        modDebugModeToggle.checked = savedDebugModeValue === 'true';
        
        modDebugModeToggle.addEventListener('change', function() {
          const value = this.checked ? 'true' : 'false';
          localStorage.setItem('modDebugMode', value);
          console.log(`Mod debug mode: ${value}`);
        });
      }
    }

    function updateSelectValues() {
      // Update display values for selects that are still selects
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      const fontSelect = document.getElementById('fontStyleSelect');
      const uiModeSelect = document.getElementById('uiModeSelect');
      const fpsCapSelect = document.getElementById('setting-fps-cap');

      // Load saved values
      if (localStorage.getItem('stageSizeSelect')) {
        stageSizeSelect.value = localStorage.getItem('stageSizeSelect');
      } else {
        // Default to current GRID_SIZE if no saved preference
        stageSizeSelect.value = GRID_SIZE.toString();
      }
      if (localStorage.getItem('fontStyleSelect')) {
        fontSelect.value = localStorage.getItem('fontStyleSelect');
      }
      if (localStorage.getItem('uiModeSelect')) {
        uiModeSelect.value = localStorage.getItem('uiModeSelect');
      }
      if (localStorage.getItem('setting-fps-cap')) {
        fpsCapSelect.value = localStorage.getItem('setting-fps-cap');
      }

      // Add change listeners to save values
      stageSizeSelect.addEventListener('change', function() {
        localStorage.setItem('stageSizeSelect', this.value);
        checkGridSizeWarning(this.value);
        checkApplyButton();
      });
      
      fontSelect.addEventListener('change', function() {
        localStorage.setItem('fontStyleSelect', this.value);
      });
      
      uiModeSelect.addEventListener('change', function() {
        localStorage.setItem('uiModeSelect', this.value);
      });
      
      fpsCapSelect.addEventListener('change', function() {
        localStorage.setItem('setting-fps-cap', this.value);
      });
    }

    // Global function to check if apply button should be shown
    function checkApplyButton() {
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      if (!stageSizeSelect) return;
      
      const currentSize = parseInt(stageSizeSelect.value);
      const actualSize = GRID_SIZE;
      const applyButton = document.getElementById('applyOptionsButton');
      
      if (currentSize !== actualSize && applyButton) {
        applyButton.style.display = 'block';
      } else if (applyButton) {
        applyButton.style.display = 'none';
      }
    }

    function setupGridSizeWarning() {
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      const largeGridWarning = document.getElementById('largeGridWarning');
      
      function checkGridSizeWarning(value) {
        const size = parseInt(value);
        if (size > 100 && largeGridWarning) {
          largeGridWarning.classList.add('show');
        } else if (largeGridWarning) {
          largeGridWarning.classList.remove('show');
        }
      }

      // Initial check
      if (stageSizeSelect) {
        checkGridSizeWarning(stageSizeSelect.value);
        checkApplyButton();
      }
    }
    closeOptionsModal.addEventListener('click', function() {
      optionsModal.style.display = 'none';
      // Return to main menu if game hasn't started
      const mainContainer = document.getElementById('mainContainer');
      const mainMenuModal = document.getElementById('mainMenuModal');
      if (mainContainer && mainContainer.style.display === 'none' && mainMenuModal) {
        mainMenuModal.style.display = 'block';
      }
    });
    window.addEventListener('click', function(event) {
      if (event.target == optionsModal) {
        optionsModal.style.display = 'none';
        // Return to main menu if game hasn't started
        const mainContainer = document.getElementById('mainContainer');
        const mainMenuModal = document.getElementById('mainMenuModal');
        if (mainContainer && mainContainer.style.display === 'none' && mainMenuModal) {
          mainMenuModal.style.display = 'block';
        }
      }
    });
    // Safely add event listener with error handling
    const applyOptionsButton = document.getElementById('applyOptionsButton');
    if (applyOptionsButton) {
      applyOptionsButton.addEventListener('click', function() {
        try {
          const sizeSelect = document.getElementById('stageSizeSelect');
          if (!sizeSelect) return;
          
          const size = parseInt(sizeSelect.value);
          if (isNaN(size) || size < 10 || size > 200) {
            console.error('Invalid grid size:', size);
            return;
          }
          
          // Reset game state variables before changing grid size
          lastFrameTime = 0;
          stepAccumulator = 0;
          
          // Initialize the grid with the new size
          initGrid(size);
          
          // Hide the modal
          if (optionsModal) optionsModal.style.display = 'none';
        } catch (error) {
          console.error('Error applying options:', error);
        }
      });
    }
    const saveLoadButton = document.getElementById('saveLoadButton');
    const saveLoadModal = document.getElementById('saveLoadModal');
    const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');
    saveLoadButton.addEventListener('click', function() {
      openSaveLoadModal();
    });
    closeSaveLoadModal.addEventListener('click', function() {
      saveLoadModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == saveLoadModal) {
        saveLoadModal.style.display = 'none';
      }
    });
    
    // Community menu functionality - removed since the community button was removed
    // const communityButton = document.getElementById('communityButton');
    // const communityModal = document.getElementById('communityModal');
    // const closeCommunityModal = document.getElementById('closeCommunityModal');
    // if (communityButton) {
    //   communityButton.addEventListener('click', function() {
    //     communityModal.style.display = 'block';
    //     updateCommunitySavesList();
    //   });
    // }
    // if (closeCommunityModal) {
    //   closeCommunityModal.addEventListener('click', function() {
    //     communityModal.style.display = 'none';
    //   });
    // }
    // Remove event listener for community modal since it was removed
    // window.addEventListener('click', function(event) {
    //   if (event.target == communityModal) {
    //     communityModal.style.display = 'none';
    //   }
    // });
    function getSaveIndex() {
      const index = localStorage.getItem("dbr_save_index");
      return index ? JSON.parse(index) : [];
    }
    function setSaveIndex(index) {
      localStorage.setItem("dbr_save_index", JSON.stringify(index));
    }
    function showSaveMessage(message, type = 'success') {
      const messageEl = document.getElementById('saveMessage');
      if (!messageEl) return;
      
      messageEl.className = `save-message ${type}`;
      messageEl.textContent = message;
      messageEl.style.display = 'block';
      
      // Auto-hide after 4 seconds
      setTimeout(() => {
        messageEl.style.display = 'none';
      }, 4000);
    }

    function saveGame() {
      const title = document.getElementById('saveTitle').value.trim();
      const description = document.getElementById('saveDescription').value.trim();
      
      if (!title) {
        showSaveMessage('Please enter a save name!', 'error');
        return;
      }
      
      try {
        showSaveMessage('Saving game...', 'warning');
        
        const saveData = {
          // Save metadata
          title: title,
          description: description || 'No description',
          version: window.currentGameVersion || "0.7.1c",
          timestamp: Date.now(),
          
          // Game state data
          GRID_SIZE,
          grid, temp, vaporLife, cloudLife, fireLife, smokeLife, burningWoodTime, wheatHeight, wheatMaxHeight,
          seedGrowthTime, rootLife, sparkLife, sparkTimer, smokeMaxLife, cloudMaxLife, branchLevel,
          branchLen, branchMaxArr, branchSubCount, branchDirX, branchDirY, oakTreeGrowthTime, oakTreeHeight,
          oakTreeMaxHeight, oakTreeRootTimer, oakTreeRootDepth, oakTreeRootMax, grassStage, burningGasTime,
          chargedStateTime, colorVariations
        };
        
        const saveString = JSON.stringify(saveData);
        const sizeMB = (saveString.length / 1024 / 1024).toFixed(2);
        
        // Check localStorage quota (typically 5-10MB)
        if (saveString.length > 4 * 1024 * 1024) { // 4MB limit
          showSaveMessage(`Save too large (${sizeMB}MB). Try using a smaller grid size or clearing some elements.`, 'error');
          return;
        }
        
        const key = "dbr_save_" + Date.now();
        
        // Use setTimeout to make save non-blocking for large saves
        setTimeout(() => {
          try {
            localStorage.setItem(key, saveString);
            let index = getSaveIndex();
            index.push({ 
              key, 
              title, 
              description: description || 'No description', 
              version: window.currentGameVersion || "0.7.1c",
              isLegacy: false,
              timestamp: Date.now() 
            });
            setSaveIndex(index);
            
            // Clear form
            document.getElementById('saveTitle').value = '';
            document.getElementById('saveDescription').value = '';
            
            // Show success message
            showSaveMessage(`Game saved as "${title}" (${sizeMB}MB)`, 'success');
            
            // Update the advanced saves list if we're on the load tab
            updateAdvancedSavesList();
            updateSavedGamesList(); // Keep compatibility with old list
            
          } catch (error) {
            console.error('Error saving game:', error);
            if (error.name === 'QuotaExceededError') {
              showSaveMessage('Storage quota exceeded. Try deleting old saves or using a smaller grid.', 'error');
            } else {
              showSaveMessage('Error saving game. Please try again.', 'error');
            }
          }
        }, 100);
        
      } catch (error) {
        console.error('Error preparing save:', error);
        showSaveMessage('Error preparing save data. Please try again.', 'error');
      }
    }
    document.getElementById('saveGameButton').addEventListener('click', saveGame);
    function updateSavedGamesList() {
    const container = document.getElementById('savedGamesList');
    container.innerHTML = "";
    const index = getSaveIndex();
    
    index.forEach(item => {
      // Create a card for each saved game
      const card = document.createElement('div');
      card.className = 'save-game-card';
      
      // Create the preview section
      const previewContainer = document.createElement('div');
      previewContainer.className = 'save-preview';
      
      // Create the actual preview grid
      const previewGrid = document.createElement('div');
      previewGrid.className = 'preview-grid';
      
      // Try to load the save data to create a preview
      const saveData = localStorage.getItem(item.key);
      if (saveData) {
        try {
          const save = JSON.parse(saveData);
          
          // We'll show a smaller version of the grid (20x20)
          const previewSize = 20;
          previewGrid.style.gridTemplateColumns = `repeat(${previewSize}, 1fr)`;
          previewGrid.style.gridTemplateRows = `repeat(${previewSize}, 1fr)`;
          
          // Figure out how to scale down the full grid to our preview size
          const scaleFactor = save.GRID_SIZE / previewSize;
          
          // Create the tiny preview cells
          for (let y = 0; y < previewSize; y++) {
            for (let x = 0; x < previewSize; x++) {
              // Map preview coordinates to the actual saved grid
              const gridX = Math.floor(x * scaleFactor);
              const gridY = Math.floor(y * scaleFactor);
              
              // Create a cell
              const cell = document.createElement('div');
              
              // Color the cell based on what's in the saved grid
              if (gridX < save.GRID_SIZE && gridY < save.GRID_SIZE) {
                const element = save.grid[gridY][gridX];
                cell.style.backgroundColor = getElementColor(element);
              } else {
                cell.style.backgroundColor = '#000'; // Default black
              }
              
              previewGrid.appendChild(cell);
            }
          }
        } catch (e) {
          console.error("Error creating preview:", e);
        }
      }
      
      // Add the preview grid to the container
      previewContainer.appendChild(previewGrid);
      card.appendChild(previewContainer);
      
      // Create the info section with title and description
      const infoDiv = document.createElement('div');
      infoDiv.className = 'save-info';
      
      const titleDiv = document.createElement('div');
      titleDiv.className = 'save-title';
      titleDiv.textContent = item.title;
      
      const descDiv = document.createElement('div');
      descDiv.className = 'save-description';
      descDiv.textContent = item.description;
      
      infoDiv.appendChild(titleDiv);
      infoDiv.appendChild(descDiv);
      card.appendChild(infoDiv);
      
      // Create the buttons
      const buttonsDiv = document.createElement('div');
      buttonsDiv.className = 'save-buttons';
      
      const loadBtn = document.createElement('button');
      loadBtn.className = 'load-button';
      loadBtn.textContent = "Load";
      loadBtn.addEventListener('click', () => {
        // Use the existing load functionality
        const data = localStorage.getItem(item.key);
        if (data) {
          const save = JSON.parse(data);
          GRID_SIZE = save.GRID_SIZE;
          initGrid(GRID_SIZE);
          grid = save.grid;
          temp = save.temp;
          vaporLife = save.vaporLife;
          cloudLife = save.cloudLife;
          fireLife = save.fireLife;
          smokeLife = save.smokeLife;
          burningWoodTime = save.burningWoodTime;
          wheatHeight = save.wheatHeight;
          wheatMaxHeight = save.wheatMaxHeight;
          seedGrowthTime = save.seedGrowthTime;
          rootLife = save.rootLife;
          sparkLife = save.sparkLife;
          sparkTimer = save.sparkTimer;
          smokeMaxLife = save.smokeMaxLife;
          cloudMaxLife = save.cloudMaxLife;
          branchLevel = save.branchLevel;
          branchLen = save.branchLen;
          branchMaxArr = save.branchMaxArr;
          branchSubCount = save.branchSubCount;
          branchDirX = save.branchDirX;
          branchDirY = save.branchDirY;
          oakTreeGrowthTime = save.oakTreeGrowthTime;
          oakTreeHeight = save.oakTreeHeight;
          oakTreeMaxHeight = save.oakTreeMaxHeight;
          oakTreeRootTimer = save.oakTreeRootTimer;
          oakTreeRootDepth = save.oakTreeRootDepth;
          oakTreeRootMax = save.oakTreeRootMax;
          grassStage = save.grassStage;
          burningGasTime = save.burningGasTime;
          chargedStateTime = save.chargedStateTime;
          
          // Load color variations if they exist in the save data
          if (save.colorVariations) {
            colorVariations = save.colorVariations;
          } else {
            // Initialize color variations for existing elements if loading an old save
            colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            
            // Generate variations for existing elements
            const variation = 0.05;
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                if (grid[y][x] !== EMPTY) {
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                }
              }
            }
          }
          
          renderGrid();
        }
      });
      
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener('click', () => {
        // Use the existing delete functionality
        let index = getSaveIndex();
        index = index.filter(i => i.key !== item.key);
        setSaveIndex(index);
        localStorage.removeItem(item.key);
        updateSavedGamesList();
      });
      
      const exportBtn = document.createElement('button');
      exportBtn.textContent = "Export";
      exportBtn.addEventListener('click', () => {
        // Use the existing export functionality
        const data = localStorage.getItem(item.key);
        if (data) {
          const blob = new Blob([data], {type: "application/json"});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = item.title + ".dbr";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      });
      
      buttonsDiv.appendChild(loadBtn);
      buttonsDiv.appendChild(deleteBtn);
      buttonsDiv.appendChild(exportBtn);
      card.appendChild(buttonsDiv);
      
      // Add the complete card to the container
      container.appendChild(card);
    });
  }
    document.getElementById('importSaveButton').addEventListener('click', () => {
      const fileInput = document.getElementById('importFileInput');
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const save = JSON.parse(e.target.result);
          const key = "dbr_save_" + Date.now();
          localStorage.setItem(key, JSON.stringify(save));
          
          // Extract metadata from save file or mark as legacy
          let title, description, version, isLegacy = false;
          
          if (save.title && save.description && save.version) {
            // Save has proper metadata
            title = save.title;
            description = save.description;
            version = save.version;
          } else {
            // Legacy save from before version 0.7
            title = file.name.replace('.dbr', '');
            description = "Legacy save made before version 0.7";
            version = "Legacy (pre-0.7)";
            isLegacy = true;
          }
          
          let index = getSaveIndex();
          index.push({ 
            key, 
            title: title,
            description: description,
            version: version,
            isLegacy: isLegacy,
            timestamp: Date.now() 
          });
          setSaveIndex(index);
          updateSavedGamesList();
        } catch (err) {
          console.error("Import error", err);
        }
      };
      reader.readAsText(file);
    });

    // New Save/Load Modal Functionality
    function initializeAdvancedSaveLoadModal() {
      console.log('Initializing advanced save/load modal...');
      const modal = document.getElementById('saveLoadModal');
      if (!modal) {
        console.error('Save/Load modal not found during initialization');
        return;
      }

      // Set up tab switching with more robust event handling
      function setupTabSwitching() {
        const tabButtons = modal.querySelectorAll('.tab-btn');
        const tabContents = modal.querySelectorAll('.tab-content');
        
        console.log('Found tab buttons:', tabButtons.length);
        console.log('Found tab contents:', tabContents.length);

        // Remove any existing listeners first
        tabButtons.forEach(btn => {
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
        });

        // Get fresh references after cloning
        const freshTabButtons = modal.querySelectorAll('.tab-btn');
        const freshTabContents = modal.querySelectorAll('.tab-content');

        // Add click handlers to fresh buttons
        freshTabButtons.forEach(btn => {
          btn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetTab = this.getAttribute('data-tab');
            console.log('Tab clicked:', targetTab);
            
            // Remove active class from all tabs and contents
            freshTabButtons.forEach(tb => tb.classList.remove('active'));
            freshTabContents.forEach(tc => tc.classList.remove('active'));
            
            // Add active class to clicked tab
            this.classList.add('active');
            
            // Find and activate corresponding content
            const targetContent = modal.querySelector(`[data-tab="${targetTab}"].tab-content`);
            if (targetContent) {
              targetContent.classList.add('active');
              console.log('Activated tab content for:', targetTab);
            } else {
              console.error('Tab content not found for:', targetTab);
            }
            
            // Update modal based on current tab
            if (targetTab === 'save') {
              setTimeout(() => {
                updateSavePreview();
                updateSaveInfo();
              }, 100);
            } else if (targetTab === 'load') {
              setTimeout(() => {
                updateAdvancedSavesList();
              }, 100);
            }
          });
        });
      }

      // Call setup function
      setupTabSwitching();

      // Set up other functionality with error checking
      function setupOtherFeatures() {
        const importDropZone = document.getElementById('importDropZone');
        const browseFileBtn = document.getElementById('browseFileBtn');
        const refreshSavesBtn = document.getElementById('refreshSaves');
        const deleteAllSavesBtn = document.getElementById('deleteAllSaves');

        // Browse file button
        if (browseFileBtn) {
          browseFileBtn.addEventListener('click', () => {
            document.getElementById('importFileInput').click();
          });
        }

        // Drag and drop functionality
        if (importDropZone) {
          importDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            importDropZone.classList.add('dragover');
          });

          importDropZone.addEventListener('dragleave', () => {
            importDropZone.classList.remove('dragover');
          });

          importDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            importDropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
              handleFileImport(files[0]);
            }
          });

          importDropZone.addEventListener('click', () => {
            document.getElementById('importFileInput').click();
          });
        }

        // File input change
        const fileInput = document.getElementById('importFileInput');
        if (fileInput) {
          fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
              handleFileImport(e.target.files[0]);
            }
          });
        }

        // Refresh saves button
        if (refreshSavesBtn) {
          refreshSavesBtn.addEventListener('click', updateAdvancedSavesList);
        }

        // Delete all saves button
        if (deleteAllSavesBtn) {
          deleteAllSavesBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to delete ALL saved games? This cannot be undone!')) {
              const index = getSaveIndex();
              index.forEach(item => localStorage.removeItem(item.key));
              setSaveIndex([]);
              updateAdvancedSavesList();
            }
          });
        }
      }

      setupOtherFeatures();
      console.log('Advanced save/load modal initialization complete');
    }

    function updateSavePreview() {
      const canvas = document.getElementById('savePreviewCanvas');
      if (!canvas) {
        console.error('Save preview canvas not found');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      const previewSize = 200;
      canvas.width = previewSize;
      canvas.height = previewSize;
      
      // Clear canvas with dark background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, previewSize, previewSize);
      
      // Check if grid exists and has data
      if (typeof grid === 'undefined' || !grid || typeof GRID_SIZE === 'undefined') {
        // Show placeholder text
        ctx.fillStyle = '#666666';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No Game Data', previewSize/2, previewSize/2);
        return;
      }
      
      // Calculate scale factor
      const scale = previewSize / GRID_SIZE;
      
      // Draw preview of current grid
      let hasContent = false;
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          if (element !== EMPTY && element !== 0) {
            hasContent = true;
            ctx.fillStyle = getElementColor(element);
            ctx.fillRect(Math.floor(x * scale), Math.floor(y * scale), Math.ceil(scale), Math.ceil(scale));
          }
        }
      }
      
      // If no content, show empty state message
      if (!hasContent) {
        ctx.fillStyle = '#666666';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Empty Canvas', previewSize/2, previewSize/2);
      }
    }

    function updateSaveInfo() {
      document.getElementById('currentGridSize').textContent = `${GRID_SIZE}x${GRID_SIZE}`;
      document.getElementById('temperatureEnabled').textContent = 'Enabled'; // Assuming temperature is always enabled
      document.getElementById('saveTimestamp').textContent = new Date().toLocaleString();
    }

    function updateAdvancedSavesList() {
      const container = document.getElementById('savedGamesList');
      const noSavesMessage = document.getElementById('noSavesMessage');
      const index = getSaveIndex();
      
      container.innerHTML = '';
      
      if (index.length === 0) {
        noSavesMessage.style.display = 'block';
        return;
      }
      
      noSavesMessage.style.display = 'none';
      
      index.forEach(item => {
        const card = document.createElement('div');
        card.className = 'save-card';
        
        // Create preview
        const preview = document.createElement('div');
        preview.className = 'save-preview';
        
        try {
          const saveData = localStorage.getItem(item.key);
          if (saveData) {
            const save = JSON.parse(saveData);
            const canvas = document.createElement('canvas');
            
            // Make it square with reasonable size
            const canvasSize = 120;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            const ctx = canvas.getContext('2d');
            
            // Clear with black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
            
            // Calculate scale to fit the grid in the square canvas
            const scale = canvasSize / save.GRID_SIZE;
            
            for (let y = 0; y < save.GRID_SIZE; y++) {
              for (let x = 0; x < save.GRID_SIZE; x++) {
                const element = save.grid[y][x];
                if (element !== EMPTY && element !== 0) {
                  ctx.fillStyle = getElementColor(element);
                  ctx.fillRect(
                    Math.floor(x * scale), 
                    Math.floor(y * scale), 
                    Math.ceil(scale), 
                    Math.ceil(scale)
                  );
                }
              }
            }
            
            preview.appendChild(canvas);
          } else {
            preview.innerHTML = '<div class="save-preview-placeholder">ðŸ“</div>';
          }
        } catch (e) {
          preview.innerHTML = '<div class="save-preview-placeholder">âŒ</div>';
        }
        
        card.appendChild(preview);
        
        // Create details section
        const details = document.createElement('div');
        details.className = 'save-details';
        
        const title = document.createElement('h4');
        title.className = 'save-title';
        title.textContent = item.title;
        
        const description = document.createElement('p');
        description.className = 'save-description';
        description.textContent = item.description || 'No description';
        
        const meta = document.createElement('div');
        meta.className = 'save-meta';
        
        const date = document.createElement('span');
        date.className = 'save-date';
        date.textContent = new Date(item.timestamp).toLocaleDateString();
        
        // Create version element if available
        let versionElement = null;
        if (item.version) {
          versionElement = document.createElement('span');
          versionElement.className = 'save-version';
          
          const currentVersion = window.currentGameVersion || "0.7.1c";
          const isVersionMismatch = item.version !== currentVersion && !item.isLegacy;
          
          if (item.isLegacy) {
            versionElement.textContent = `${item.version}`;
            versionElement.style.color = '#ff9800';
            versionElement.style.fontWeight = 'bold';
            versionElement.title = 'Legacy save from before version 0.7';
          } else if (isVersionMismatch) {
            versionElement.textContent = `v${item.version}`;
            versionElement.style.color = '#f44336';
            versionElement.style.fontWeight = 'bold';
            versionElement.title = `Version mismatch! This save was made with v${item.version}, but you're running v${currentVersion}`;
          } else {
            versionElement.textContent = `v${item.version}`;
            versionElement.style.color = '#4caf50';
          }
        }
        
        const actions = document.createElement('div');
        actions.className = 'save-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.className = 'save-action-btn load';
        loadBtn.textContent = 'Load';
        
        // Add version warning for load button
        loadBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          
          const currentVersion = window.currentGameVersion || "0.7.1c";
          const isVersionMismatch = item.version && item.version !== currentVersion && !item.isLegacy;
          
          if (isVersionMismatch) {
            const confirmed = confirm(
              `âš ï¸ VERSION MISMATCH WARNING âš ï¸\n\n` +
              `This save was created with version ${item.version}, but you're running version ${currentVersion}.\n\n` +
              `Loading this save may cause:\n` +
              `â€¢ Unexpected behavior\n` +
              `â€¢ Missing elements\n` +
              `â€¢ Game crashes\n\n` +
              `Do you want to continue loading this save anyway?`
            );
            if (!confirmed) return;
          } else if (item.isLegacy) {
            const confirmed = confirm(
              `âš ï¸ LEGACY SAVE WARNING âš ï¸\n\n` +
              `This is a legacy save from before version 0.7.\n\n` +
              `Loading this save may cause:\n` +
              `â€¢ Missing metadata\n` +
              `â€¢ Compatibility issues\n\n` +
              `Do you want to continue loading this legacy save?`
            );
            if (!confirmed) return;
          }
          
          loadSaveGame(item.key);
          const saveLoadModal = document.getElementById('saveLoadModal');
          if (saveLoadModal) saveLoadModal.style.display = 'none';
        });
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'save-action-btn delete';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm(`Delete save "${item.title}"?`)) {
            let index = getSaveIndex();
            index = index.filter(i => i.key !== item.key);
            setSaveIndex(index);
            localStorage.removeItem(item.key);
            updateAdvancedSavesList();
          }
        });
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'save-action-btn';
        exportBtn.textContent = 'Export';
        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          exportSaveGame(item);
        });
        
        actions.appendChild(loadBtn);
        actions.appendChild(deleteBtn);
        actions.appendChild(exportBtn);
        
        // Create first meta row with date and version
        const metaRow1 = document.createElement('div');
        metaRow1.className = 'save-meta-row';
        metaRow1.appendChild(date);
        if (versionElement) {
          metaRow1.appendChild(versionElement);
        }
        
        // Create second meta row with actions
        const metaRow2 = document.createElement('div');
        metaRow2.className = 'save-meta-row';
        metaRow2.appendChild(actions);
        
        meta.appendChild(metaRow1);
        meta.appendChild(metaRow2);
        
        details.appendChild(title);
        details.appendChild(description);
        details.appendChild(meta);
        
        card.appendChild(details);
        
        // Make entire card clickable to load
        card.addEventListener('click', () => {
          loadSaveGame(item.key);
          const saveLoadModal = document.getElementById('saveLoadModal');
          if (saveLoadModal) saveLoadModal.style.display = 'none';
        });
        
        container.appendChild(card);
      });
    }

    function loadSaveGame(key) {
      const data = localStorage.getItem(key);
      if (!data) return;
      
      try {
        const save = JSON.parse(data);
        GRID_SIZE = save.GRID_SIZE;
        initGrid(GRID_SIZE);
        grid = save.grid;
        temp = save.temp;
        vaporLife = save.vaporLife;
        cloudLife = save.cloudLife;
        fireLife = save.fireLife;
        smokeLife = save.smokeLife;
        burningWoodTime = save.burningWoodTime;
        wheatHeight = save.wheatHeight;
        wheatMaxHeight = save.wheatMaxHeight;
        seedGrowthTime = save.seedGrowthTime;
        rootLife = save.rootLife;
        sparkLife = save.sparkLife;
        sparkTimer = save.sparkTimer;
        smokeMaxLife = save.smokeMaxLife;
        cloudMaxLife = save.cloudMaxLife;
        branchLevel = save.branchLevel;
        branchLen = save.branchLen;
        branchMaxArr = save.branchMaxArr;
        branchSubCount = save.branchSubCount;
        branchDirX = save.branchDirX;
        branchDirY = save.branchDirY;
        oakTreeGrowthTime = save.oakTreeGrowthTime;
        oakTreeHeight = save.oakTreeHeight;
        oakTreeMaxHeight = save.oakTreeMaxHeight;
        oakTreeRootTimer = save.oakTreeRootTimer;
        oakTreeRootDepth = save.oakTreeRootDepth;
        oakTreeRootMax = save.oakTreeRootMax;
        grassStage = save.grassStage;
        burningGasTime = save.burningGasTime;
        chargedStateTime = save.chargedStateTime;
        
        if (save.colorVariations) {
          colorVariations = save.colorVariations;
        } else {
          colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
          const variation = 0.05;
          for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
              if (grid[y][x] !== EMPTY) {
                colorVariations[y][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
              }
            }
          }
        }
        
        renderGrid();
      } catch (e) {
        console.error('Error loading save:', e);
        alert('Error loading save file. The file may be corrupted.');
      }
    }

    function exportSaveGame(item) {
      const data = localStorage.getItem(item.key);
      if (!data) return;
      
      const blob = new Blob([data], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = item.title + ".dbr";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function showImportMessage(message, type = 'success') {
      // Create a temporary message element in the import area
      const importArea = document.getElementById('importDropZone');
      if (!importArea) return;
      
      let messageEl = importArea.querySelector('.import-message');
      if (!messageEl) {
        messageEl = document.createElement('div');
        messageEl.className = 'import-message';
        messageEl.style.cssText = `
          position: absolute;
          top: 10px;
          left: 10px;
          right: 10px;
          padding: 10px;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          z-index: 10;
          animation: slideIn 0.3s ease;
        `;
        importArea.style.position = 'relative';
        importArea.appendChild(messageEl);
      }
      
      if (type === 'success') {
        messageEl.style.background = 'linear-gradient(135deg, #4caf50, #45a049)';
        messageEl.style.color = 'white';
        messageEl.style.border = '1px solid #4caf50';
      } else if (type === 'error') {
        messageEl.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';
        messageEl.style.color = 'white';
        messageEl.style.border = '1px solid #f44336';
      } else if (type === 'warning') {
        messageEl.style.background = 'linear-gradient(135deg, #ff9800, #f57c00)';
        messageEl.style.color = 'white';
        messageEl.style.border = '1px solid #ff9800';
      }
      
      messageEl.textContent = message;
      messageEl.style.display = 'block';
      
      // Auto-hide after 4 seconds
      setTimeout(() => {
        if (messageEl) {
          messageEl.style.display = 'none';
        }
      }, 4000);
    }

    function handleFileImport(file) {
      if (!file.name.endsWith('.dbr')) {
        showImportMessage('Please select a .dbr file (Dabicco Rewritten file)', 'error');
        return;
      }
      
      showImportMessage('Importing file...', 'warning');
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const save = JSON.parse(e.target.result);
          const key = "dbr_save_" + Date.now();
          
          const saveString = JSON.stringify(save);
          const sizeMB = (saveString.length / 1024 / 1024).toFixed(2);
          
          // Extract metadata from save file or mark as legacy
          let title, description, version, isLegacy = false;
          
          if (save.title && save.description && save.version) {
            // Save has proper metadata
            title = save.title;
            description = save.description;
            version = save.version;
          } else {
            // Legacy save from before version 0.7
            title = file.name.replace('.dbr', '');
            description = "Legacy save made before version 0.7";
            version = "Legacy (pre-0.7)";
            isLegacy = true;
          }
          
          localStorage.setItem(key, saveString);
          let index = getSaveIndex();
          index.push({ 
            key, 
            title: title,
            description: description,
            version: version,
            isLegacy: isLegacy,
            timestamp: Date.now() 
          });
          setSaveIndex(index);
          updateAdvancedSavesList();
          
          // Switch to load tab and show success
          document.querySelector('[data-tab="load"].tab-btn').click();
          
          if (isLegacy) {
            showImportMessage(`Legacy save imported: "${title}" (${sizeMB}MB) - Made before version 0.7`, 'warning');
          } else {
            showImportMessage(`Save file imported: "${title}" v${version} (${sizeMB}MB)`, 'success');
          }
        } catch (err) {
          console.error("Import error", err);
          showImportMessage('Error importing save file. The file may be corrupted.', 'error');
        }
      };
      reader.readAsText(file);
    }

    // Initialize the advanced modal when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      initializeAdvancedSaveLoadModal();
    });

    // Update the existing modal opening code to properly initialize tabs
    function openSaveLoadModal() {
      const saveLoadModal = document.getElementById('saveLoadModal');
      if (!saveLoadModal) {
        console.error('Save/Load modal not found!');
        return;
      }
      
      console.log('Opening save/load modal...');
      saveLoadModal.style.display = 'block';
      
      // Wait a bit for the modal to be displayed, then reinitialize
      setTimeout(() => {
        // Reinitialize the modal to ensure everything works
        initializeAdvancedSaveLoadModal();
        
        // Set default tab to save and update content
        const saveTab = saveLoadModal.querySelector('[data-tab="save"].tab-btn');
        const saveContent = saveLoadModal.querySelector('[data-tab="save"].tab-content');
        
        if (saveTab && saveContent) {
          // Reset all first
          const allTabs = saveLoadModal.querySelectorAll('.tab-btn');
          const allContents = saveLoadModal.querySelectorAll('.tab-content');
          
          allTabs.forEach(tab => tab.classList.remove('active'));
          allContents.forEach(content => content.classList.remove('active'));
          
          // Activate save tab
          saveTab.classList.add('active');
          saveContent.classList.add('active');
          
          // Update save preview and info
          updateSavePreview();
          updateSaveInfo();
        }
      }, 100);
    }

    // Function to check grid size and show warning if necessary
    function checkGridSizeWarning(size) {
      const largeGridWarning = document.getElementById('largeGridWarning');
      if (parseInt(size) > 100) {
        largeGridWarning.style.display = 'block';
      } else {
        largeGridWarning.style.display = 'none';
      }
    }

    // Initial check when page loads
    document.addEventListener('DOMContentLoaded', function() {
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      if (stageSizeSelect) {
        checkGridSizeWarning(stageSizeSelect.value);
      }
    });

    document.getElementById('stageSizeSelect').addEventListener('change', function() {
      const newSize = parseInt(this.value);
      
      // Show or hide the warning based on selected size
      checkGridSizeWarning(newSize);
      
      if (newSize !== GRID_SIZE) {
        pendingStageSize = newSize;
        confirmationModal.style.display = 'block';
      } else {
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        document.getElementById('applyOptionsButton').style.display = 'none';
      }
    });

    // Add null check for confirmYes element
    const confirmYes = document.getElementById('confirmYes');
    if (confirmYes) {
      confirmYes.addEventListener('click', function() {
        if (pendingStageSize !== null) {
          initGrid(pendingStageSize);
          pendingStageSize = null;
          confirmationModal.style.display = 'none';
          optionsModal.style.display = 'none';
        }
      });
    }

    // Add null check for confirmNo element
    const confirmNo = document.getElementById('confirmNo');
    if (confirmNo) {
      confirmNo.addEventListener('click', function() {
      pendingStageSize = null;
      confirmationModal.style.display = 'none';
      document.getElementById('stageSizeSelect').value = GRID_SIZE.toString();
      document.getElementById('applyOptionsButton').style.display = 'none';
    });
    }

    // DabyFPS setting
    const settingDabyFps = document.getElementById('setting-dabyfps');
    if (settingDabyFps) {
      settingDabyFps.value = localStorage.getItem('setting-dabyfps') || 'false';
      settingDabyFps.addEventListener('change', function() {
        localStorage.setItem('setting-dabyfps', this.value);
        // Show or hide the FPS cap setting based on DabyFPS being enabled
        const fpsCapContainer = document.getElementById('fps-cap-container');
        if (fpsCapContainer) {
          fpsCapContainer.style.display = this.value === 'true' ? 'block' : 'none';
        }
      });
    }
    
    // FPS Cap setting
    const settingFpsCap = document.getElementById('setting-fps-cap');
    if (settingFpsCap) {
      settingFpsCap.value = localStorage.getItem('setting-fps-cap') || '60';
      settingFpsCap.addEventListener('change', function() {
        localStorage.setItem('setting-fps-cap', this.value);
      });
    }
    
    // Show/hide FPS cap based on saved DabyFPS setting
    const fpsCapContainer = document.getElementById('fps-cap-container');
    const dabyFpsElement = document.getElementById('setting-dabyfps');
    if (fpsCapContainer && dabyFpsElement) {
      fpsCapContainer.style.display = dabyFpsElement.value === 'true' ? 'block' : 'none';
    }

    // This function returns the color for each element type; I used to implement it during debugging, however it's now used for the Save/Load functionality.
    function getElementColor(element) {
    // This matches the game's element colors! Modders should use this for new elements.
    switch(element) {
      case 0: return '#000000'; // EMPTY
      case 1: return '#e6c88e'; // SAND
      case 2: return '#4286f4'; // WATER
      case 3: return '#ff4500'; // LAVA
      case 4: return '#808080'; // STONE
      case 5: return '#ffb6c1'; // ERASER
      case 6: return '#b3e6ff'; // WATER_VAPOR
      case 7: return '#ffffff'; // CLOUD
      case 8: return '#555555'; // BASALT
      case 9: return '#333333'; // OBSIDIAN
      case 10: return '#a52a2a'; // MOLTEN_SLAG
      case 11: return '#b87333'; // COPPER
      case 12: return '#aaaaaa'; // STEEL
      case 13: return '#cceeff'; // ICE
      case 14: return '#8b4513'; // WOOD
      case 15: return '#ff6600'; // FIRE
      case 16: return '#777777'; // SMOKE
      case 17: return '#a52a2a'; // BURNING_WOOD
      case 18: return '#555555'; // ASH
      case 19: return '#d3d3d3'; // GLASS
      case 20: return '#ff0000'; // BOMB
      case 21: return '#8b4513'; // DIRT
      case 22: return '#a0522d'; // WET_DIRT
      case 23: return '#f5deb3'; // WHEAT_SEEDS
      case 24: return '#f0e68c'; // WHEAT
      case 25: return '#fff8dc'; // FLOUR
      case 26: return '#f5deb3'; // DOUGH
      case 27: return '#d2b48c'; // BREAD
      case 28: return '#8b4513'; // ROOT
      case 29: return '#a52a2a'; // BURNING_ORGANIC
      case 30: return '#ffff00'; // SPARK
      case 31: return '#ffa500'; // CHARGED_COPPER
      case 32: return '#556b2f'; // OAK_SEEDS
      case 33: return '#228b22'; // OAK_LEAVES
      case 34: return '#32cd32'; // OAK_BABY_LEAVES
      case 35: return '#8b4513'; // DEAD_OAK
      case 36: return '#d2b48c'; // WET_SAND
      case 37: return '#7cfc00'; // GRASS
      case 38: return '#8b4513'; // DEAD_PLANT
      case 39: return '#a52a2a'; // BURNING_LEAVES
      case 40: return '#a52a2a'; // BURNING_ROOT
      case 41: return '#8b4513'; // DEAD_ROOT
      case 42: return '#e6e6fa'; // GAS
      case 43: return '#ff6347'; // BURNING_GAS
      case 44: return '#696969'; // WALL
      case 45: return '#cd853f'; // CHARGED_DOWN_COPPER
      case 46: return '#00bfff'; // COOLER
      case 47: return '#ff4500'; // HEATER
      case 48: return '#ffd700'; // HEAT_SEPARATOR
      case 49: return '#ffa500'; // CHARGED_HEAT_SEPARATOR
      case 50: return '#cd853f'; // CHARGED_DOWN_HEAT_SEPARATOR
      case 51: return '#00ff00'; // INPUT
      case 52: return '#7fff00'; // CHARGED_INPUT
      case 53: return '#0000ff'; // OUTPUT
      case 54: return '#1e90ff'; // CHARGED_OUTPUT
      case 55: return '#ff00ff'; // NOT_GATE
      case 56: return '#9932cc'; // AND_GATE
      case 57: return '#800080'; // BLOCKER
      case 60: return '#00ffff'; // CLONER
      case 61: return '#9370db'; // CHARGED_BLOCKER
      case 62: return '#2f4f4f'; // COAL
      case 63: return '#2f4f4f'; // COAL_LUMP
      case 64: return '#8b0000'; // BURNING_COAL
      case 65: return '#8b0000'; // BURNING_COAL_LUMP
      case 68: return '#a9a9a9'; // THERMITE
      case 69: return '#ff4500'; // BURNING_THERMITE
      case 70: return '#32cd32'; // ACID
      case 71: return '#98fb98'; // ACID_STEAM
      case 72: return '#90ee90'; // ACID_CLOUD
      case 73: return '#00ff7f'; // SLIME
      case 74: return '#d3d3d3'; // CARBON_DIOXIDE
      case 75: return '#e0ffff'; // OXYGEN
      case 76: return '#000000'; // BIRD
      case 77: return '#cd5c5c'; // MEAT
      case 78: return '#8b4513'; // COOKED_MEAT
      case 79: return '#a9a9a9'; // COBBLESTONE
      case 80: return '#000000'; // OIL
      case 81: return '#ff0000'; // BIG_BOMB
      case 82: return '#4169e1'; // WATER_BOMB
      case 83: return '#ff4500'; // FIRE_BOMB
      case 84: return '#00ffff'; // CRYO_BOMB
      case 85: return '#ff00ff'; // NUKE_BOMB
      case 86: return '#e6f7ff'; // HELIUM
      case 87: return '#ff1493'; // BOUNCY_BALL
      case 88: return '#8b7355'; // BIRCH_SEEDS
      case 89: return '#90ee90'; // BIRCH_LEAVES
      case 90: return '#98fb98'; // BIRCH_BABY_LEAVES
      case 91: return '#f5deb3'; // BIRCH_WOOD
      case 92: return '#8b7355'; // DEAD_BIRCH
      case 93: return '#ffc0cb'; // CELL
      case 94: return '#696969'; // DEAD_CELL
      case 95: return '#8b0000'; // BLOOD
      case 96: return '#b0e0e6'; // GLASS_SHARD
      case 97: return '#deb887'; // SAWDUST
      case 98: return '#ffffff'; // SALT
      case 99: return '#4682b4'; // SALT_WATER
      case 200: return '#ffd700'; // GLUE
      case 201: return '#ffffff'; // SUGAR
      case 202: return '#f0f8ff'; // SUGAR_WATER
      case 203: return '#228b22'; // PLANT
      case 204: return '#b9f2ff'; // DIAMOND
      case 205: return '#e0f0ff'; // DIAMOND_SHARDS
      case 206: return '#87ceeb'; // MOLTEN_DIAMOND
      case 207: return '#ff69b4'; // CONFETTI
      case 208: return '#ff1493'; // DABICCO
      case 209: return '#708090'; // OXIDIZED_COPPER
      case 210: return '#ff7f50'; // MOLTEN_COPPER
      case 211: return '#fffacd'; // MOLTEN_SALT
      case 212: return '#ff6347'; // MOLTEN_STEEL
      case 213: return '#deb887'; // MOLTEN_SUGAR
      case 214: return '#ffa07a'; // MOLTEN_GLASS
      case 215: return '#ff8c00'; // MOLTEN_ELECTRICAL
      case 216: return '#2f4f4f'; // INSULATOR
      case 217: return '#ffff00'; // PHOTON
      case 218: return '#ffd700'; // LIGHTNING
      case 219: return '#fff8dc'; // LIGHTNING_TRAIL
      case 220: return '#d3d3d3'; // DENSE_CLOUD
      case 221: return '#ffffff'; // SNOW
      default: return '#333333'; // Default dark gray
    }
  }
  </script>

  <!-- Initialize all event handlers after DOM is loaded -->
  <script>
    // HUD toggle functionality
    function updateHudVisibility() {
      const hud = document.getElementById('hud');
      const hudToggle = document.getElementById('hudToggle');
      if (hud && hudToggle) {
        const isVisible = hudToggle.checked;
        hud.style.display = isVisible ? 'block' : 'none';
        // Save preference
        localStorage.setItem('hudToggle', isVisible ? '1' : '0');
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Debug elements
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });

      // Initialize HUD visibility - this is handled by setupToggleSwitches() but we need to ensure it shows by default on desktop
      const hud = document.getElementById('hud');
      const isMobile = window.innerWidth <= 1024;
      
      // Set initial HUD visibility based on device type if no saved preference exists
      if (!localStorage.getItem('hudToggle') && hud && !isMobile) {
        localStorage.setItem('hudToggle', '1'); // Default to visible on desktop
        hud.style.display = 'block';
      }

      // DabyFPS handler
      const dabyFpsSelect = document.getElementById('dabyFps');
      if (dabyFpsSelect) {
        dabyFpsSelect.addEventListener('change', function(e) {
          targetFps = parseInt(e.target.value);
        });
      }

      // Pop out mode handler
      const popOutModeSelect = document.getElementById('popOutMode');
      if (popOutModeSelect) {
        popOutModeSelect.addEventListener('change', function(e) {
          if (parseInt(e.target.value) === 1) {
            if (!popOutWindow || popOutWindow.closed) {
              popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
              const popOutDoc = popOutWindow.document;
              
              // Create pop-out window content
              popOutDoc.write(`
                <!DOCTYPE html>
                <html>
                <head>
                  <style>
                    body { margin: 0; background: #222; overflow: hidden; }
                    #popOutGrid { width: 100%; height: 100%; }
                  </style>
                </head>
                <body>
                  <div id="popOutGrid"></div>
                </body>
                </html>
              `);
              
              // Move grid to pop-out window
              const originalGrid = document.getElementById('grid');
              popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
              
              // Handle window resize
              popOutWindow.addEventListener('resize', function() {
                const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
                originalGrid.style.width = size + 'px';
                originalGrid.style.height = size + 'px';
              });
              
              // Handle window close
              popOutWindow.addEventListener('unload', function() {
                if (!popOutWindow.closed) {
                  document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
                  originalGrid.style.width = '500px';
                  originalGrid.style.height = '500px';
                  document.getElementById('popOutMode').value = "0";
                }
              });
            }
          } else {
            if (popOutWindow && !popOutWindow.closed) {
              popOutWindow.close();
            }
          }
        });
      }

      // Store the current stage size
      let currentStageSize = GRID_SIZE;
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      const applyButton = document.getElementById('applyOptionsButton');

      // Update stage size select to show current size
      stageSizeSelect.value = currentStageSize.toString();

      // Handle stage size change
      stageSizeSelect.addEventListener('change', function(e) {
        const newSize = parseInt(e.target.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
      });

      // Modify applyOptionsButton click handler
      applyButton.addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          currentStageSize = newSize;
          initGrid(newSize);
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'none';
      });

      // When options modal is opened, check if size is different
      const optionsButton = document.getElementById('optionsButton');
      if (optionsButton) {
        optionsButton.addEventListener('click', function() {
          const newSize = parseInt(stageSizeSelect.value);
          if (newSize !== currentStageSize) {
            applyButton.style.display = 'block';
            applyButton.classList.add('show-clear-warning');
          } else {
            applyButton.style.display = 'none';
            applyButton.classList.remove('show-clear-warning');
          }
          const optionsModal = document.getElementById('optionsModal');
          if (optionsModal) {
            optionsModal.style.display = 'block';
          }
        });
      }
    });

    // Clear All Data button functionality
    const clearAllDataButton = document.getElementById('clearAllDataButton');
    if (clearAllDataButton) {
      clearAllDataButton.addEventListener('click', function() {
        // Create confirmation modal
        const confirmModal = document.createElement('div');
        confirmModal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          font-family: inherit;
        `;
        
        const confirmContent = document.createElement('div');
        confirmContent.style.cssText = `
          background: var(--bg-primary);
          border: 2px solid #f44336;
          border-radius: 16px;
          padding: 30px;
          max-width: 400px;
          text-align: center;
          box-shadow: 0 8px 32px rgba(244, 67, 54, 0.3);
        `;
        
        confirmContent.innerHTML = `
          <div style="color: #f44336; font-size: 48px; margin-bottom: 20px;">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 48px; height: 48px;">
              <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
            </svg>
          </div>
          <h3 style="color: var(--text-primary); margin: 0 0 15px 0; font-size: 24px;">
            Clear All Data?
          </h3>
          <p style="color: var(--text-secondary); margin: 0 0 25px 0; line-height: 1.4;">
            This will permanently delete:<br>
            â€¢ All saved games (.dbr files)<br>
            â€¢ All settings and preferences<br>
            â€¢ All game data<br><br>
            <strong style="color: #f44336;">This action cannot be undone!</strong>
          </p>
          <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="cancelClearData" style="
              background: var(--bg-secondary);
              color: var(--text-primary);
              border: 2px solid var(--border-color);
              border-radius: 8px;
              padding: 12px 24px;
              font-size: 14px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
            ">Cancel</button>
            <button id="confirmClearData" style="
              background: #f44336;
              color: white;
              border: none;
              border-radius: 8px;
              padding: 12px 24px;
              font-size: 14px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
            ">Clear All Data</button>
          </div>
        `;
        
        confirmModal.appendChild(confirmContent);
        document.body.appendChild(confirmModal);
        
        // Handle cancel
        document.getElementById('cancelClearData').addEventListener('click', function() {
          document.body.removeChild(confirmModal);
        });
        
        // Handle confirm
        document.getElementById('confirmClearData').addEventListener('click', function() {
          try {
            // Clear all localStorage data
            localStorage.clear();
            
            // Show success message before reload
            confirmContent.innerHTML = `
              <div style="color: #4caf50; font-size: 48px; margin-bottom: 20px;">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 48px; height: 48px;">
                  <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/>
                </svg>
              </div>
              <h3 style="color: var(--text-primary); margin: 0 0 15px 0; font-size: 24px;">
                Data Cleared Successfully
              </h3>
              <p style="color: var(--text-secondary); margin: 0 0 25px 0;">
                The page will reload in 3 seconds...
              </p>
            `;
            
            // Reload page after 3 seconds
            setTimeout(() => {
              window.location.reload();
            }, 3000);
            
          } catch (error) {
            console.error('Error clearing data:', error);
            confirmContent.innerHTML = `
              <div style="color: #f44336; font-size: 48px; margin-bottom: 20px;">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width: 48px; height: 48px;">
                  <path d="M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"/>
                </svg>
              </div>
              <h3 style="color: var(--text-primary); margin: 0 0 15px 0; font-size: 24px;">
                Error Clearing Data
              </h3>
              <p style="color: var(--text-secondary); margin: 0 0 25px 0;">
                There was an error clearing the data. Please try again or manually clear your browser data.
              </p>
              <button onclick="document.body.removeChild(this.closest('div'))" style="
                background: var(--accent);
                color: white;
                border: none;
                border-radius: 8px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">Close</button>
            `;
          }
        });
        
        // Close on background click
        confirmModal.addEventListener('click', function(e) {
          if (e.target === confirmModal) {
            document.body.removeChild(confirmModal);
          }
        });
      });
    }

    // Loading screen functionality
    function initializeLoadingScreen() {
      const loadingScreen = document.getElementById('loadingScreen');
      const loadingBar = document.getElementById('loadingBar');
      const loadingText = document.getElementById('loadingText');
      const loadingTip = document.getElementById('loadingTip');
      
      let progress = 0;
      const loadingSteps = [
        { text: "Initializing physics engine...", progress: 10 },
        { text: "Loading element definitions...", progress: 25 },
        { text: "Setting up rendering pipeline...", progress: 40 },
        { text: "Preparing audio system...", progress: 60 },
        { text: "Initializing user interface...", progress: 80 },
        { text: "Finalizing game state...", progress: 95 },
        { text: "Ready to play!", progress: 100 }
      ];
      
      const tips = [
        "Tip: Right-click to erase elements",
        "Tip: Use the mouse wheel to change brush size",
        "Tip: Try mixing fire and water to create steam",
        "Tip: Plants need water and dirt to grow",
        "Tip: Lava cools into stone when it touches water",
        "Tip: Electricity flows through copper wires",
        "Tip: Use the space bar to pause the simulation",
        "Tip: Save your creations for later use",
        "Tip: Hold Alt while placing to create square patterns",

        "Tip: Use the Heat tool to increase element temperatures",
        "Tip: The Cool tool can freeze water into ice",
        "Tip: Salt dissolves in water to create salt water",
        "Tip: Oil burns longer and hotter than other materials",
        "Tip: Acid dissolves most elements on contact",
        "Tip: Trees grow from seeds planted in dirt",
        "Tip: Coal burns very hot and lasts a long time",
        "Tip: Glass can be made by heating sand to high temperatures",
        "Tip: Thermite creates extremely hot fires when ignited",
        "Tip: Birds fly around and avoid dangerous areas",
        "Tip: Use the Terrain Generator for instant landscapes",
        "Tip: Custom elements let you create your own materials",
        "Tip: Explosives detonate when heated to their trigger temperature",
        "Tip: The HUD shows temperature and element information",
        "Tip: Larger grid sizes give more space but may reduce performance",
        "Tip: Mods can add new elements and change game behavior",
        "Tip: Use the Search function to quickly find specific elements",
        "Tip: Copper conducts electricity and can power other components",
        "Tip: Mix Tool stirs elements together for interesting effects",
        "Tip: Sponge Tool absorbs liquids from an area",
        "Tip: Lightning creates powerful electrical discharges",
        "Tip: Diamond is extremely hard and heat-resistant",
        "Tip: Different elements have unique heat capacities and melting points",
        "Tip: Water and lava create obsidian at high temperatures",
        "Tip: Wood burns to create ash when ignited",
        "Tip: Steel is resistant to most forms of damage",
        "Tip: Flour and water combine to make dough when mixed"
      ];
      
      let currentStep = 0;
      const randomTip = tips[Math.floor(Math.random() * tips.length)];
      loadingTip.textContent = randomTip;
      
      // Check if user prefers retro mode from localStorage
      const savedUiMode = localStorage.getItem('uiMode');
      if (savedUiMode === 'pixel') {
        document.body.classList.add('pixel-mode');
      }
      
      function updateLoading() {
        if (currentStep < loadingSteps.length) {
          const step = loadingSteps[currentStep];
          loadingText.textContent = step.text;
          loadingBar.style.width = step.progress + '%';
          
          currentStep++;
          
          // Vary timing for more realistic loading
          const delay = currentStep < 3 ? 300 : (currentStep < 5 ? 500 : 700);
          setTimeout(updateLoading, delay);
        } else {
          // Loading complete, fade out
          setTimeout(() => {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
              loadingScreen.style.display = 'none';
            }, 500);
          }, 800);
        }
      }
      
      // Start loading sequence after a brief delay
      setTimeout(updateLoading, 500);
    }
    
    // Initialize loading screen when DOM is ready (unless skipload is set)
    const urlParams = getUrlParameters();
    if (urlParams.skipload !== 'true') {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeLoadingScreen);
      } else {
        initializeLoadingScreen();
      }
    } else {
      // If skipload is true, hide loading screen immediately
      const loadingScreen = document.getElementById('loadingScreen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }



    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>

  <script>
    // Terrain Generation
    window.generateTerrain = function() {
      // Clear the grid first
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          eraseCell(x, y);
        }
      }

      // Generate surface level (about 30% down from top)
      const surfaceLevel = Math.floor(GRID_SIZE * 0.3);
      
      // Generate perlin noise for surface variation
      const surfaceNoise = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        surfaceNoise[x] = Math.sin(x * 0.1) * 3 + Math.random() * 2;
      }

      // Generate caves using a simple cellular automata approach
      let caves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
      
      // Initialize random cave seeds (increased frequency)
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (Math.random() < 0.2) {
            caves[y][x] = true;
          }
        }
      }

      // Smooth caves
      for (let i = 0; i < 3; i++) {
        const newCaves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            let neighbors = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (caves[ny][nx]) neighbors++;
                }
              }
            }
            newCaves[y][x] = neighbors >= 4 || (caves[y][x] && neighbors >= 3);
          }
        }
        caves = newCaves;
      }

      // Generate terrain
      for (let x = 0; x < GRID_SIZE; x++) {
        const localSurface = Math.floor(surfaceLevel + surfaceNoise[x]);
        
        // Generate seeds and plants first
        if (Math.random() < 0.15) {
          grid[localSurface][x-1] = OAK_SEEDS;
          temp[localSurface][x-1] = 20;
        } else if (Math.random() < 0.15) {
          grid[localSurface][x-1] = WHEAT_SEEDS;
          temp[localSurface][x-1] = 20;
        }
        
        // Generate grass layer
        grid[localSurface + 1][x] = GRASS;
        temp[localSurface + 1][x] = 20;
        
        // Add atmospheric gasses
        if (Math.random() < 0.1 && localSurface > 0) {
          grid[localSurface - 1][x] = Math.random() < 0.5 ? CARBON_DIOXIDE : OXYGEN;
          temp[localSurface - 1][x] = 20;
        }
        
        // Generate dirt and occasional cobblestone layer
        for (let y = localSurface + 2; y < localSurface + 7; y++) {
          if (y >= GRID_SIZE) continue;
          if (!caves[y][x]) {
            if (Math.random() < 0.1) {
              grid[y][x] = COBBLESTONE;
            } else {
              grid[y][x] = DIRT;
            }
            temp[y][x] = 20;
          }
        }
        
        // Generate stone layer with ores
        for (let y = localSurface + 7; y < GRID_SIZE; y++) {
          if (!caves[y][x]) {
            if (Math.random() < 0.05) {
              const depth = y / GRID_SIZE;
              if (depth > 0.8 && Math.random() < 0.3) {
                grid[y][x] = STEEL;
              } else if (depth > 0.6 && Math.random() < 0.3) {
                grid[y][x] = COPPER;
              } else if (Math.random() < 0.4) {
                grid[y][x] = COAL;
              } else {
                grid[y][x] = STONE;
              }
            } else {
              grid[y][x] = STONE;
            }
            temp[y][x] = 20;
          }
        }
      }

      // Add water/lava to caves
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.02) {
            const isLava = y > GRID_SIZE * 0.7 && Math.random() < 0.3;
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 50;

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = isLava ? LAVA : WATER;
                temp[cy][cx] = isLava ? 1200 : 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add oil deposits near bottom
      for (let y = Math.floor(GRID_SIZE * 0.8); y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.03) {
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 30;

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = OIL;
                temp[cy][cx] = 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add random birds near surface
      for (let y = 0; y < surfaceLevel; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === EMPTY && Math.random() < 0.01) {
            grid[y][x] = BIRD;
            temp[y][x] = 20;
          }
        }
      }
    };
  </script>
</body>
</html>
</html>