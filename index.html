<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=0.5, user-scalable=yes">
  <title>Sandbox Delta 0.7.1c</title>
  <!-- Webapp metadata -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Sandbox Delta">
  <meta name="application-name" content="Sandbox Delta">
  <link rel="icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJhSURBVFhH7ZY9aBRBGIbfvdwld7lL7hJz+YnJJcYYY0gMwUQsRFELCwutRBELGwutxFZtRBDBwkIQRBBE0MbGRrAQRLAQRBAsgoUWFhYWFhYWYp7vnNm9XdnLzwXkwBcedmdnZ9/vne+b2bvCcRxsZRXWvzet/G6HyWRSxONxEYvFRDQaFeFwWIRCIeHz+YTP6xVer1d4PB7hdruF2+USLpdLOJ1O4XA4hN1uFzabTVitVmGxWITZbBYmk0mYTCZhNBqFwWAQer1e6HQ6odVqhUajEWq1WqhUKqFUKoVCoRByuVzI5XIhk8mETCYTUqlUSCQSIRaLBUVRQBAEQZIkQZRlQRRFQRAEQa/XC1qtVmi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFlKpVMhkMiGXy4VCodh8AHVdF4VCIWQymZBKpUIikQixWCykUqmQyWRCLpcLhUIh5HK5kMlkQiqVColEIsRisZBKpUIqlQqZTCbkcrlQKBRCLpcLmUwmpFKpkEgkQiwWC6lUKmQymZDL5UIhXwXweDwbD8AZcLvdwuVyCYfDIex2u7DZbMJqtQqLxSLMZrMwmUzCaDQKg8Eg9Hq90Ol0QqvVCo1GI9RqtVCpVEKpVAqFQiHkcrmQyWRCKpUKiUQixGKxoChKEIIgCJIkCaIsCqIoCgaDQWi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFhRFEQRBECRJEkRZFERRFPR6vdBqtUKj0Qi1Wi1UKpVQKpVCoVAIuVwuZDKZkEqlQiKRCLFYLCiKIgiCIEiSJIiyKIiiKPwXAYQQfwBCxA1TnWK6GAAAAABJRU5ErkJggg==">
  <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJhSURBVFhH7ZY9aBRBGIbfvdwld7lL7hJz+YnJJcYYY0gMwUQsRFELCwutRBELGwutxFZtRBDBwkIQRBBE0MbGRrAQRLAQRBAsgoUWFhYWFhYWYp7vnNm9XdnLzwXkwBcedmdnZ9/vne+b2bvCcRxsZRXWvzet/G6HyWRSxONxEYvFRDQaFeFwWIRCIeHz+YTP6xVer1d4PB7hdruF2+USLpdLOJ1O4XA4hN1uFzabTVitVmGxWITZbBYmk0mYTCZhNBqFwWAQer1e6HQ6odVqhUajEWq1WqhUKqFUKoVCoRByuVzI5XIhk8mETCYTUqlUSCQSIRaLBUVRQBAEQZIkQZRlQRRFQRAEQa/XC1qtVmi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFlKpVMhkMiGXy4VCodh8AHVdF4VCIWQymZBKpUIikQixWCykUqmQyWRCLpcLhUIh5HK5kMlkQiqVColEIsRisZBKpUIqlQqZTCbkcrlQKBRCLpcLmUwmpFKpkEgkQiwWC6lUKmQymZDL5UIhXwXweDwbD8AZcLvdwuVyCYfDIex2u7DZbMJqtQqLxSLMZrMwmUzCaDQKg8Eg9Hq90Ol0QqvVCo1GI9RqtVCpVEKpVAqFQiHkcrmQyWRCKpUKiUQixGKxoChKEIIgCJIkCaIsCqIoCgaDQWi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFhRFEQRBECRJEkRZFERRFPR6vdBqtUKj0Qi1Wi1UKpVQKpVCoVAIuVwuZDKZkEqlQiKRCLFYLCiKIgiCIEiSJIiyKIiiKPwXAYQQfwBCxA1TnWK6GAAAAABJRU5ErkJggg==">

  <style>
    /* Basic layout: center the page content, side panel on the right */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    /* Volume slider styles */
    .volume-slider {
      width: 200px;
      margin: 0 10px;
      vertical-align: middle;
    }
    
    .element-volume-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .element-volume-item {
      display: flex;
      align-items: center;
      padding: 5px;
      border: 1px solid #444;
      border-radius: 4px;
    }
    
    .element-color-box {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border-radius: 3px;
    }

    #game-container {
      overflow: auto;
    }

    .playing #game-container {
      overflow: hidden;
    }

    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --accent: #00b4d8;
      --text-primary: #e6e6e6;
      --text-secondary: #a8a8a8;
      --border-color: #2a3a5f;
      --hover-bg: rgba(0, 180, 216, 0.1);
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      box-sizing: border-box;
      line-height: 1.5;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    /* The main container: grid + side panel horizontally */
    #mainContainer {
      display: flex;
      flex-direction: row;
      justify-content: center;
      margin: 0 auto;
      padding: 10px;
      box-sizing: border-box;
      width: 100%;
      height: 100vh;
      gap: 20px;
      position: relative;
      overflow: hidden;
    }
    
    /* Custom scrollbar for the entire document */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: #777;
    }
    
    /* Mobile layout */
    @media (max-width: 1024px) {
      body {
        overflow-x: hidden;
      }
      
      #mainContainer {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
        padding: 5px;
        gap: 10px;
        overflow-x: hidden;
      }
      
      #grid {
        width: 100% !important;
        max-width: 100% !important;
        height: 70vh !important;
        margin: 0 auto;
        touch-action: none; /* Prevent default touch behavior */
        user-select: none;
      }
      
      #sidePanel {
        width: 100% !important;
        height: auto !important;
        min-height: 30vh;
        max-height: 40vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* Tool buttons on mobile */
      .tool {
        padding: 10px;
        margin: 5px;
        font-size: 14px;
        border-radius: 6px;
        cursor: pointer;
        touch-action: manipulation;
      }

      .tool.selected {
        background-color: var(--hover-bg);
      }

      /* Hover overlay for touch */
      #hoverOverlay {
        pointer-events: none;
        touch-action: none;
      }
      
      #hud {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px 12px;
        border-radius: 6px;
        z-index: 100;
        font-size: 12px;
      }
      
      #hud > div {
        margin: 2px 0;
      }
      
      #selectedElementNotification {
        bottom: 10px;
        left: 10px;
        font-size: 14px;
        padding: 8px 15px;
      }
      
      #selectedElementNotification .element-color {
        width: 20px;
        height: 20px;
      }
    }
    /* The game grid; its size will be determined by GRID_SIZE */
    #grid {
      flex: 1;
      max-width: calc(100vh - 20px);
      aspect-ratio: 1;
      background-color: #555;
      user-select: none;
      cursor: crosshair;
      display: grid;
      grid-template-columns: repeat(50, 1fr);
      grid-template-rows: repeat(50, 1fr);
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .cell {
      width: 100%;
      height: 100%;
      background-color: #000;
      box-sizing: border-box;
    }
    /* Hover overlay for stroke highlighting */
    #hoverOverlay {
      position: absolute;
      pointer-events: none;
      border: 2px dashed yellow;
      background-color: rgba(255, 255, 0, 0.2);
      display: none;
      box-sizing: border-box;
    }
    
    /* Selected element notification */
    #selectedElementNotification {
      position: fixed;
      bottom: 30px;
      left: 30px;
      color: #fff;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background-color: rgba(40, 40, 45, 0.95);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      transform: translateY(30px) scale(0.98);
      min-width: 180px;
    }
    
    #selectedElementNotification.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }
    
    #selectedElementNotification .element-color {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3),
                  inset 0 1px 2px rgba(255, 255, 255, 0.2);
      flex-shrink: 0;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    #selectedElementNotification.visible .element-color {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    }
    /* Side panel: now wider */
    #sidePanel {
      display: flex;
      flex-direction: column;
      width: 380px;
      min-width: 380px;
      height: calc(100vh - 20px);
      background: var(--bg-secondary);
      border-radius: 8px;
      box-shadow: var(--shadow);
      overflow: hidden;
      border: 1px solid var(--border-color);
      box-sizing: border-box;
      transition: all 0.3s ease;
      position: relative;
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    
    #sidePanel::-webkit-scrollbar {
      display: none;  /* Hide scrollbar for Chrome, Safari and Opera */
    }
    /* Container for the two scrollable areas side-by-side */
    #sideContent {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }
    
    @media (max-width: 1024px) {
      #sideContent {
        flex-direction: column;
      }
      
      #elementScroll {
        max-height: 50vh;
        overflow-y: auto;
      }
    }
    /* Element list scroll area */
    #elementScroll {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
    }
    
    #elementScroll::-webkit-scrollbar {
      width: 6px;
    }
    
    #elementScroll::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #elementScroll::-webkit-scrollbar-thumb {
      background-color: var(--border-color);
      border-radius: 3px;
    }
    /* Custom scrollbar for element list */
    #elementScroll::-webkit-scrollbar {
      width: 8px;
    }
    #elementScroll::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Search and Sort Container */
    #toolSearchContainer {
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      padding: 0 5px;
      width: 100%;
      box-sizing: border-box;
      gap: 8px;
    }
    
    #toolSearch {
      flex: 1;
      min-width: 0; /* Allows the input to shrink below its default minimum width */
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 12px;
      box-sizing: border-box;
      font-size: 14px;
      transition: all 0.2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    #toolSearch:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.2);
    }
    #toolSearch::placeholder {
      color: #bbb;
    }
    
    /* Sort dropdown styling */
    #sortOrder {
      flex: 0 0 auto;
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 25px 8px 10px;
      font-size: 12px;
      cursor: pointer;
      outline: none;
      transition: all 0.2s ease;
      width: 100px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,<svg width='12' height='12' viewBox='0 0 12 12' fill='white' xmlns='http://www.w3.org/2000/svg'><path d='M6 9L2 5h8l-4 4z' fill='%23e6e6e6'/></svg>");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    #sortOrder:hover {
      background-color: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
    }
    
    #sortOrder:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.3);
    }
    
    #sortOrder option {
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      padding: 8px 12px;
      font-size: 12px;
    }
    
    /* Hide the default dropdown arrow in IE11 */
    select::-ms-expand {
      display: none;
    }
    /* Toolbar (element icons) */
    #toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 5px;
      overflow-y: auto;
      max-height: 60vh;
    }
    
    @media (max-width: 768px) {
      #toolbar {
        gap: 4px;
      }
      
      .tool {
        width: 50px !important;
        height: 36px !important;
      }
      
      .tool span {
        font-size: 9px !important;
      }
    }
    .tool {
      position: relative;
      width: 58px;
      height: 38px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      background-color: rgba(255, 255, 255, 0.05);
      transition: all 0.15s ease;
      overflow: hidden;
    }
    /* HUD (not scrollable) */
    #hud {
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid var(--border-color);
      font-size: 14px;
      color: #fff;
      display: flex;
      flex-direction: column;
      gap: 5px;
      position: relative;
      z-index: 10;
    }
    
    .tool:hover {
      background-color: var(--hover-bg);
      transform: translateY(-2px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      border-color: var(--accent);
    }
    .tool span {
      position: absolute;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-primary);
      bottom: 3px;
      right: 3px;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      padding: 1px 3px;
      border-radius: 3px;
      background-color: rgba(0, 0, 0, 0.4);
    }
    .tool.selected {
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 180, 216, 0.3);
      background-color: rgba(0, 180, 216, 0.15);
    }
    /* Category menu (tabs) placed to the right in its own scroll area */
    #categoryMenu {
      display: flex;
      flex-direction: column;
      width: 120px;
      min-width: 120px;
      overflow-y: auto;
      padding: 8px 4px;
      background-color: var(--bg-primary);
      border-right: 1px solid var(--border-color);
      scrollbar-width: thin;
    }
    
    @media (max-width: 1024px) {
      #categoryMenu {
        flex-direction: row;
        width: 100%;
        min-width: 100%;
        height: auto;
        max-height: 50px;
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }
      
      #categoryMenu button {
        margin: 0 2px;
        padding: 4px 8px;
        white-space: nowrap;
      }
    }
    
    #categoryMenu button {
      width: 100%;
      padding: 6px 8px;
      margin: 2px 0;
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      border: 1px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      text-align: left;
      transition: all 0.15s ease;
      text-transform: capitalize;
    }
    
    #categoryMenu button:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    
    #categoryMenu button.active {
      background-color: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    /* Custom scrollbar for category menu */
    #categoryMenu::-webkit-scrollbar {
      width: 8px;
    }
    #categoryMenu::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Element color classes */
    .sand         { background-color: #f4a460; }
    .wall         { background-color: #666666; }
    .water        { background-color: #1e7fdf; }
    .salt-water   { background-color: #3aafff; }
    .lava         { background-color: #ff4500; }
    .stone        { background-color: #808080; }
    .water-vapor  { background-color: #e0e0e0; }
    .cloud        { background-color: #ffffff; }
    .helium       { background-color: #e6f7ff; }
    .eraser       { background-color: pink; border: 2px solid #fff; }
    .copper       { background-color: #b87333; }
    .steel        { background-color: #aaaaaa; }
    .ice          { background-color: #cceeff; }
    .wood         { background-color: #3B220E; }
    .fire         { background-color: #ffcc00; }
    .smoke        { background-color: #666666; }
    .burning-wood { background-color: #5a3310; }
    .ash          { background-color: #444444; }
    .glass        { background-color: #c2e9fb; }
    .bomb         { background-color: #006400; border: 2px solid #000; }
    .dirt         { background-color: #7B5E42; }
    .wet-dirt     { background-color: #4d2e12; }
    .wheat-seeds  { background-color: #bca136; }
    .wheat        { background-color: #c2b280; }
    .flour        { background-color: #f5f5dc; }
    .dough        { background-color: #d2b48c; }
    .bread        { background-color: #f4c986; }
    .burning-organic { background-color: #6a3400; }
    .root         { background-color: #4a3a2f; }
    .spark        { background-color: #ffdd00; border: 1px solid #ffbb00; }
    .charged-copper { background-color: #ff8c00; }
    .charged-down-copper { background-color: #cc6600; }
    .oak-seeds       { background-color: #32CD32; }
    .oak-leaves      { background-color: #228B22; }
    .oak-baby-leaves { background-color: #66bb6a; }
    .dead-oak        { background-color: #777777; }
    .wet-sand        { background-color: #d2a679; }
    .grass           { background-color: #00aa00; }
    .dead-plant      { background-color: #555555; }
    .burning-leaves  { background-color: #a0522d; }
    .burning-root    { background-color: #ff4500; }
    .dead-root       { background-color: #555555; }
    .gas             { background-color: rgba(200,200,200,0.2); }
    .burning-gas     { background-color: #ff6666; opacity: 0.75; }
    .acid            { background-color: #90EE90; }
    .acid-steam      { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud      { background-color: #98FB98; }
    .slime         { background-color: #006400; }

    .carbon-dioxide  { background-color: rgba(128,128,128,0.2); }
    .oxygen          { background-color: rgba(200,230,255,0.2); }
    .bird            { background-color: #B8860B; }
    .meat            { background-color: #FF6B6B; }
    .cooked-meat     { background-color: #8B4513; }
    .cobblestone     { background-color: #808080; }
    .oil             { background-color: #2F4F4F; }
    /* cooler & heater */
    .cooler { background-color: #3399ff; }
    .heater { background-color: #ff3333; }
    /* Heat Separator, Input, Output, Not Gate, And Gate, Blocker */
    .heat-separator          { background-color: #ffef96; }
    .charged-heat-separator  { background-color: #ffe033; }
    .charged-down-heat-separator { background-color: #ffd700; }
    .input            { background-color: #646464; }
    .charged-input    { background-color: #ffff77; }
    .output           { background-color: #3636ff; }
    .charged-output   { background-color: #8888ff; }
    .not-gate         { background-color: #a15050; }
    .and-gate         { background-color: #405050; }
    .blocker          { background-color: #856fa8; }
    .charged-blocker  { background-color: #9b50a3; }

    .cloner { background-color: #cc00cc; }

    .coal         { background-color: #202020; }
    .coal-lump    { background-color: #303030; }
    .burning-coal         { background-color: #520f0f; }
    .burning-coal-lump    { background-color: #812626; }
    /* New element: Thermite â€“ tool styling */
    .thermite     { background-color: #AA4444; }
    .bomb         { background-color: #ff0000; }
    .big-bomb     { background-color: #ff3333; }
    .water-bomb   { background-color: #3366ff; }
    .fire-bomb    { background-color: #ff6600; }
    .cryo-bomb    { background-color: #00ccff; }
    .nuke-bomb    { background-color: #33cc33; } 
    .helium       { background-color: #e6f7ff; }
    .bouncy-ball  { background-color: #ff5599; } 
    .birch-seeds   { background-color: #8cff9b; }
    .tool.cell    { background-color: #00ff99; }
    .blood         { background-color: #cc0000; }
    .glass-shard   { background-color: #aaddff; }
    .sawdust      { background-color: #d9c29e; }
    .salt         { background-color: #ffffff; }

    .grind        { background-color: #777777; }
    
    /* New elements: Cell, Dead Cell, Blood, Glass Shard, and Sawdust */
    .cell-element { background-color: #00ff99 !important; }
    .dead-cell    { background-color: #666666; }
    .blood        { background-color: #cc0000; }
    .glass-shard  { background-color: #aaddff; }
    .sawdust      { background-color: #d9c29e; }
    

    /* HUD area for temp, element info, and FPS */
    #hud {
      position: fixed;
      top: 15px;
      left: 15px;
      background-color: rgba(0, 0, 0, 0.65);
      padding: 8px 12px;
      border-radius: 6px;
      font-family: 'Fira Code', 'Courier New', monospace;
      font-size: 12px;
      color: var(--text-primary);
      backdrop-filter: blur(5px);
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow);
      z-index: 100;
    }
    #hud div { margin: 5px 0; }
    /* Bottom controls */
    #bottomControls {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }
    #speedContainer {
      margin-bottom: 10px;
      text-align: center;
      color: #fff;
    }
    #speed {
      -webkit-appearance: none;
      appearance: none;
      width: 120px;
      background: #444;
      outline: none;
      border-radius: 5px;
      border: 1px solid #888;
      height: 6px;
      cursor: pointer;
    }
    #speed::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 12px;
      width: 12px;
      background: #888;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid #aaa;
    }
    #speedValue {
      margin-left: 20px;
      min-width: 40px;
      text-align: right;
      display: inline-block;
    }
    #clearAllBtn {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      font-size: 14px;
      padding: 8px 12px;
      cursor: pointer;
    }
    #clearAllBtn:hover { background-color: #555; }
    /* Extra Sidebar Buttons */
    #optionsButtonContainer, #saveLoadButtonContainer, #modButtonContainer, #communityButtonContainer {
      text-align: center;
    }
    #optionsButton, #saveLoadButton, #modButton, #communityButton {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      margin: 5px;
    }
    #optionsButton:hover, #saveLoadButton:hover, #modButton:hover, #communityButton:hover {
      background-color: #555;
    }
    /* Mod Manager Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: rgba(0,0,0,0.8);
    }
    .modal .modal-content {
      background-color: #333;
      margin-top: 5% auto;
      padding: 20px 20px;
      border: 1px solid #888;
      width: calc(100% - 20px);
      max-width: 600px;
      max-height: 90vh;
      bottom: 0;
      position: sticky;
      display: flex !important;
      flex-direction: column;
      overflow: auto;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 5;
      scrollbar-width: thin;
      scrollbar-color: #666 #333;
    }
    .modal .close {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
    }
    .modal .close:hover,
    .modal .close:focus {
      color: #fff;
      text-decoration: none;
      cursor: pointer;
    }
    .modal input[type="text"],
    .modal textarea,
    .modal select {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      background-color: #222;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      box-sizing: border-box;
    }
    .modal button {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
    }
    .modal button:hover {
      background-color: #555;
    }
    
    /* Community saves styles */
    #communitySavesList {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 15px;
    }
    
    #communitySavesList .loading,
    #communitySavesList .no-saves,
    #communitySavesList .error {
      padding: 10px;
      text-align: center;
      color: #ddd;
    }
    
    #communitySavesList .error {
      color: #ff6b6b;
    }
    
    .save-metadata {
      display: flex;
      flex-wrap: wrap;
      font-size: 0.8em;
      color: #aaa;
      margin-top: 5px;
    }
    
    .save-metadata > div {
      margin-right: 10px;
    }
    
    .save-publisher {
      font-style: italic;
    }
    
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      width: 100px;
      height: 100px;
      background-color: #222;
      border: 1px solid #444;
    }
    
    .preview-cell {
      width: 100%;
      height: 100%;
      background-color: #000;
    }
    
    .preview-error {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100px;
      height: 100px;
      background-color: #333;
      color: #ff6b6b;
      font-size: 0.8em;
      text-align: center;
    }
    
    .save-game-card {
      display: flex;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 5px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    
    .save-preview {
      flex: 0 0 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #222;
    }
    
    .save-info {
      flex: 1;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    
    .save-title {
      font-weight: bold;
      font-size: 1.1em;
      margin-bottom: 5px;
    }
    
    .save-description {
      color: #ccc;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    
    .load-save-button {
      align-self: flex-end;
      margin-top: auto;
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 5px 10px;
      cursor: pointer;
    }
    
    .load-save-button:hover {
      background-color: #555;
    }
    /* Styles for mod cards in the mod menu */
    .modCard {
      background-color: #444;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
    }
    .modCard h3 {
      margin: 0;
      font-size: 18px;
    }
    .modCard p {
      font-size: 14px;
      margin: 5px 0;
    }
    .modCard small {
      font-size: 12px;
      color: #aaa;
    }
    .modCard small.incompatible {
      color: red;
    }
    .modCard button {
      background-color: #555;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }
    .modCard button:hover {
      background-color: #666;
    }
    .acid          { background-color: #90EE90; }
    .acid-steam    { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud    { background-color: #98FB98; }
    .slime         { background-color: #006400; }
    /* Tool styles */
    .tool.heat { background: linear-gradient(45deg, #ff4500, #ffd700); }
    .tool.cool { background: linear-gradient(45deg, #00bfff, #87ceeb); }
    .tool.cook { background-color: #deb887; }
    .tool.mix { background: repeating-linear-gradient(45deg, #444, #666 10px); }
    .tool.move { background-color: #4169e1; }
    .tool.sponge { background-color: #ffa07a; }
    .tool.extinguish { background-color: #4682b4; }
    /* Add to existing styles */
    .options-section {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .options-section.experimental {
      background-color: #333;
      border-color: #ffd700;
    }

    .options-section h3 {
      margin-top: 0;
      color: #ffd700;
      font-size: 1.2em;
      letter-spacing: 0.5px;
    }

    .options-button {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      width: 100%;
      margin: 5px 0;
    }

    .options-button:hover {
      background-color: #555;
    }

    /* Make the saved games display in a grid */
    #savedGamesList {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      max-height: 280px;
      overflow-y: auto;
      padding: 10px 0;
    }

    /* Style for each save game card */
    .save-game-card {
      border: 1px solid #555;
      border-radius: 5px;
      padding: 10px;
      background-color: #333;
      display: flex;
      flex-direction: column;
    }

    /* Container for the preview image */
    .save-preview {
      width: 100%;
      height: 120px;
      margin-bottom: 10px;
      border: 1px solid #666;
      position: relative;
      overflow: hidden;
    }

    /* The actual preview grid */
    .preview-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: grid;
    }

    /* Info section with title and description */
    .save-info {
      margin-bottom: 10px;
    }

    .save-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
    }

    .save-description {
      font-size: 12px;
      color: #aaa;
      height: 30px;
      overflow: hidden;
    }

    /* Buttons at the bottom of each card */
    .save-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: auto;
    }

    .save-buttons button {
      padding: 5px 8px;
      font-size: 12px;
      background-color: #444;
      border: none;
      color: white;
      cursor: pointer;
    }

    .save-buttons button:hover {
      background-color: #555;
    }

    .save-buttons .load-button {
      background-color: #2a6496;
    }

    .save-buttons .load-button:hover {
      background-color: #337ab7;
    }

    /* Input groups and warnings */
    .input-group {
      margin-bottom: 10px;
      position: relative;
    }

    .input-group input {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      margin-bottom: 2px;
    }

    .input-warning {
      color: #ff6b6b;
      font-size: 12px;
      height: 15px;
      margin-top: 2px;
    }

    /* Info icon next to save title */
    .save-title-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }

    .save-title {
      font-weight: bold;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }

    .info-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #4286f4;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-left: 8px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .info-icon:hover {
      background-color: #2a6496;
    }

    /* Popup for save information */
    .save-info-popup {
      position: absolute;
      right: -250px;
      top: 0;
      width: 240px;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 5px;
      padding: 10px;
      z-index: 10;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      display: none;
    }

    .save-info-popup.active {
      display: block;
    }

    .save-game-card {
      position: relative;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
    }

    .info-label {
      color: #aaa;
    }

    .info-value {
      color: white;
      font-weight: bold;
    }

    .close-info {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 14px;
      color: #aaa;
    }

    .close-info:hover {
      color: white;
    }

    #popOutWindow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 10px;
      border: 2px solid #444;
      border-radius: 5px;
      display: none;
      z-index: 2000;
    }

    /* Mobile touch support */
    @media (max-width: 1024px) {
      #mainContainer {
        flex-direction: column;
        height: auto;
      }
      #grid {
        width: 100%;
        max-width: none;
        height: auto;
      }
      #sidePanel {
        width: 100%;
        min-width: 0;
        height: auto;
      }
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      #mainContainer {
        flex-direction: column;
        align-items: center;
        padding: 15px;
      }
      #sidePanel {
        width: 100%;
        max-width: 600px;
        margin-top: 20px;
        height: auto;
        max-height: 50vh;
      }
      #grid {
        max-width: 90vw;
        max-height: 90vw;
      }
    }
    
    @media (max-width: 768px) {
      #toolbar {
        justify-content: center;
      }
      #categoryMenu {
        justify-content: center;
      }
      #hud {
        font-size: 11px;
        padding: 6px 10px;
      }
    }

    /* Add dynamic lighting styles */
    .cell.lit {
      transition: background-color 0.1s ease;
    }

    .cell.glass.lit {
      transition: background-color 0.2s ease;
      mix-blend-mode: screen;
    }

    /* Add to existing styles */
    .option-item {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      transition: border-color 0.2s ease;
    }

    .option-item:hover {
      border-color: #666;
    }

    .option-description {
      color: #888;
      font-size: 0.9em;
      margin: 5px 0 0 0;
      font-style: italic;
    }

    /* Main menu specific styling */
    .main-menu {
      text-align: center;
      background-color: rgba(34, 34, 34, 0.95) !important;
      min-height: 500px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 40px 20px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .main-menu h1 {
      font-size: 3.5em;
      color: #fff;
      margin: 0;
      padding: 20px 0;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
      border-radius: 10px;
      margin-bottom: 40px;
    }

    .main-menu-buttons {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 30px;
      align-items: center;
      margin: 20px 0;
    }

    .main-menu-button {
      background: linear-gradient(45deg, #444, #333);
      border: 2px solid #666;
      border-radius: 10px;
      color: #fff;
      padding: 20px 40px;
      font-size: 1.4em;
      cursor: pointer;
      width: 250px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
    }

    .main-menu-button:hover {
      background: linear-gradient(45deg, #555, #444);
      border-color: #888;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
    }

    .main-menu-button:active {
      transform: scale(0.98);
    }

    .engine-info {
      padding: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      margin-top: 20px;
    }

    /* Main Menu Modal */
    #mainMenuModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    @media (max-width: 768px) {
      #mainMenuModal .modal-content {
        width: 95%;
        max-width: 400px;
        margin: 20px auto;
        padding: 20px;
      }
      
      .main-menu-buttons {
        flex-direction: column;
        gap: 15px;
      }
      
      .main-menu-button {
        width: 100%;
        padding: 15px;
        font-size: 18px;
      }
      
      .engine-info {
        flex-direction: column;
        gap: 10px;
        text-align: center;
        margin-top: 20px;
      }
    }

    /* Help Menu Styling */
    .help-menu {
      display: none;
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .help-content {
      background-color: #333;
      margin: 5% auto;
      padding: 30px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      border-radius: 15px;
      position: relative;
      display: flex;
      flex-direction: column;
      color: #fff;
    }

    .help-page {
      display: none;
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .help-page.active {
      display: block;
    }

    .help-navigation {
      display: flex;
      justify-content: space-between;
      padding: 20px 0;
      border-top: 1px solid #444;
      margin-top: 20px;
    }

    .help-nav-button {
      background: #444;
      border: none;
      padding: 10px 20px;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .help-nav-button:hover {
      background: #555;
    }

    .help-nav-button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    .help-close {
      position: absolute;
      right: 20px;
      top: 20px;
      font-size: 24px;
      color: #fff;
      cursor: pointer;
      background: none;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
    }

    .help-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Options modal height fix */
    .modal-content {
      margin: 2vh auto;
      flex-direction: column;
      max-height: 96vh;
    }
    
    /* Options content scrollable styles */
    .options-content {
      overflow-y: auto;
      padding-right: 10px;
      margin-right: -10px;
      flex: 1;
      max-height: calc(80vh - 120px);
      scrollbar-width: thin;
      scrollbar-color: #666 #333;
    }
    
    .options-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .options-content::-webkit-scrollbar-track {
      background: #333;
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb {
      background-color: #666;
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb:hover {
      background-color: #888;
    }
    
    #optionsModal h2 {
      position: sticky;
      top: 0;
      background-color: #333;
      margin-top: 0;
      padding-top: 10px;
      z-index: 5;
      color: #ffd700;
      text-align: center;
      font-size: 1.6em;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #optionsModal #applyOptionsButton #saveLoadModal {
      display: none !important;
      margin-top: 15px;
      background: linear-gradient(to bottom, #666, #444);
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      position: sticky;
      bottom: 0;
      width: calc(100% - 20px);
      margin-left: auto;
      margin-right: auto;
      border-top: 1px solid #444;
      padding-top: 15px;
      z-index: 5;
      background-color: #333;
    }
    
    #optionsModal #applyOptionsButton.show-clear-warning {
      display: block !important;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Modal footer style */
    .modal-footer {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #444;
      text-align: center;
    }

    /* Add to existing styles */
    .options-section.disabled {
      opacity: 0.5;
      pointer-events: none;
      position: relative;
    }

    .options-section.disabled::after {
      content: "Coming Soon";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
    }

    /* Confirmation Modal */
    .confirmation-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .confirmation-content {
      background-color: #333;
      margin: 15% auto;
      padding: 20px;
      width: 300px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      text-align: center;
      color: #fff;
    }

    .confirmation-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .confirmation-buttons button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .confirmation-yes {
      background-color: #4CAF50;
      color: white;
    }

    .confirmation-no {
      background-color: #f44336;
      color: white;
    }

    .confirmation-buttons button:hover {
      transform: scale(1.05);
    }

    /* Add styles for the apply button states */
    #applyOptionsButton {
      display: none;
    }

    #applyOptionsButton.show-clear-warning {
      display: block;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Community Button and Modal Styling */
    #communityButtonContainer {
      margin-top: 10px;
      text-align: center;
    }
    
    #communityButton {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    
    #communityButton:hover {
      background-color: #3a5a80;
    }
    
    /* Community Modal Styling */
    .login-form, .upload-form {
      margin: 15px 0;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input, .form-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
    }
    
    .form-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .message {
      margin-top: 10px;
      padding: 8px;
      border-radius: 4px;
    }
    
    .message.error {
      background-color: #ffebee;
      color: #c62828;
    }
    
    .message.success {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    
    .community-tabs {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 20px;
    }
    
    .community-tab-btn {
      background: none;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      font-size: 16px;
      border-bottom: 3px solid transparent;
      color: #fff;
    }
    
    .community-tab-btn.active {
      border-bottom: 3px solid #4a6fa5;
      font-weight: bold;
    }
    
    .community-tab-content {
      display: none;
    }
    
    .community-tab-content.active {
      display: block;
    }
    
    .community-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .community-filters select, .community-filters input {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
    }
    
    .community-filters input {
      flex-grow: 1;
    }
    
    .community-saves-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      max-height: 500px;
      overflow-y: auto;
    }
    
    .community-save-card {
      border: 1px solid #444;
      border-radius: 4px;
      padding: 15px;
      background-color: #333;
      position: relative;
    }
    
    .community-save-preview {
      width: 100%;
      height: 150px;
      background-color: #222;
      margin-bottom: 10px;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .community-save-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .community-save-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 5px;
      color: #fff;
    }
    
    .community-save-author, .community-save-date {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .community-save-description {
      font-size: 14px;
      margin-bottom: 10px;
      max-height: 60px;
      overflow: hidden;
      color: #ddd;
    }
    
    .community-save-actions {
      display: flex;
      justify-content: flex-end;
    }
    
    .community-save-actions button {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .community-save-actions button:hover {
      background-color: #3a5a80;
    }
    
    .local-saves-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #444;
      border-radius: 4px;
      margin-bottom: 15px;
      background-color: #222;
    }
    
    .local-save-item {
      padding: 10px;
      border-bottom: 1px solid #333;
      cursor: pointer;
      color: #ddd;
    }
    
    .local-save-item:last-child {
      border-bottom: none;
    }
    
    .local-save-item.selected {
      background-color: #2a4a70;
    }
    
    .local-save-item:hover {
      background-color: #444;
    }
    
    .community-loading {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }
    

  </style>
</head>
<body>
  <!-- Selected element notification (moved here to ensure it's available when scripts run) -->
  <div id="selectedElementNotification">
    <div class="element-color" id="selectedElementColor"></div>
    <span id="selectedElementName">Element</span>
  </div>

  <!-- Main Menu Modal -->
  <div id="mainMenuModal" class="modal" style="display: block;">
    <div class="modal-content main-menu">
      <h1>Sandbox Delta</h1>
      <div class="main-menu-buttons">
        <button id="beginGameBtn" class="main-menu-button">Begin Game</button>
        <button id="helpBtn" class="main-menu-button">Help</button>
        <button id="modsMenuBtn" class="main-menu-button">Mods (Alpha)</button>
      </div>
      <div class="engine-info">
        <span class="version-info">Sandbox Delta Version 0.7.1c</span>
        <span class="engine-version">Dabicco Engine 8.7.4</span>
      </div>
    </div>
  </div>

  <!-- Help Menu -->
  <div id="helpMenu" class="help-menu">
    <div class="help-content">
      <button class="help-close">&times;</button>
      <div class="help-page active" data-page="1">
        <h2>Welcome to Sandbox Delta</h2>
        <p>Sandbox Delta is a physics-based particle simulation game where you can experiment with various elements and their interactions. Create complex systems, generate reactions, and explore the possibilities!<br>The game is compiled on Dabicco Engine 8.7.4</p>
        
        <h3>Basic Controls</h3>
        <ul>
          <li>Left Click/Touch: Place selected element</li>
          <li>Right Click: Erase elements</li>
          <li>Mouse Wheel: Adjust brush size</li>
        </ul>

        <h3>Interface Overview</h3>
        <ul>
          <li>Main Grid: The simulation area where elements interact</li>
          <li>Side Panel: Contains element selection and categories</li>
          <li>Speed Slider: Controls simulation speed (0.0x to 4.0x)</li>
          <li>Element Search: Quick-find elements by name</li>
          <li>HUD: Shows temperature, selected element, and FPS</li>
        </ul>
      </div>

      <div class="help-page" data-page="2">
        <h2>Elements & Categories</h2>
        
        <h3>Basic Elements</h3>
        <ul>
          <li>Sand: Basic powder that falls and piles up</li>
          <li>Water: Flows and interacts with other elements</li>
          <li>Fire: Burns flammable materials and spreads</li>
          <li>Wood: Can be burned and supports plant growth</li>
          <li>Stone: Solid building material</li>
          <li>Wall: Indestructible barrier</li>
        </ul>

        <h3>Element Categories</h3>
        <ul>
          <li>Powders: Sand, Flour, Coal Lumps, etc.</li>
          <li>Liquids: Water, Lava, Oil, etc.</li>
          <li>Gases: Steam, Smoke, Gas, etc.</li>
          <li>Solids: Stone, Wood, Glass, etc.</li>
          <li>Life: Plants, Seeds, Birds, etc.</li>
          <li>Explosives: Bombs, Thermite</li>
          <li>Cooking: Dough, Bread, Meat</li>
          <li>Electricity: Copper, Circuits, Logic Gates</li>
        </ul>
      </div>

      <div class="help-page" data-page="3">
        <h2>Advanced Mechanics</h2>
        
        <h3>Temperature System</h3>
        <p>Elements have temperature properties that affect their behavior:</p>
        <ul>
          <li>Heat Transfer: Elements conduct heat between each other</li>
          <li>State Changes: Water boils to steam, lava cools to stone</li>
          <li>Reactions: High temperatures can cause burning, melting, or explosions</li>
          <li>Tools: Use Heat and Cool tools to manipulate temperature</li>
        </ul>

        <h3>Plant Growth</h3>
        <ul>
          <li>Wheat: Grows from seeds, produces flour</li>
          <li>Oak Trees: Complex growth with branches and leaves</li>
          <li>Grass: Spreads naturally on dirt</li>
          <li>Roots: Absorb water from wet soil</li>
        </ul>

        <h3>Special Tools</h3>
        <ul>
          <li>Mix Tool: Stirs elements together</li>
          <li>Move Tool: Precisely position elements</li>
          <li>Sponge: Removes burning materials</li>
          <li>Cook Tool: Process food items</li>
        </ul>
      </div>

      <div class="help-page" data-page="4">
        <h2>Advanced Features</h2>
        
        <h3>Electrical System</h3>
        <p>Create complex circuits and logic systems:</p>
        <ul>
          <li>Copper: Conducts electricity and heat</li>
          <li>Spark: Initiates electrical current</li>
          <li>Logic Gates: NOT, AND gates for circuits</li>
          <li>Input/Output: Control signal flow</li>
          <li>Heat Separator: Manages heat distribution</li>
        </ul>

        <h3>Chemical Reactions</h3>
        <ul>
          <li>Sand + Heat = Glass</li>
          <li>Water + Lava = Stone/Obsidian</li>
          <li>Flour + Water = Dough</li>
          <li>Dough + Heat = Bread</li>
          <li>Coal + Heat = Long-burning fuel</li>
        </ul>
      </div>

      <div class="help-page" data-page="5">
        <h2>Game Features</h2>
        
        <h3>Save System</h3>
        <ul>
          <li>Save/Load: Store and retrieve your creations</li>
          <li>Export: Share save files with other players</li>
          <li>Import: Load shared save files</li>
        </ul>

        <h3>World Generation</h3>
        <ul>
          <li>Terrain Generation: Create natural landscapes</li>
          <li>Cave Systems: Underground networks</li>
          <li>Ore Deposits: Find valuable materials</li>
          <li>Ecosystems: Plants and wildlife</li>
        </ul>

        <h3>Mod Support</h3>
        <ul>
          <li>Custom Elements: Add new materials</li>
          <li>New Behaviors: Modify element interactions</li>
          <li>Visual Effects: Change appearance</li>
          <li>Game Extensions: Add new features</li>
        </ul>

        <h3>Tips & Tricks</h3>
        <ul>
          <li>Use the search function to quickly find elements</li>
          <li>Adjust brush size for precise or broad placement</li>
          <li>Experiment with element combinations</li>
          <li>Watch temperature changes in the HUD</li>
          <li>Try the terrain generator for inspiration</li>
        </ul>
      </div>

      <div class="help-navigation">
        <button class="help-nav-button" id="prevPage" disabled>Previous Page</button>
        <span id="pageIndicator">Page 1 of 5</span>
        <button class="help-nav-button" id="nextPage">Next Page</button>
      </div>
    </div>
  </div>

  <script>
    // Help menu functionality
    document.addEventListener('DOMContentLoaded', function() {
      const helpMenu = document.getElementById('helpMenu');
      const helpBtn = document.getElementById('helpBtn');
      const closeHelpBtn = document.querySelector('.help-close');
      const prevPageBtn = document.getElementById('prevPage');
      const nextPageBtn = document.getElementById('nextPage');
      const pageIndicator = document.getElementById('pageIndicator');
      const pages = document.querySelectorAll('.help-page');
      let currentPage = 1;
      const totalPages = pages.length;

      function updatePageButtons() {
        prevPageBtn.disabled = currentPage === 1;
        nextPageBtn.disabled = currentPage === totalPages;
        pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
      }

      function showPage(pageNum) {
        pages.forEach(page => page.classList.remove('active'));
        document.querySelector(`[data-page="${pageNum}"]`).classList.add('active');
        currentPage = pageNum;
        updatePageButtons();
      }

      helpBtn.addEventListener('click', () => {
        helpMenu.style.display = 'block';
        showPage(1);
      });

      closeHelpBtn.addEventListener('click', () => {
        helpMenu.style.display = 'none';
      });

      prevPageBtn.addEventListener('click', () => {
        if (currentPage > 1) showPage(currentPage - 1);
      });

      nextPageBtn.addEventListener('click', () => {
        if (currentPage < totalPages) showPage(currentPage + 1);
      });

      // Fix for load save functionality
      document.getElementById('createCanvasBtn').addEventListener('click', function() {
        const creationMode = document.getElementById('gameCreationMode').value;
        
        if (creationMode === 'load') {
          // Initialize with default settings
          initGrid(50);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Show load menu
          const saveLoadModal = document.getElementById('saveLoadModal');
          saveLoadModal.style.display = 'block';
          saveLoadModal.querySelector('h2').textContent = 'Load';
          const saveSection = saveLoadModal.querySelector('div:first-of-type');
          if (saveSection) saveSection.style.display = 'none';
          updateSavedGamesList();
        } else {
          // Normal new game creation
          const size = parseInt(document.getElementById('newGameSizeSelect').value);
          const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
          
          initGrid(size);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Add terrain generation function if it doesn't exist
          if (typeof generateTerrain !== 'function') {
            window.generateTerrain = function() {
              // Simple terrain generation - create ground at the bottom half
              const groundLevel = Math.floor(GRID_SIZE * 0.7);
              
              for (let y = groundLevel; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                  // Mostly dirt with some sand and stone
                  const rand = Math.random();
                  if (rand < 0.7) {
                    grid[y][x] = DIRT;
                    temp[y][x] = 20;
                  } else if (rand < 0.9) {
                    grid[y][x] = SAND;
                    temp[y][x] = 20;
                  } else {
                    grid[y][x] = STONE;
                    temp[y][x] = 20;
                  }
                }
              }
              
              // Add some underground features
              for (let i = 0; i < Math.floor(GRID_SIZE/5); i++) {
                const caveX = Math.floor(Math.random() * GRID_SIZE);
                const caveY = Math.floor(groundLevel + Math.random() * (GRID_SIZE - groundLevel));
                const caveSize = 3 + Math.floor(Math.random() * 4);
                
                for (let dy = -caveSize; dy <= caveSize; dy++) {
                  for (let dx = -caveSize; dx <= caveSize; dx++) {
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance <= caveSize) {
                      const nx = caveX + dx;
                      const ny = caveY + dy;
                      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && ny >= groundLevel) {
                        grid[ny][nx] = EMPTY;
                        temp[ny][nx] = null;
                      }
                    }
                  }
                }
              }
              
              renderGrid();
            };
          }
          
          if (shouldGenerateTerrain) {
            generateTerrain();
          }
        }
      });
    });
  </script>

  <!-- New Game Modal -->
  <div id="newGameModal" class="modal">
    <div class="modal-content">
      <span id="closeNewGameModal" class="close">&times;</span>
      <h2>New Game</h2>
      <div class="options-section">
        <div class="option-item">
          <label for="gameCreationMode">Game Creation Mode:</label>
          <select id="gameCreationMode">
            <option value="new">New Game</option>
            <option value="load">Load Save</option>
          </select>
          <p class="option-description">Choose between creating a new game or loading an existing save.</p>
        </div>

        <div id="newGameOptions">
          <div class="option-item">
            <label for="newGameSizeSelect">Stage Size:</label>
            <select id="newGameSizeSelect">
              <option value="25">25x25x25</option>
              <option value="50" selected>50x50x50</option>
              <option value="75">75x75x75</option>
              <option value="100">100x100x100</option>
              <option value="125">125x125x125</option>
            </select>
            <p class="option-description">Changes the size of the simulation grid. Larger sizes may impact performance.</p>
          </div>

          <div class="option-item">
            <label for="generateTerrainToggle">Generate Terrain:</label>
            <select id="generateTerrainToggle">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Start with a procedurally generated world containing caves, ores, and surface features.</p>
          </div>
        </div>
      </div>
      <button id="createCanvasBtn" class="main-menu-button">Create Canvas</button>
    </div>
  </div>

  <script>
    // Game version updated to 0.7.1c
    window.currentGameVersion = "0.7.1c";

    // Initialize main menu system
    document.addEventListener('DOMContentLoaded', function() {
      const mainContainer = document.getElementById('mainContainer');
      const mainMenuModal = document.getElementById('mainMenuModal');
      const newGameModal = document.getElementById('newGameModal');
      const saveLoadModal = document.getElementById('saveLoadModal');
      const modMenu = document.getElementById('modMenu');
      const urlParams = getUrlParameters();

      // Update version displays
      document.querySelector('.version-info').textContent = `Sandbox Delta Version ${window.currentGameVersion}`;

      // Hide main container initially

      // Begin Game button
      document.getElementById('beginGameBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        newGameModal.style.display = 'block';
      });

      // Mods button
      document.getElementById('modsMenuBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        modMenu.style.display = 'block';
        updateModListUI();
      });

      // Add game creation mode handling
      document.getElementById('gameCreationMode').addEventListener('change', function(e) {
        const newGameOptions = document.getElementById('newGameOptions');
        const createCanvasBtn = document.getElementById('createCanvasBtn');
        
        if (e.target.value === 'load') {
          newGameOptions.style.display = 'none';
          createCanvasBtn.textContent = 'Continue to Load';
        } else {
          newGameOptions.style.display = 'block';
          createCanvasBtn.textContent = 'Create Canvas';
        }
      });

    // Update Create Canvas button behavior
    document.getElementById('createCanvasBtn').addEventListener('click', function() {
      const creationMode = document.getElementById('gameCreationMode').value;
      
      if (creationMode === 'load') {
        // Initialize with default settings
        initGrid(50);
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
        
        // Show load menu
        const saveLoadModal = document.getElementById('saveLoadModal');
        saveLoadModal.style.display = 'block';
        saveLoadModal.querySelector('h2').textContent = 'Load';
        const saveSection = saveLoadModal.querySelector('div:first-of-type');
        if (saveSection) saveSection.style.display = 'none';
        updateSavedGamesList();
      } else {
        // Normal new game creation
        const size = parseInt(document.getElementById('newGameSizeSelect').value);
        const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
        
        initGrid(size);
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
        
        if (shouldGenerateTerrain) {
          window.generateTerrain(); // Call the global function explicitly
        }
      }
    });

      // Update selected element notification
    // Direct mapping of element names to colors
    const ELEMENT_COLORS = {
      // Tools
      'eraser': '#FF0000',
      'heat': '#FF4500',
      'cool': '#1E90FF',
      'cook': '#FF8C00',
      'mix': '#9370DB',
      'move': '#FFD700',
      'sponge': '#F5F5DC',
      'extinguish': '#00BFFF',
      'grind': '#A9A9A9',
      
      // Basic Elements
      'sand': '#f4a460',
      'wall': '#666666',
      'water': '#1e7fdf',
      'salt-water': '#3aafff',
      'lava': '#ff4500',
      'stone': '#808080',
      'water-vapor': '#e0e0e0',
      'cloud': '#ffffff',
      'basalt': '#3c3c3c',
      'obsidian': '#333333',
      'molten-slag': '#ff6600',
      'copper': '#b87333',
      'steel': '#aaaaaa',
      'ice': '#cceeff',
      'wood': '#3B220E',
      'fire': '#ffcc00',
      'smoke': '#666666',
      'burning-wood': '#5a3310',
      'ash': '#444444',
      'glass': '#c2e9fb',
      'dirt': '#7B5E42',
      'wet-dirt': '#4d2e12',
      'wheat-seeds': '#bca136',
      'wheat': '#c2b280',
      'flour': '#f5f5dc',
      'dough': '#d2b48c',
      'bread': '#f4c986',
      'burning-organic': '#6a3400',
      'root': '#4a3a2f',
      'spark': '#ffdd00',
      'charged-copper': '#ff8c00',
      'charged-down-copper': '#cc6600',
      'oak-seeds': '#32CD32',
      'oak-leaves': '#228B22',
      'oak-baby-leaves': '#66bb6a',
      'oak-wood': '#8B4513',
      'dead-oak': '#5C4033',
      'burning-leaves': '#a0522d',
      'burning-root': '#ff4500',
      'dead-root': '#555555',
      'gas': 'rgba(200,200,200,0.2)',
      'burning-gas': '#ff6666',
      'acid': '#90EE90',
      'acid-steam': '#98FB98',
      'acid-cloud': '#98FB98',
      'slime': '#006400',
      'carbon-dioxide': 'rgba(128,128,128,0.2)',
      'oxygen': 'rgba(200,230,255,0.2)',
      'bird': '#B8860B',
      'meat': '#FF6B6B',
      'cooked-meat': '#8B4513',
      'cobblestone': '#808080',
      'oil': '#2F4F4F',
      'cooler': '#3399ff',
      'heater': '#ff3333',
      'heat-separator': '#ffef96',
      'charged-heat-separator': '#ffe033',
      'charged-down-heat-separator': '#ffd700',
      'input': '#646464',
      'charged-input': '#ffff77',
      'output': '#3636ff',
      'charged-output': '#8888ff',
      'not-gate': '#a15050',
      'and-gate': '#405050',
      'blocker': '#856fa8',
      'charged-blocker': '#9b50a3',
      'cloner': '#cc00cc',
      'coal': '#202020',
      'coal-lump': '#303030',
      'burning-coal': '#520f0f',
      'burning-coal-lump': '#812626',
      'thermite': '#AA4444',
      'burning-thermite': '#ffc31f',
      'bomb': '#ff0000',
      'big-bomb': '#ff3333',
      'water-bomb': '#3366ff',
      'fire-bomb': '#ff6600',
      'cryo-bomb': '#00ccff',
      'nuke-bomb': '#33cc33',
      'helium': '#e6f7ff',
      'bouncy-ball': '#ff5599',
      'cell': '#66cc99',
      'dead-cell': '#336644',
      'blood': '#cc0000',
      'glass-shard': '#e0f0ff',
      'sawdust': '#d9c29e',
      'salt': '#ffffff'
    };
    
    function updateSelectedElementNotification(toolElement) {
      try {
        // Get the tool's display name
        const toolName = toolElement.getAttribute('data-tool') || toolElement.getAttribute('title') || 'Unknown';
        let toolColor = '#FF0000'; // Default to red if we can't find a color
        
        // Try to find the element's class that matches our color map
        for (const className of toolElement.classList) {
          if (ELEMENT_COLORS[className]) {
            toolColor = ELEMENT_COLORS[className];
            break;
          }
        }
        
        // If we still don't have a color, try to find a span with color
        if (toolColor === '#FF0000') {
          const span = toolElement.querySelector('span');
          if (span) {
            const spanStyle = window.getComputedStyle(span);
            const spanColor = spanStyle.color || spanStyle.backgroundColor;
            if (spanColor && spanColor !== 'rgba(0, 0, 0, 0)' && spanColor !== 'transparent') {
              toolColor = spanColor;
            }
          }
        }
        
        // Get the notification elements
        const notification = document.getElementById('selectedElementNotification');
        const colorDisplay = document.getElementById('selectedElementColor');
        const nameDisplay = document.getElementById('selectedElementName');
        
        // Only proceed if all required elements exist
        if (!notification || !colorDisplay || !nameDisplay) {
          console.warn('Notification elements not found');
          return;
        }
        
        // Add a subtle animation class for the color swatch
        colorDisplay.style.animation = 'pulse 0.5s ease-in-out';
        
        // Remove the animation after it completes
        colorDisplay.addEventListener('animationend', function() {
          colorDisplay.style.animation = '';
        }, { once: true });
        
        // Update the color and text
        colorDisplay.style.backgroundColor = toolColor;
        nameDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
        
        // Show the notification with animation
        notification.classList.remove('visible');
        // Force reflow
        void notification.offsetWidth;
        notification.classList.add('visible');
        
        // Hide after 3 seconds
        clearTimeout(notification.timeoutId);
        notification.timeoutId = setTimeout(() => {
          notification.classList.remove('visible');
        }, 3000);
      } catch (error) {
        console.error('Error updating element notification:', error);
      }
    }
    
      // Function to handle tool clicks
    function handleToolClick() {
      updateSelectedElementNotification(this);
    }
    
    // Add click handlers to all tool elements
    function initializeToolClickHandlers() {
      const tools = document.querySelectorAll('.tool');
      console.log('Initializing click handlers for', tools.length, 'tools');
      
      tools.forEach(tool => {
        // Remove any existing click handlers to prevent duplicates
        tool.removeEventListener('click', handleToolClick);
        tool.addEventListener('click', handleToolClick);
      });
    }
    
    // Initialize tool click handlers when the DOM is fully loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeToolClickHandlers);
    } else {
      // DOM already loaded, initialize immediately
      setTimeout(initializeToolClickHandlers, 100);
    }
    
    // Re-initialize tool click handlers after loading a game or creating a new one
    const originalInitGrid = window.initGrid;
    if (originalInitGrid) {
      window.initGrid = function(size) {
        const result = originalInitGrid.call(this, size);
        // Small delay to ensure tools are created
        setTimeout(initializeToolClickHandlers, 100);
        return result;
      };
    }

      // Close buttons for modals
      document.getElementById('closeNewGameModal').addEventListener('click', function() {
        newGameModal.style.display = 'none';
        mainMenuModal.style.display = 'block';
      });

      // When closing save/load or mods menu, return to main menu if game hasn't started
      const closeModMenu = document.getElementById('closeModMenu');
      const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');

      // Variated Colors setting in Options menu
      const variatedColorsToggle = document.getElementById('variatedColorsToggle');
      const applyVariatedColors = document.getElementById('applyVariatedColors');
      
      // DSPLE setting in Options menu
      const dspleToggle = document.getElementById('dspleToggle');
      const applyDsple = document.getElementById('applyDsple');
      
      // Initialize toggles based on current settings
      variatedColorsToggle.value = window.isVariatedColorsEnabled ? '1' : '0';
      dspleToggle.value = window.isDspleEnabled ? '1' : '0';
      
      // Apply Variated Colors setting
      applyVariatedColors.addEventListener('click', function() {
        const newVariatedColorsSetting = variatedColorsToggle.value === '1';
        
        // If setting changed from disabled to enabled, reassign all color variations
        if (!window.isVariatedColorsEnabled && newVariatedColorsSetting) {
          reassignColorVariations();
        }
        
        // Update the setting
        window.isVariatedColorsEnabled = newVariatedColorsSetting;
        
        // Re-render the grid to apply changes
        renderGrid();
      });
      
      // Apply DSPLE setting
      applyDsple.addEventListener('click', function() {
        const newDspleSetting = dspleToggle.value === '1';
        
        // Update the setting
        window.isDspleEnabled = newDspleSetting;
        
        if (newDspleSetting) {
          // Initialize the lighting engine if enabling
          initDspleLightingEngine();
        } else {
          // Clean up lighting effects if disabling
          cleanupDspleLightingEngine();
        }
        
        // Re-render the grid to apply changes
        renderGrid();
      });
      
      closeModMenu.addEventListener('click', function() {
        modMenu.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      closeSaveLoadModal.addEventListener('click', function() {
        saveLoadModal.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      // Window click handlers
      window.addEventListener('click', function(event) {
        if (event.target === newGameModal) {
          newGameModal.style.display = 'none';
          mainMenuModal.style.display = 'block';
        }
        if (event.target === saveLoadModal) {
          saveLoadModal.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
        if (event.target === modMenu) {
          modMenu.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
      });
    });
  </script>

  <div id="mainContainer">
    <!-- The simulation grid (will be rebuilt based on stage size) -->
    <div id="grid">
      <!-- Hover overlay element -->
      <div id="hoverOverlay"></div>
    </div>
    <!-- Side panel -->
    <div id="sidePanel">
      <!-- Side content: two columns (element list and category menu) -->
      <div id="sideContent">
        <!-- Element list scroll area -->
        <div id="elementScroll">
          <div id="toolSearchContainer">
            <input type="text" id="toolSearch" placeholder="Search...">
            <select id="sortOrder" style="margin-left: 10px;">
              <option value="natural">Natural</option>
              <option value="alpha">A-Z</option>
              <option value="type">By Type</option>
            </select>
          </div>
          <div id="toolbar">
            <!-- Tools Section -->
            <div class="tool eraser" data-tool="eraser" data-cat="tools" title="Eraser"><span>Eraser</span></div>
            <div class="tool move" data-tool="move" data-cat="tools" title="Move Tool"><span>Move</span></div>
            <div class="tool heat" data-tool="heat" data-cat="tools" title="Heat Tool"><span>Heat</span></div>
            <div class="tool cool" data-tool="cool" data-cat="tools" title="Cool Tool"><span>Cool</span></div>
            <div class="tool cook" data-tool="cook" data-cat="tools" title="Cook Tool"><span>Cook</span></div>
            <div class="tool mix" data-tool="mix" data-cat="tools" title="Mix Tool"><span>Mix</span></div>
            <div class="tool sponge" data-tool="sponge" data-cat="tools" title="Sponge Tool"><span>Sponge</span></div>
            <div class="tool extinguish" data-tool="extinguish" data-cat="tools" title="Extinguish Tool"><span>Ext</span></div>
            <div class="tool grind" data-tool="grind" data-cat="tools" title="Grind Tool"><span>Grind</span></div>
            
            <!-- Basic Elements -->
            <div class="tool sand selected" data-tool="sand" data-cat="powders" title="Sand"><span>S</span></div>
            <div class="tool water" data-tool="water" data-cat="liquids" title="Water"><span>W</span></div>
            <div class="tool wall" data-tool="wall" data-cat="solids" title="Wall"><span>Wall</span></div>
            <div class="tool stone" data-tool="stone" data-cat="solids" title="Stone"><span>St</span></div>
            <div class="tool lava" data-tool="lava" data-cat="liquids" title="Lava"><span>Lv</span></div>
            <div class="tool ice" data-tool="ice" data-cat="solids" title="Ice"><span>I</span></div>
            <div class="tool water-vapor" data-tool="water-vapor" data-cat="gasses" title="Water Vapor"><span>V</span></div>
            
            <!-- Dirt & Related -->
            <div class="tool dirt" data-tool="dirt" data-cat="powders" title="Dirt"><span>Di</span></div>
            <div class="tool wet-dirt" data-tool="wet-dirt" data-cat="powders" title="Wet Dirt"><span>WDi</span></div>
            <div class="tool grass" data-tool="grass" data-cat="life" title="Grass"><span>Gr</span></div>
            
            <!-- Fire & Combustion -->
            <div class="tool fire" data-tool="fire" data-cat="gasses" title="Fire"><span>F</span></div>
            <div class="tool smoke" data-tool="smoke" data-cat="gasses" title="Smoke"><span>Sm</span></div>
            <div class="tool ash" data-tool="ash" data-cat="powders" title="Ash"><span>A</span></div>
            
            <!-- Wood & Related -->
            <div class="tool wood" data-tool="wood" data-cat="solids" title="Wood"><span>Wd</span></div>
            <div class="tool sawdust" data-tool="sawdust" data-cat="powders" title="Sawdust"><span>SDust</span></div>
            
            <!-- Glass & Related -->
            <div class="tool glass" data-tool="glass" data-cat="solids" title="Glass"><span>G</span></div>
            <div class="tool glass-shard" data-tool="glass-shard" data-cat="powders" title="Glass Shard"><span>GSh</span></div>
            
            <!-- Cooking -->
            <div class="tool wheat-seeds" data-tool="wheat-seeds" data-cat="life" title="Wheat Seeds"><span>WSeeds</span></div>
            <div class="tool flour" data-tool="flour" data-cat="powders,cooking" title="Flour"><span>Flr</span></div>
            <div class="tool dough" data-tool="dough" data-cat="cooking" title="Dough"><span>Dh</span></div>
            <div class="tool bread" data-tool="bread" data-cat="cooking" title="Bread"><span>Br</span></div>
            <div class="tool meat" data-tool="meat" data-cat="cooking" title="Meat"><span>Meat</span></div>
            <div class="tool cooked-meat" data-tool="cooked-meat" data-cat="cooking" title="Cooked Meat"><span>CMeat</span></div>
            
            <!-- Plant Life -->
            <div class="tool plant-root" data-tool="plant-root" data-cat="life" title="Plant Roots"><span>PR</span></div>
            <div class="tool oak-seeds" data-tool="oak-seeds" data-cat="life" title="Oak Tree Seeds"><span>OakS</span></div>
            <div class="tool birch-seeds" data-tool="birch-seeds" data-cat="life" title="Birch Tree Seeds"><span>BirchS</span></div>
            
            <!-- Electricity -->
            <div class="tool copper" data-tool="copper" data-cat="electricity" title="Copper"><span>Cu</span></div>
            <div class="tool spark" data-tool="spark" data-cat="electricity" title="Spark"><span>Sp</span></div>
            <div class="tool cooler" data-tool="cooler" data-cat="electricity" title="Cooler"><span>CL</span></div>
            <div class="tool heater" data-tool="heater" data-cat="electricity" title="Heater"><span>HT</span></div>
            <div class="tool heat-separator" data-tool="heat-separator" data-cat="electricity" title="Heat Separator"><span>HS</span></div>
            <div class="tool input" data-tool="input" data-cat="electricity" title="Input"><span>In</span></div>
            <div class="tool output" data-tool="output" data-cat="electricity" title="Output"><span>Out</span></div>
            <div class="tool cloner" data-tool="cloner" data-cat="special,electricity" title="Cloner"><span>Cloner</span></div>
            
            <!-- Liquids -->
            <div class="tool oil" data-tool="oil" data-cat="liquids" title="Oil"><span>Oil</span></div>
            <div class="tool acid" data-tool="acid" data-cat="liquids" title="Acid"><span>Ac</span></div>
            <div class="tool slime" data-tool="slime" data-cat="liquids" title="Slime"><span>Slime</span></div>
            <div class="tool blood" data-tool="blood" data-cat="liquids" title="Blood"><span>Blood</span></div>
            <div class="tool salt-water" data-tool="salt-water" data-cat="liquids" title="Salt Water"><span>SaltW</span></div>
            
            <!-- Gasses -->
            <div class="tool gas" data-tool="gas" data-cat="gasses" title="Gas"><span>Gas</span></div>
            <div class="tool oxygen" data-tool="oxygen" data-cat="gasses" title="Oxygen"><span>O2</span></div>
            <div class="tool carbon-dioxide" data-tool="carbon-dioxide" data-cat="gasses" title="Carbon Dioxide"><span>CO2</span></div>
            <div class="tool helium" data-tool="helium" data-cat="gasses" title="Helium"><span>He</span></div>
            
            <!-- Explosives -->
            <div class="tool bomb" data-tool="bomb" data-cat="explosives" title="Bomb"><span>B</span></div>
            <div class="tool big-bomb" data-tool="big-bomb" data-cat="explosives" title="Big Bomb"><span>GB</span></div>
            <div class="tool water-bomb" data-tool="water-bomb" data-cat="explosives" title="Water Bomb"><span>WB</span></div>
            <div class="tool nuke-bomb" data-tool="nuke-bomb" data-cat="explosives" title="Nuke Bomb"><span>Nuke</span></div>
            <div class="tool thermite" data-tool="thermite" data-cat="powders,explosives" title="Thermite"><span>Th</span></div>
            
            <!-- Metals -->
            <div class="tool steel" data-tool="steel" data-cat="solids" title="Steel"><span>Fe</span></div>
            
            <!-- Coal & Related -->
            <div class="tool coal" data-tool="coal" data-cat="solids" title="Coal"><span>Coal</span></div>
            <div class="tool coal-lump" data-tool="coal-lump" data-cat="solids" title="Coal Lump"><span>CLump</span></div>
            
            <!-- Rocks & Minerals -->
            <div class="tool cobblestone" data-tool="cobblestone" data-cat="powders" title="Cobblestone"><span>Cbl</span></div>
            <div class="tool salt" data-tool="salt" data-cat="powders" title="Salt"><span>Salt</span></div>
            
            <!-- Life Forms -->
            <div class="tool bird" data-tool="bird" data-cat="life" title="Bird"><span>Bird</span></div>
            <div class="tool cell" data-tool="cell" data-cat="life" title="Cell"><span>Cell</span></div>
            
            <!-- Special -->
            <div class="tool bouncy-ball" data-tool="bouncy-ball" data-cat="special" title="Bouncy Ball"><span>BB</span></div>
          </div>
        </div>
        <!-- Category menu (independent scroll area on the right) -->
        <div id="categoryMenu">
          <button data-category="all" class="selectedCat">All</button>
          <button data-category="tools">Tools</button>
          <button data-category="liquids">Liquids</button>
          <button data-category="powders">Powders</button>
          <button data-category="solids">Solids</button>
          <button data-category="gasses">Gasses</button>
          <button data-category="explosives">Explosives</button>
          <button data-category="life">Life</button>
          <button data-category="cooking">Cooking</button>
          <button data-category="electricity">Electricity Beta</button>
          <button data-category="special">Special</button>
        </div>
      </div>
      <!-- HUD (not scrollable) -->
      <div id="hud">
        <div id="hudTemp">Temp: -- Â°C</div>
        <div id="hudElem">Element: --</div>
        <div id="hudFPS">FPS: --</div>
      </div>
      <!-- Bottom controls (not scrollable) -->
      <div id="bottomControls">
        <div id="speedContainer">
          <label for="speed">Simulation Speed:</label>
          <input type="range" id="speed" min="0" max="5" step="0.01" value="1"/>
          <span id="speedValue">1</span>Ã—
        </div>
        <button id="clearAllBtn">Clear All</button>
      </div>
      <!-- Extra Sidebar Buttons -->
      <div id="optionsButtonContainer">
        <button id="optionsButton">Options</button>
      </div>
      <div id="saveLoadButtonContainer">
        <button id="saveLoadButton">Save/Load</button>
      </div>

      <div id="modButtonContainer">
        <button id="modButton">Mods</button>
      </div>
    </div>
  </div>

  <script>
    /***************************************************************
     * The Entire Game Script; Made By Dabicco (Compiled in Dabicco Engine). DO NOT COPY!!
     ***************************************************************/


    // Stage size is dynamic; default is 50.
    let GRID_SIZE = 50;
    // Initialize variables that are used before their declarations elsewhere
    // These were moved from later in the code to prevent 'before initialization' errors
    let dirtyGrid = [];
    let lastFrameTime = 0;
    // Reusable arrays for shuffling positions - moved from later in the code
    const reusablePositions = [];
    const reusableXPositions = [];
    // Tool constants
    const TOOL_HEAT         = 100;
    const TOOL_COOL         = 101;
    const TOOL_COOK         = 102;
    const TOOL_MIX          = 103;
    const TOOL_MOVE         = 104;
    const TOOL_SPONGE       = 105;
    const TOOL_EXTINGUISH   = 106;
    const TOOL_GRIND        = 107;

    const EMPTY             = 0;
    const ERASER            = 5;
    // Basic elements
    const SAND              = 1;
    const WALL              = 44;
    const WATER             = 2;
    const LAVA              = 3;
    const STONE             = 4;
    const WATER_VAPOR       = 6;
    const CLOUD             = 7;
    const BASALT            = 8;
    const OBSIDIAN          = 9;
    const MOLTEN_SLAG       = 10;
    const COPPER            = 11;
    const STEEL             = 12;
    const ICE               = 13;
    const WOOD              = 14;
    const FIRE              = 15;
    const SMOKE             = 16;
    const BURNING_WOOD      = 17;
    const ASH               = 18;
    const GLASS             = 19;
    const BOMB              = 20;
    // Additional
    const DIRT              = 21;
    const WET_DIRT          = 22;
    const WHEAT_SEEDS       = 23;
    const WHEAT             = 24;
    const FLOUR             = 25;
    const DOUGH             = 26;
    const BREAD             = 27;
    const ROOT              = 28;
    const BURNING_ORGANIC   = 29;
    const SPARK             = 30;
    const CHARGED_COPPER    = 31;
    const OAK_SEEDS         = 32;
    const OAK_LEAVES        = 33;
    const OAK_BABY_LEAVES   = 34;
    const DEAD_OAK          = 35;
    const WET_SAND          = 36;
    const GRASS             = 37;
    const DEAD_PLANT        = 38;
    const BURNING_LEAVES    = 39;
    const BURNING_ROOT      = 40;
    const DEAD_ROOT         = 41;
    const GAS               = 42;
    const BURNING_GAS       = 43;
    const CHARGED_DOWN_COPPER = 45;
    // COOLER & HEATER
    const COOLER            = 46;
    const HEATER            = 47;
    // Electric elements
    const HEAT_SEPARATOR                = 48;
    const CHARGED_HEAT_SEPARATOR        = 49;
    const CHARGED_DOWN_HEAT_SEPARATOR   = 50;
    const INPUT                         = 51;
    const CHARGED_INPUT                 = 52;
    const OUTPUT                        = 53;
    const CHARGED_OUTPUT                = 54;
    const NOT_GATE                      = 55;
    const AND_GATE                      = 56;
    const BLOCKER                       = 57;
    const CHARGED_BLOCKER               = 61;
    // Cloner
    const CLONER                        = 60;
    // New elements: Coal and Coal Lump
    const COAL              = 62;
    const COAL_LUMP         = 63;
    const BURNING_COAL      = 64;
    const BURNING_COAL_LUMP = 65;
    // New element: Thermite â€“ assign THERMITE and BURNING_THERMITE (ensure no conflict with mod Orange Juice)
    const THERMITE          = 68;
    const BURNING_THERMITE  = 69;
    // New elements
    const ACID              = 70;
    const ACID_STEAM        = 71;
    const ACID_CLOUD        = 72;
    const SLIME             = 73;
    // Additional new elements
    const CARBON_DIOXIDE    = 74;
    const OXYGEN            = 75;
    const BIRD             = 76;
    const MEAT             = 77;
    const COOKED_MEAT      = 78;
    const COBBLESTONE      = 79;
    const OIL              = 80;
    const BIG_BOMB         = 81;
    const WATER_BOMB       = 82;
    const FIRE_BOMB        = 83;
    const CRYO_BOMB        = 84;
    const NUKE_BOMB        = 85;
    const HELIUM           = 86;
    const BOUNCY_BALL      = 87;
    const BIRCH_SEEDS      = 88;
    const BIRCH_LEAVES     = 89;
    const BIRCH_BABY_LEAVES= 90;
    const BIRCH_WOOD       = 91;
    const DEAD_BIRCH       = 92;
    // New elements
    const CELL              = 93;
    const DEAD_CELL         = 94;
    const BLOOD             = 95;
    const GLASS_SHARD       = 96;
    const SAWDUST           = 97;
    // New elements: Salt and Salt Water
    const SALT             = 98;
    const SALT_WATER       = 99;
    // Simulation constants
    let speed               = 1;
    const simulationTimeStep= 0.1;
    const vaporTransformThreshold= 4;
    const diffusionRate     = 0.3;
    const fireTemperature   = 600;
    const burnDuration      = 1.5;
    const burnToAshChance   = 0.25;
    const fireLifetime      = 2.0;
    const glassTemp         = 1700;
    const bombExplosionRadius= 3;
    const wetDirtEvapTemp   = 100;
    const doughBakeTemp     = 120;
    const breadBurnTemp     = 1000;
    const sparkLifetime     = 0.5;
    const burningGasDuration= 2.0;
    const burnDurationCoal      = 10.0;
    const burnDurationCoalLump  = 5.0;
    // Salt properties
    const saltMeltingTemp = 801; // Melting point of salt in Celsius
    const saltWaterEvaporationRate = 0.02; // Rate at which salt water evaporates
    // Conduction rates
    const conductionRates = {
      // Base elements
      [EMPTY]: 0,
      [WALL]: 0, // I bloody broke wall ):
      [ERASER]: 0,
      
      // Metals (highest conductivity)
      [COPPER]: 4.0,       // Copper has excellent conductivity
      [CHARGED_COPPER]: 4.0,
      [CHARGED_DOWN_COPPER]: 4.0,
      [STEEL]: 1.5,        // Steel conducts well but less than copper
      
      // Liquids (moderate conductivity)
      [WATER]: 0.6,        // Water conducts heat moderately well
      [LAVA]: 0.8,         // Molten rock conducts better than water
      [MOLTEN_SLAG]: 0.7,
      [ACID]: 0.5,
      [OIL]: 0.3,          // Oil conducts less than water
      
      // Gases (poor conductivity but good convection)
      [WATER_VAPOR]: 0.2,  // Gases conduct poorly but move
      [CLOUD]: 0.15,
      [SMOKE]: 0.1,
      [GAS]: 0.15,
      [BURNING_GAS]: 0.2,
      [CARBON_DIOXIDE]: 0.15,
      [OXYGEN]: 0.15,
      [HELIUM]: 0.25,      // Helium conducts better than other gases
      [ACID_STEAM]: 0.2,
      [ACID_CLOUD]: 0.15,
      
      // Solids (varied conductivity)
      [STONE]: 0.3,
      [BASALT]: 0.25,
      [OBSIDIAN]: 0.2,
      [GLASS]: 0.15,       // Glass is a poor conductor
      [GLASS_SHARD]: 0.15,  // Glass shards conduct like glass
      [SAND]: 0.2,         // Sand conducts poorly
      [WET_SAND]: 0.3,     // Wet sand conducts better than dry
      [CELL]: 0.4,         // Cells conduct moderately well due to water content
      [BLOOD]: 0.5,        // Blood conducts like water
      [SAWDUST]: 0.1,
      [SALT]: 0.3,          // Salt conducts heat better than sand
      [SALT_WATER]: 0.5,   // Salt water conducts heat better than fresh water      // Sawdust is a poor conductor
      [DIRT]: 0.15,
      [WET_DIRT]: 0.25,
      [COBBLESTONE]: 0.25,
      [ICE]: 0.4,          // Ice conducts better than water
      
      // Organic materials (poor conductors)
      [WOOD]: 0.12,
      [BURNING_WOOD]: 0.15,
      [ROOT]: 0.1,
      [BURNING_ROOT]: 0.15,
      [DEAD_ROOT]: 0.08,
      [WHEAT]: 0.08,
      [WHEAT_SEEDS]: 0.07,
      [FLOUR]: 0.05,
      [DOUGH]: 0.1,
      [BREAD]: 0.08,
      [GRASS]: 0.07,
      [OAK_SEEDS]: 0.07,
      [OAK_LEAVES]: 0.08,
      [OAK_BABY_LEAVES]: 0.07,
      [DEAD_OAK]: 0.06,
      [BIRCH_SEEDS]: 0.07,
      [BIRCH_LEAVES]: 0.08,
      [BIRCH_BABY_LEAVES]: 0.07,
      [BIRCH_WOOD]: 0.11,
      [DEAD_BIRCH]: 0.06,
      [CELL]: 0.2,
      [DEAD_CELL]: 0.08,
      [BLOOD]: 0.5,
      [GLASS_SHARD]: 0.15,
      [SAWDUST]: 0.09,
      [SALT]: 0.2,          // Salt has moderate heat capacity
      [SALT_WATER]: 0.7,   // Salt water has higher heat capacity than fresh water
      [DEAD_PLANT]: 0.06,
      [BURNING_LEAVES]: 0.12,
      [BURNING_ORGANIC]: 0.15,
      [MEAT]: 0.3,         // Meat conducts better due to water content
      [COOKED_MEAT]: 0.2,  // Cooked meat conducts less as water evaporates
      
      // Special elements
      [FIRE]: 0.8,         // Fire transfers heat well
      [ASH]: 0.05,         // Ash is an insulator
      [COAL]: 0.2,
      [COAL_LUMP]: 0.15,
      [BURNING_COAL]: 0.4,
      [BURNING_COAL_LUMP]: 0.35,
      [THERMITE]: 0.3,
      [BURNING_THERMITE]: 1.2,  // Thermite reaction transfers heat extremely well
      [SLIME]: 0.3,
      
      // Electronic components
      [COOLER]: 1.0,       // Designed to transfer heat
      [HEATER]: 1.0,
      [HEAT_SEPARATOR]: 0.4,
      [CHARGED_HEAT_SEPARATOR]: 0.4,
      [CHARGED_DOWN_HEAT_SEPARATOR]: 0.4,
      [INPUT]: 0.3,
      [CHARGED_INPUT]: 0.3,
      [OUTPUT]: 0.3,
      [CHARGED_OUTPUT]: 0.3,
      [NOT_GATE]: 0.3,
      [AND_GATE]: 0.3,
      [BLOCKER]: 0.3,
      [CHARGED_BLOCKER]: 0.3,
      [CLONER]: 0.3,
      
      // Explosives (low conductivity for safety)
      [BOMB]: 0.1,
      [BIG_BOMB]: 0.1,
      [WATER_BOMB]: 0.1,
      [FIRE_BOMB]: 0.1,
      [CRYO_BOMB]: 0.1,
      [NUKE_BOMB]: 0.1,
      
      // Miscellaneous
      [SPARK]: 0.3,
      [BOUNCY_BALL]: 0.2
    };
    const heatCapacities = {
      // Base elements
      [EMPTY]: 1,
      [WALL]: 1000,
      [ERASER]: 1,
      
      // Metals (low heat capacity - heat up/cool quickly)
      [COPPER]: 0.4,       // Copper heats up quickly
      [CHARGED_COPPER]: 0.4,
      [CHARGED_DOWN_COPPER]: 0.4,
      [STEEL]: 0.5,        // Steel takes a bit more energy to heat
      
      // Liquids (high heat capacity - store heat well)
      [WATER]: 4.0,        // Water has very high heat capacity
      [SALT_WATER]: 3.9,    // Salt water has slightly lower heat capacity than pure water
      [LAVA]: 1.0,         // Molten rock has lower capacity than water
      [MOLTEN_SLAG]: 1.0,
      [ACID]: 3.0,
      [OIL]: 2.0,          // Oil has lower capacity than water
      
      // Gases (moderate heat capacity)
      [WATER_VAPOR]: 2.0,  // Steam holds less heat than water
      [CLOUD]: 2.0,
      [SMOKE]: 1.0,
      [GAS]: 1.0,
      [BURNING_GAS]: 0.8,
      [CARBON_DIOXIDE]: 0.8,
      [OXYGEN]: 0.9,
      [HELIUM]: 5.0,       // Helium has extremely high heat capacity
      [ACID_STEAM]: 2.0,
      [ACID_CLOUD]: 2.0,
      
      // New elements
      [CELL]: 2.0,        // Cell has moderate heat capacity like living tissue
      [DEAD_CELL]: 1.0,   // Dead cell has lower heat capacity
      [BLOOD]: 3.8,       // Blood has high heat capacity similar to water
      [GLASS_SHARD]: 0.8, // Glass has moderate-low heat capacity
      
      // Solids (varied heat capacity)
      [STONE]: 0.8,
      [BASALT]: 0.8,
      [OBSIDIAN]: 0.8,
      [GLASS]: 0.8,
      [SAND]: 0.8,
      [SALT]: 0.8,         // Similar to sand and other minerals
      [WET_SAND]: 1.2,     // Water increases heat capacity
      [DIRT]: 0.9,
      [WET_DIRT]: 1.3,
      [COBBLESTONE]: 0.8,
      [ICE]: 2.0,          // Ice has high heat capacity
      
      // Organic materials (moderate heat capacity)
      [WOOD]: 1.8,
      [BURNING_WOOD]: 1.0,
      [ROOT]: 1.8,
      [BURNING_ROOT]: 1.0,
      [DEAD_ROOT]: 1.5,
      [WHEAT]: 1.5,
      [WHEAT_SEEDS]: 1.2,
      [FLOUR]: 1.2,
      [DOUGH]: 2.0,        // Water content increases capacity
      [BREAD]: 1.5,
      [GRASS]: 1.5,
      [OAK_SEEDS]: 1.2,
      [OAK_LEAVES]: 1.5,
      [OAK_BABY_LEAVES]: 1.5,
      [DEAD_OAK]: 1.2,
      [BIRCH_SEEDS]: 1.2,
      [BIRCH_LEAVES]: 1.5,
      [BIRCH_BABY_LEAVES]: 1.5,
      [BIRCH_WOOD]: 1.7,
      [DEAD_BIRCH]: 1.2,
      [CELL]: 2.5,
      [DEAD_CELL]: 1.2,
      [BLOOD]: 3.5,
      [GLASS_SHARD]: 0.8,
      [DEAD_PLANT]: 1.2,
      [BURNING_LEAVES]: 0.8,
      [BURNING_ORGANIC]: 0.8,
      [MEAT]: 3.0,         // High water content means high capacity
      [COOKED_MEAT]: 1.5,  // Less water, lower capacity
      
      // Special elements
      [FIRE]: 0.2,         // Fire changes temperature quickly
      [ASH]: 0.8,
      [COAL]: 0.8,
      [COAL_LUMP]: 0.8,
      [BURNING_COAL]: 0.5,
      [BURNING_COAL_LUMP]: 0.5,
      [THERMITE]: 0.8,
      [BURNING_THERMITE]: 0.5,
      [SLIME]: 2.5,        // High water content
      
      // Electronic components (moderate capacity)
      [COOLER]: 1.0,
      [HEATER]: 1.0,
      [HEAT_SEPARATOR]: 1.0,
      [CHARGED_HEAT_SEPARATOR]: 1.0,
      [CHARGED_DOWN_HEAT_SEPARATOR]: 1.0,
      [INPUT]: 1.0,
      [CHARGED_INPUT]: 1.0,
      [OUTPUT]: 1.0,
      [CHARGED_OUTPUT]: 1.0,
      [NOT_GATE]: 1.0,
      [AND_GATE]: 1.0,
      [BLOCKER]: 1.0,
      [CHARGED_BLOCKER]: 1.0,
      [CLONER]: 1.0,
      
      // Explosives
      [BOMB]: 0.8,
      [BIG_BOMB]: 0.8,
      [WATER_BOMB]: 0.8,
      [FIRE_BOMB]: 0.8,
      [CRYO_BOMB]: 0.8,
      [NUKE_BOMB]: 0.8,
      
      // Miscellaneous
      [SPARK]: 0.2,
      [BOUNCY_BALL]: 1.5
    };
    // New Constants:
    // Add this after your element constants (SAND, WATER, etc.)
    const elementBaseColors = {
      // Basic elements
      [EMPTY]: '#000000',
      [SALT]: '#ffffff',
      [SALT_WATER]: '#1ea5ff',
      [SAND]: '#f4a460',
      [CELL]: '#66cc99',
      [DEAD_CELL]: '#336644',
      [BLOOD]: '#cc0000',
      [GLASS_SHARD]: '#e0f0ff',
      [SAWDUST]: '#d9c29e',
      [WALL]: '#666666',
      [WATER]: '#1e90ff',
      [LAVA]: '#ff4500',
      [STONE]: '#808080',
      [ERASER]: '#ffaaaa',
      
      // Gases and vapors
      [WATER_VAPOR]: '#e0e0e0',
      [CLOUD]: '#ffffff',
      [SMOKE]: '#666666',
      [GAS]: 'rgba(200,200,200,0.2)',
      [BURNING_GAS]: '#ff6666',
      [CARBON_DIOXIDE]: 'rgba(128,128,128,0.2)',
      [OXYGEN]: 'rgba(200,230,255,0.2)',
      [HELIUM]: '#e6f7ff',
      [ACID_STEAM]: '#98FB98',
      [ACID_CLOUD]: '#98FB98',
      
      // Rocks and minerals
      [BASALT]: '#555555',
      [OBSIDIAN]: '#333333',
      [MOLTEN_SLAG]: '#ff6600',
      [COBBLESTONE]: '#808080',
      [GLASS]: '#c2e9fb',
      
      // Metals
      [COPPER]: '#b87333',
      [STEEL]: '#aaaaaa',
      [CHARGED_COPPER]: '#ff8c00',
      [CHARGED_DOWN_COPPER]: '#cc6600',
      
      // Temperature elements
      [ICE]: '#cceeff',
      [FIRE]: '#ffcc00',
      [COOLER]: '#3399ff',
      [HEATER]: '#ff3333',
      
      // Wood and plants
      [WOOD]: '#3B220E',
      [BURNING_WOOD]: '#5a3310',
      [ROOT]: '#4a3a2f',
      [BURNING_ROOT]: '#ff4500',
      [DEAD_ROOT]: '#555555',
      [WHEAT_SEEDS]: '#bca136',
      [WHEAT]: '#c2b280',
      [OAK_SEEDS]: '#556b2f',
      [OAK_LEAVES]: '#228b22',
      [OAK_BABY_LEAVES]: '#32cd32',
      [DEAD_OAK]: '#8b4513',
      [BIRCH_SEEDS]: '#6b8e23',
      [BIRCH_LEAVES]: '#32cd32',
      [BIRCH_BABY_LEAVES]: '#7cfc00',
      [BIRCH_WOOD]: '#f5f5f5',
      [DEAD_BIRCH]: '#a9a9a9',
      [GRASS]: '#00aa00',
      [DEAD_PLANT]: '#555555',
      [BURNING_LEAVES]: '#a0522d',
      
      // Food and cooking
      [FLOUR]: '#f5f5dc',
      [DOUGH]: '#d2b48c',
      [BREAD]: '#f4c986',
      [MEAT]: '#FF6B6B',
      [COOKED_MEAT]: '#8B4513',
      
      // Earth elements
      [DIRT]: '#7B5E42',
      [WET_DIRT]: '#4d2e12',
      [WET_SAND]: '#d2a679',
      [ASH]: '#444444',
      
      // Special elements
      [BURNING_ORGANIC]: '#6a3400',
      [SPARK]: '#ffdd00',
      [ACID]: '#90EE90',
      [SLIME]: '#006400',
      [OIL]: '#2F4F4F',
      [BIRD]: '#B8860B',
      
      // Coal and combustibles
      [COAL]: '#202020',
      [COAL_LUMP]: '#303030',
      [BURNING_COAL]: '#ff4500',
      [BURNING_COAL_LUMP]: '#ff4500',
      [THERMITE]: '#AA4444',
      [BURNING_THERMITE]: '#ffc31f',
      
      // Electronic components
      [HEAT_SEPARATOR]: '#ffef96',
      [CHARGED_HEAT_SEPARATOR]: '#ffe033',
      [CHARGED_DOWN_HEAT_SEPARATOR]: '#ffd700',
      [INPUT]: '#646464',
      [CHARGED_INPUT]: '#ffff77',
      [OUTPUT]: '#3636ff',
      [CHARGED_OUTPUT]: '#8888ff',
      [NOT_GATE]: '#a15050',
      [AND_GATE]: '#405050',
      [BLOCKER]: '#856fa8',
      [CHARGED_BLOCKER]: '#9b50a3',
      [CLONER]: '#cc00cc',
      
      // Explosives
      [BOMB]: '#ff0000',
      [BIG_BOMB]: '#ff3333',
      [WATER_BOMB]: '#3366ff',
      [FIRE_BOMB]: '#ff6600',
      [CRYO_BOMB]: '#00ccff',
      [NUKE_BOMB]: '#33cc33',
      
      // Special objects
      [BOUNCY_BALL]: '#ff5599'
    };
    // Global arrays for grid state
    let grid = [], temp = [], moved = [];
    let vaporLife = [], cloudLife = [];
    let fireLife = [], smokeLife = [];
    let burningWoodTime = [];
    let wheatHeight = [], wheatMaxHeight = [], seedGrowthTime = [], rootLife = [];
    let sparkLife = [], sparkTimer = [];
    let smokeMaxLife = [], cloudMaxLife = [];
    let branchLevel = [], branchLen = [], branchMaxArr = [], branchSubCount = [];
    let branchDirX = [], branchDirY = [];
    let oakTreeGrowthTime = [], oakTreeHeight = [], oakTreeMaxHeight = [];
    let oakTreeRootTimer = [], oakTreeRootDepth = [], oakTreeRootMax = [];
    let grassStage = [];
    let burningGasTime = [];
    let chargedStateTime = [];
    // Bird movement arrays
    let birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
    let birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballVelocityX = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let ballVelocityY = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // New global variable: stroke thickness (in cells)
    let strokeThickness = 1;
    let isAltKeyDown = false;
    // Audio context for placement sounds
    let audioContext = null;
    // Initialize audio context on first user interaction
    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    // Game version updated to 0.5.0a
    const currentGameVersion = "0.7.1c";

    // Add these right after the GRID_SIZE declaration and before any functions
    // Global lighting system variables
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    
    // Graphics settings
    window.isVariatedColorsEnabled = true; // Default to enabled
    window.isDspleEnabled = false; // DSPLE disabled by default
    window.lightSources = []; // Array to store light sources
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };
    
    function getTemperatureAdjustedColor(baseColor, temperature, elementType, x, y) {
      // Parse the base color (handles both hex and rgb formats)
      let r, g, b;
      
      if (baseColor.startsWith('#')) {
        // Handle hex color
        const hex = baseColor.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
      } else if (baseColor.startsWith('rgb')) {
        // Handle rgb color
        const matches = baseColor.match(/\d+/g);
        r = parseInt(matches[0]);
        g = parseInt(matches[1]);
        b = parseInt(matches[2]);
      } else {
        // Default fallback
        return baseColor;
      }
      
      // Apply random variations if they exist for this cell
      if (colorVariations[y] && colorVariations[y][x]) {
        const variation = colorVariations[y][x];
        r = Math.floor(r * variation.r);
        g = Math.floor(g * variation.g);
        b = Math.floor(b * variation.b);
      }
      
      // For liquids, add a slight random variation each time to create a flowing effect
      if (elementType === WATER || elementType === LAVA || elementType === OIL || 
          elementType === ACID || elementType === MOLTEN_SLAG || elementType === BLOOD) {
        // Small random variation for liquids to create a flowing effect
        const liquidVariation = 0.02; 
        r = Math.floor(r * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
        g = Math.floor(g * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
        b = Math.floor(b * (1 + (Math.random() * liquidVariation * 2 - liquidVariation)));
      }
      
      // Adjust color based on temperature
      // Hot: more red/yellow, Cold: more blue
      if (temperature > 100) {
        // Hot - shift toward red/yellow
        const factor = Math.min((temperature - 100) / 900, 1); // Max effect at 1000Â°C
        r = Math.min(r + (255 - r) * factor * 0.7, 255);
        g = Math.max(g - g * factor * 0.3, 0);
        b = Math.max(b - b * factor * 0.5, 0);
      } else if (temperature < 0) {
        // Cold - shift toward blue
        const factor = Math.min(Math.abs(temperature) / 100, 1); // Max effect at -100Â°C
        r = Math.max(r - r * factor * 0.5, 0);
        g = Math.max(g - g * factor * 0.3, 0);
        b = Math.min(b + (255 - b) * factor * 0.5, 255);
      }
      
      // Only apply color variations if the feature is enabled
      if (window.isVariatedColorsEnabled) {
        // Apply stored color variation for non-liquid elements
        // For liquids, continue to use random variations
        const liquidElements = [WATER, LAVA, ACID, OIL, MOLTEN_SLAG, BLOOD];
        
        if (liquidElements.includes(elementType)) {
          // For liquids, add a new random variation each time
          const variation = 0.02;
          r = Math.min(Math.max(Math.floor(r * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
          g = Math.min(Math.max(Math.floor(g * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
          b = Math.min(Math.max(Math.floor(b * (1 + (Math.random() * variation * 2 - variation))), 0), 255);
        } else if (colorVariations[y][x]) {
          // For other elements, use the stored variation
          r = Math.min(Math.max(Math.floor(r * colorVariations[y][x].r), 0), 255);
          g = Math.min(Math.max(Math.floor(g * colorVariations[y][x].g), 0), 255);
          b = Math.min(Math.max(Math.floor(b * colorVariations[y][x].b), 0), 255);
        }
      }
      
      return `rgb(${r}, ${g}, ${b})`;
    }

    // Add this function to parse URL parameters
function getUrlParameters() {
  const params = {};
  const queryString = window.location.search.substring(1);
  const pairs = queryString.split('&');
  
  for (let i = 0; i < pairs.length; i++) {
    if(!pairs[i]) continue;
    const pair = pairs[i].split('=');
    params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  
  return params;
}

    // DSPLE (Dabicco Shader-Pixel Lighting Engine) functions
    let lightingCanvas = null;
    let lightingContext = null;
    let previousLightMap = null; // Store previous frame's light map for smooth transitions
    let lightingAnimationFrame = null; // Store animation frame ID
    
    // Initialize the DSPLE lighting engine
    function initDspleLightingEngine() {
      // Create lighting canvas overlay if it doesn't exist
      if (!lightingCanvas) {
        lightingCanvas = document.createElement('canvas');
        lightingCanvas.id = 'lightingCanvas';
        lightingCanvas.style.position = 'absolute';
        lightingCanvas.style.top = '0';
        lightingCanvas.style.left = '0';
        lightingCanvas.style.width = '100%';
        lightingCanvas.style.height = '100%';
        lightingCanvas.style.pointerEvents = 'none'; // Allow clicks to pass through
        lightingCanvas.style.zIndex = '1'; // Above the grid but below UI
        lightingCanvas.style.mixBlendMode = 'screen'; // Light blend mode
        lightingCanvas.style.imageRendering = 'pixelated'; // Ensure crisp pixel edges
        
        // Add the canvas to the grid container
        gridContainer.appendChild(lightingCanvas);
        
        // Get the context for drawing
        lightingContext = lightingCanvas.getContext('2d');
      }
      
      // Update canvas dimensions to match the grid
      updateLightingCanvasDimensions();
      
      // Initialize previous light map based on current grid size
      resetLightMap();
      
      // Start the lighting render loop
      lightingAnimationFrame = requestAnimationFrame(renderLighting);
      
      // Add resize observer to handle stage size changes
      if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver(entries => {
          if (window.isDspleEnabled) {
            updateLightingCanvasDimensions();
            resetLightMap();
          }
        });
        resizeObserver.observe(gridContainer);
      }
    }
    
    // Update lighting canvas dimensions to match the grid exactly
    function updateLightingCanvasDimensions() {
      if (lightingCanvas) {
        const gridRect = gridContainer.getBoundingClientRect();
        // Set the canvas size to exactly match the grid container
        lightingCanvas.width = gridRect.width;
        lightingCanvas.height = gridRect.height;
        
        // Ensure the canvas is positioned correctly
        lightingCanvas.style.top = '0';
        lightingCanvas.style.left = '0';
        lightingCanvas.style.width = '100%';
        lightingCanvas.style.height = '100%';
      }
    }
    
    // Reset the light map based on current grid size
    function resetLightMap() {
      previousLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    }
    
    // Clean up the DSPLE lighting engine
    function cleanupDspleLightingEngine() {
      if (lightingCanvas) {
        // Cancel animation frame if active
        if (lightingAnimationFrame) {
          cancelAnimationFrame(lightingAnimationFrame);
          lightingAnimationFrame = null;
        }
        
        // Remove the lighting canvas
        gridContainer.removeChild(lightingCanvas);
        lightingCanvas = null;
        lightingContext = null;
        previousLightMap = null;
      }
    }
    
    // Identify light sources in the grid
    function identifyLightSources() {
      // Clear existing light sources
      window.lightSources = [];
      
      // Define elements that emit light
      const lightEmitters = {
        [FIRE]: { intensity: 1.0, radius: 8, color: '#ffcc00' },
        [LAVA]: { intensity: 0.8, radius: 6, color: '#ff4500' },
        [BURNING_WOOD]: { intensity: 0.7, radius: 5, color: '#ff6600' },
        [BURNING_LEAVES]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_ORGANIC]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_ROOT]: { intensity: 0.6, radius: 4, color: '#ff6600' },
        [BURNING_COAL]: { intensity: 0.9, radius: 7, color: '#ff4500' },
        [BURNING_COAL_LUMP]: { intensity: 1.0, radius: 8, color: '#ff4500' },
        [BURNING_THERMITE]: { intensity: 1.2, radius: 10, color: '#ffff00' },
        [BURNING_GAS]: { intensity: 0.5, radius: 4, color: '#ff6666' },
        [CHARGED_COPPER]: { intensity: 0.4, radius: 3, color: '#ff8c00' },
        [CHARGED_DOWN_COPPER]: { intensity: 0.3, radius: 2, color: '#cc6600' },
        [SPARK]: { intensity: 0.9, radius: 5, color: '#ffdd00' },
        [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, radius: 3, color: '#ffe033' },
        [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, radius: 2, color: '#ffd700' },
        [CHARGED_INPUT]: { intensity: 0.4, radius: 3, color: '#ffff77' },
        [CHARGED_OUTPUT]: { intensity: 0.4, radius: 3, color: '#8888ff' },
        [MOLTEN_SLAG]: { intensity: 0.8, radius: 6, color: '#ff4500' }
      };
      
      // Scan the grid for light sources
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          
          // Check if this element is a light emitter
          if (lightEmitters[element]) {
            const emitter = lightEmitters[element];
            
            // Get temperature for intensity variation
            const temperature = temp[y][x] || 20;
            let intensityMod = 1.0;
            
            // Increase intensity with temperature for fire elements
            if ([FIRE, BURNING_WOOD, BURNING_LEAVES, BURNING_ORGANIC, BURNING_COAL, BURNING_COAL_LUMP, BURNING_THERMITE].includes(element)) {
              intensityMod = Math.min(1.0 + (temperature - 500) / 1000, 2.0);
            }
            
            // Add to light sources
            window.lightSources.push({
              x: x,
              y: y,
              intensity: emitter.intensity * intensityMod,
              radius: emitter.radius,
              color: emitter.color
            });
          }
        }
      }
    }
    
    // Render the lighting effects
    function renderLighting() {
      // Only continue if DSPLE is enabled
      if (!window.isDspleEnabled || !lightingContext) {
        return;
      }
      
      // Identify light sources
      identifyLightSources();
      
      // Clear the canvas
      lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
      
      // Calculate cell size
      const cellSize = lightingCanvas.width / GRID_SIZE;
      
      // Create a grid-based lighting map for the current frame
      const currentLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // For each light source, calculate its contribution to each cell
      for (const source of window.lightSources) {
        // Parse the color
        let r, g, b;
        if (source.color.startsWith('#')) {
          const hex = source.color.substring(1);
          r = parseInt(hex.substring(0, 2), 16);
          g = parseInt(hex.substring(2, 4), 16);
          b = parseInt(hex.substring(4, 6), 16);
        } else {
          // Default to orange if color format is unknown
          r = 255;
          g = 165;
          b = 0;
        }
        
        // Calculate the light's influence area
        const radius = Math.ceil(source.radius);
        // Reduce intensity by 40% to make lighting less intense
        const intensity = source.intensity * 0.6;
        
        // Loop through cells in the influence area
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            const nx = source.x + dx;
            const ny = source.y + dy;
            
            // Skip if out of bounds
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
            
            // Calculate distance (in cells) from light source
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // Skip if outside the radius
            if (distance > radius) continue;
            
            // More realistic voxel-based lighting with inverse square law falloff
            // Use a steeper falloff curve for more realistic light propagation
            const falloff = Math.pow(1 - Math.min(distance / radius, 1), 2);
            const cellIntensity = intensity * falloff;
            
            // Initialize the cell's light value if needed
            if (!currentLightMap[ny][nx]) {
              currentLightMap[ny][nx] = { r: 0, g: 0, b: 0, a: 0 };
            }
            
            // Add this light's contribution (additive blending)
            // Reduce RGB values for less intensity
            currentLightMap[ny][nx].r += r * cellIntensity;
            currentLightMap[ny][nx].g += g * cellIntensity;
            currentLightMap[ny][nx].b += b * cellIntensity;
            currentLightMap[ny][nx].a = Math.min(currentLightMap[ny][nx].a + cellIntensity * 0.3, 0.7); // Reduced alpha cap
          }
        }
      }
      
      // Create the final light map with smooth transitions from previous frame
      const finalLightMap = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Blend current frame with previous frame for smooth transitions
      const transitionSpeed = 0.2; // Lower = slower transitions (0.2 = 20% change per frame)
      
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const current = currentLightMap[y][x];
          const previous = previousLightMap[y][x];
          
          // If no light in current or previous frame, skip
          if (!current && !previous) continue;
          
          // Initialize final light map cell
          finalLightMap[y][x] = { r: 0, g: 0, b: 0, a: 0 };
          
          // If there's light in the current frame
          if (current) {
            if (previous) {
              // Blend with previous frame for smooth transition
              finalLightMap[y][x].r = previous.r + (current.r - previous.r) * transitionSpeed;
              finalLightMap[y][x].g = previous.g + (current.g - previous.g) * transitionSpeed;
              finalLightMap[y][x].b = previous.b + (current.b - previous.b) * transitionSpeed;
              finalLightMap[y][x].a = previous.a + (current.a - previous.a) * transitionSpeed;
            } else {
              // Fade in new light
              finalLightMap[y][x].r = current.r * transitionSpeed;
              finalLightMap[y][x].g = current.g * transitionSpeed;
              finalLightMap[y][x].b = current.b * transitionSpeed;
              finalLightMap[y][x].a = current.a * transitionSpeed;
            }
          } else if (previous) {
            // Fade out disappearing light
            finalLightMap[y][x].r = previous.r * (1 - transitionSpeed);
            finalLightMap[y][x].g = previous.g * (1 - transitionSpeed);
            finalLightMap[y][x].b = previous.b * (1 - transitionSpeed);
            finalLightMap[y][x].a = previous.a * (1 - transitionSpeed);
          }
        }
      }
      
      // Store the final light map for the next frame
      previousLightMap = finalLightMap;
      
      // Render the final light map to the canvas
      lightingContext.globalCompositeOperation = 'lighter';
      
      // Simple approach - just draw directly to match the grid exactly
      
      // First, clear the canvas with a fully transparent background
      lightingContext.clearRect(0, 0, lightingCanvas.width, lightingCanvas.height);
      
      // Draw each cell with exact matching to the grid cells
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const light = finalLightMap[y][x];
          if (light && light.a > 0.03) { // Lower threshold to catch fading lights
            // Clamp RGB values
            const r = Math.min(Math.max(Math.floor(light.r), 0), 255);
            const g = Math.min(Math.max(Math.floor(light.g), 0), 255);
            const b = Math.min(Math.max(Math.floor(light.b), 0), 255);
            const a = light.a;
            
            // Draw a full square for this cell with exact positioning
            lightingContext.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
            
            // Use the exact same cell size and position calculation as the main grid
            lightingContext.fillRect(
              x * cellSize, 
              y * cellSize, 
              cellSize, 
              cellSize
            );
          }
        }
      }
      
      // Continue the render loop
      lightingAnimationFrame = requestAnimationFrame(renderLighting);
    }
    
    // Function to reassign color variations to all cells
    function reassignColorVariations() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] !== EMPTY) {
            // Initialize color variation for this element
            const variation = 0.05;
            colorVariations[y][x] = {
              r: 1 + (Math.random() * variation * 2 - variation),
              g: 1 + (Math.random() * variation * 2 - variation),
              b: 1 + (Math.random() * variation * 2 - variation)
            };
          }
        }
      }
      renderGrid(); // Re-render the grid with new variations
    }
    
    // Function to initialize the grid based on GRID_SIZE.
    function initGrid(newSize) {
      GRID_SIZE = newSize;
      // Update grid DOM: set grid template columns/rows according to new size.
      gridContainer.innerHTML = "";
      gridContainer.appendChild(hoverOverlay);
      gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.style.gridTemplateRows = `repeat(${GRID_SIZE}, 1fr)`;
      
      // Reset all arrays
      grid = [];
      temp = [];
      moved = [];
      vaporLife = [];
      cloudLife = [];
      fireLife = [];
      smokeLife = [];
      burningWoodTime = [];
      wheatHeight = [];
      wheatMaxHeight = [];
      seedGrowthTime = [];
      rootLife = [];
      sparkLife = [];
      sparkTimer = [];
      smokeMaxLife = [];
      cloudMaxLife = [];
      branchLevel = [];
      branchLen = [];
      branchMaxArr = [];
      branchSubCount = [];
      branchDirX = [];
      branchDirY = [];
      oakTreeGrowthTime = [];
      oakTreeHeight = [];
      oakTreeMaxHeight = [];
      oakTreeRootTimer = [];
      oakTreeRootDepth = [];
      oakTreeRootMax = [];
      grassStage = [];
      burningGasTime = [];
      chargedStateTime = [];
      
      // Reset physics arrays
      ballVelocityX = [];
      ballVelocityY = [];
      
      // Reset color variations
      colorVariations = [];
      
      // Reset lighting arrays
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Initialize bird arrays
      birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
      birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

      cells.length = 0;
      for (let y = 0; y < GRID_SIZE; y++) {
        let row = [], trow = [], mrow = [];
        let vrow = [], crow = [], frow = [], srow = [], bwrow = [];
        let wH = [], wMH = [], sGT = [], rLifeRow = [];
        let spLifeRow = [], spTimerRow = [];
        let smaxrow = [], cmaxrow = [];
        let bLevel = [], bLen = [], bMax = [], bSub = [], bDirXrow = [], bDirYrow = [];
        let otGrowth = [], otHeight = [], otMaxHeight = [];
        let otRootTimer = [], otRootDepth = [], otRootMax = [];
        let grassRow = [];
        let burnGasRow = [];
        let cdtRow = [];
        let bVelX = [], bVelY = [];
        let colorVarRow = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          row.push(EMPTY);
          trow.push(null);
          mrow.push(false);
          vrow.push(0);
          crow.push(0);
          frow.push(0);
          srow.push(0);
          bwrow.push(0);
          wH.push(0);
          wMH.push(0);
          sGT.push(0);
          rLifeRow.push(0);
          spLifeRow.push(0);
          spTimerRow.push(0);
          smaxrow.push(1.0 + 2.0 * Math.random());
          cmaxrow.push(5.0 + 5.0 * Math.random());
          bLevel.push(-1);
          bLen.push(0);
          bMax.push(0);
          bSub.push(-1);
          bDirXrow.push(0);
          bDirYrow.push(0);
          otGrowth.push(0);
          otHeight.push(0);
          otMaxHeight.push(0);
          otRootTimer.push(0);
          otRootDepth.push(0);
          otRootMax.push(0);
          grassRow.push(1);
          burnGasRow.push(0);
          cdtRow.push(0);
          bVelX.push(0);
          bVelY.push(0);
          colorVarRow.push(null);
        }
        grid.push(row);
        temp.push(trow);
        moved.push(mrow);
        vaporLife.push(vrow);
        cloudLife.push(crow);
        fireLife.push(frow);
        smokeLife.push(srow);
        burningWoodTime.push(bwrow);
        wheatHeight.push(wH);
        wheatMaxHeight.push(wMH);
        seedGrowthTime.push(sGT);
        rootLife.push(rLifeRow);
        sparkLife.push(spLifeRow);
        sparkTimer.push(spTimerRow);
        smokeMaxLife.push(smaxrow);
        cloudMaxLife.push(cmaxrow);
        branchLevel.push(bLevel);
        branchLen.push(bLen);
        branchMaxArr.push(bMax);
        branchSubCount.push(bSub);
        branchDirX.push(bDirXrow);
        branchDirY.push(bDirYrow);
        oakTreeGrowthTime.push(otGrowth);
        oakTreeHeight.push(otHeight);
        oakTreeMaxHeight.push(otMaxHeight);
        oakTreeRootTimer.push(otRootTimer);
        oakTreeRootDepth.push(otRootDepth);
        oakTreeRootMax.push(otRootMax);
        grassStage.push(grassRow);
        burningGasTime.push(burnGasRow);
        chargedStateTime.push(cdtRow);
        ballVelocityX.push(bVelX);
        ballVelocityY.push(bVelY);
        colorVariations.push(colorVarRow);
        // Create cell divs.
        let rowOfCells = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.id = `cell-${x}-${y}`;
          gridContainer.appendChild(cell);
          rowOfCells.push(cell);
        }
        cells.push(rowOfCells);
      }
      
      // Reinitialize lighting arrays when grid size changes
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      
      // Initialize dirtyGrid to mark all cells as needing rendering
      dirtyGrid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(true));
      
      // Reinitialize the reusable arrays for position shuffling
      reusablePositions.length = 0;
      reusableXPositions.length = 0;
      for (let i = 0; i < GRID_SIZE; i++) {
        reusablePositions.push(i);
        reusableXPositions.push(i);
      }
    }
    /***************************************
     * DOM
     ***************************************/
    const gridContainer = document.getElementById('grid');
    const hoverOverlay = document.getElementById('hoverOverlay');
    const toolElements = document.getElementsByClassName('tool');
    const speedSlider = document.getElementById('speed');
    const speedValueDisplay = document.getElementById('speedValue');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const hudTemp = document.getElementById('hudTemp');
    const hudElem = document.getElementById('hudElem');
    const hudFPS = document.getElementById('hudFPS');
    const toolSearch = document.getElementById('toolSearch');
    const toolbar = document.getElementById('toolbar');
    const categoryButtons = document.querySelectorAll('#categoryMenu button');
    const sortOrder = document.getElementById('sortOrder');
    let activeCategory = 'all';
    
    // Store the original order of tools for 'Natural' sort
    let originalToolsOrder = [];
    
    // Function to sort tools
    function sortTools() {
      const tools = Array.from(document.querySelectorAll('.tool'));
      const eraser = tools.find(tool => tool.dataset.tool === 'eraser');
      let otherTools = tools.filter(tool => tool !== eraser);
      
      // Store original order on first sort
      if (originalToolsOrder.length === 0) {
        originalToolsOrder = [...otherTools];
      }
      
      // Sort based on selected option
      const sortBy = sortOrder.value;
      
      if (sortBy === 'alpha') {
        otherTools.sort((a, b) => {
          return a.getAttribute('title').localeCompare(b.getAttribute('title'));
        });
      } else if (sortBy === 'type') {
        const categoryOrder = {
          'tools': 1,
          'liquids': 2,
          'powders': 3,
          'solids': 4,
          'gasses': 5,
          'explosives': 6,
          'life': 7,
          'cooking': 8,
          'electricity': 9,
          'special': 10
        };
        
        otherTools.sort((a, b) => {
          const catA = a.dataset.cat.split(',')[0]; // Get primary category
          const catB = b.dataset.cat.split(',')[0];
          return (categoryOrder[catA] || 99) - (categoryOrder[catB] || 99) || 
                 a.getAttribute('title').localeCompare(b.getAttribute('title'));
        });
      } else if (sortBy === 'natural') {
        // Restore original order
        otherTools = [...originalToolsOrder];
      }
      
      // Rebuild toolbar with sorted elements (keep eraser first)
      toolbar.innerHTML = '';
      if (eraser) toolbar.appendChild(eraser);
      otherTools.forEach(tool => toolbar.appendChild(tool));
      
      // Reattach event listeners
      document.querySelectorAll('.tool').forEach(el => {
        el.addEventListener('click', () => selectTool(el));
      });
    }
    
    // Add event listeners for sorting
    if (sortOrder) {
      sortOrder.addEventListener('change', sortTools);
      // Initial sort
      sortTools();
    }
    const cells = [];
    // The initGrid function will create the cells.
    initGrid(50); // Default stage size 50x50x50
    let currentTool = SAND;
    function selectTool(el) {
      Array.from(toolElements).forEach(t => t.classList.remove('selected'));
      el.classList.add('selected');
      const name = el.getAttribute('data-tool');
      switch (name) {
        case "eraser": currentTool = ERASER; break;
        case "sand": currentTool = SAND; break;
        case "wall": currentTool = WALL; break;
        case "water": currentTool = WATER; break;
        case "lava": currentTool = LAVA; break;
        case "stone": currentTool = STONE; break;
        case "water-vapor": currentTool = WATER_VAPOR; break;
        case "copper": currentTool = COPPER; break;
        case "steel": currentTool = STEEL; break;
        case "ice": currentTool = ICE; break;
        case "wood": currentTool = WOOD; break;
        case "fire": currentTool = FIRE; break;
        case "smoke": currentTool = SMOKE; break;
        case "ash": currentTool = ASH; break;
        case "glass": currentTool = GLASS; break;
        case "bomb": currentTool = BOMB; break;
        case "dirt": currentTool = DIRT; break;
        case "wet-dirt": currentTool = WET_DIRT; break;
        case "wheat-seeds": currentTool = WHEAT_SEEDS; break;
        case "flour": currentTool = FLOUR; break;
        case "dough": currentTool = DOUGH; break;
        case "bread": currentTool = BREAD; break;
        case "plant-root": currentTool = ROOT; break;
        case "spark": currentTool = SPARK; break;
        case "oak-seeds": currentTool = OAK_SEEDS; break;
        case "grass": currentTool = GRASS; break;
        case "gas": currentTool = GAS; break;
        case "cooler": currentTool = COOLER; break;
        case "heater": currentTool = HEATER; break;
        case "heat-separator": currentTool = HEAT_SEPARATOR; break;
        case "input": currentTool = INPUT; break;
        case "output": currentTool = OUTPUT; break;
        case "not-gate": currentTool = NOT_GATE; break;
        case "and-gate": currentTool = AND_GATE; break;
        case "blocker": currentTool = BLOCKER; break;
        case "cloner": currentTool = CLONER; break;
        case "coal": currentTool = COAL; break;
        case "coal-lump": currentTool = COAL_LUMP; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "heat": currentTool = TOOL_HEAT; break;
        case "cool": currentTool = TOOL_COOL; break;
        case "cook": currentTool = TOOL_COOK; break;
        case "mix": currentTool = TOOL_MIX; break;
        case "move": currentTool = TOOL_MOVE; break;
        case "sponge": currentTool = TOOL_SPONGE; break;
        case "extinguish": currentTool = TOOL_EXTINGUISH; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "carbon-dioxide": currentTool = CARBON_DIOXIDE; break;
        case "oxygen": currentTool = OXYGEN; break;
        case "bird": currentTool = BIRD; break;
        case "meat": currentTool = MEAT; break;
        case "cooked-meat": currentTool = COOKED_MEAT; break;
        case "cobblestone": currentTool = COBBLESTONE; break;
        case "oil": currentTool = OIL; break;
        case "big-bomb": currentTool = BIG_BOMB; break;
        case "water-bomb": currentTool = WATER_BOMB; break;
        case "fire-bomb": currentTool = FIRE_BOMB; break;
        case "cryo-bomb": currentTool = CRYO_BOMB; break;
        case "nuke-bomb": currentTool = NUKE_BOMB; break;
        case "helium": currentTool = HELIUM; break;
        case "bouncy-ball": currentTool = BOUNCY_BALL; break;
        case "birch-seeds": currentTool = BIRCH_SEEDS; break;
        case "cell": currentTool = CELL; break;
        case "blood": currentTool = BLOOD; break;
        case "glass-shard": currentTool = GLASS_SHARD; break;
        case "sawdust": currentTool = SAWDUST; break;
        case "grind": currentTool = TOOL_GRIND; break;
        case "salt": currentTool = SALT; break;
        case "salt-water": currentTool = SALT_WATER; break;
      }
    }
    Array.from(toolElements).forEach(el => { el.addEventListener('click', () => selectTool(el)); });
    speedSlider.addEventListener('input', e => { speed = parseFloat(e.target.value); speedValueDisplay.textContent = speed.toFixed(2); });
    clearAllBtn.addEventListener('click', () => { for (let y = 0; y < GRID_SIZE; y++) { for (let x = 0; x < GRID_SIZE; x++) { eraseCell(x, y); } } });
    let isLeftMouseDown = false, isRightMouseDown = false;
    let hoveredX = null, hoveredY = null;
    let isTouching = false;
    let touchX = null, touchY = null;
    
    // Touch event handlers
    gridContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isTouching = true;
        const touch = e.touches[0];
        const pos = getMousePos(touch);
        touchX = pos.x;
        touchY = pos.y;
        hoveredX = pos.x;
        hoveredY = pos.y;
        
        // Handle touch as left click
        onMouseDown(e);
        placeElementAt(pos.x, pos.y, currentTool);
    });

    gridContainer.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isTouching) return;
        const touch = e.touches[0];
        const pos = getMousePos(touch);
        touchX = pos.x;
        touchY = pos.y;
        hoveredX = pos.x;
        hoveredY = pos.y;
        updateHoverOverlay();
        placeElementAt(pos.x, pos.y, currentTool);
    });

    gridContainer.addEventListener('touchend', (e) => {
        e.preventDefault();
        isTouching = false;
        touchX = null;
        touchY = null;
        hoveredX = null;
        hoveredY = null;
        onMouseUp(e);
    });

    // Override getMousePos to handle touch events
    // Function to get grid coordinates from touch/mouse event
    function getMousePos(e) {
        const rect = gridContainer.getBoundingClientRect();
        const x = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
        const y = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
        const gridX = Math.floor((x - rect.left) / (rect.width / GRID_SIZE));
        const gridY = Math.floor((y - rect.top) / (rect.height / GRID_SIZE));
        
        // Ensure coordinates are within grid bounds
        return {
            x: Math.max(0, Math.min(GRID_SIZE - 1, gridX)),
            y: Math.max(0, Math.min(GRID_SIZE - 1, gridY))
        };
    };
    function onMouseDown(e) {
      e.preventDefault();
      if (e.button === 0) isLeftMouseDown = true;
      else if (e.button === 2) isRightMouseDown = true;
    }
    function onMouseUp(e) {
      if (e) e.preventDefault();
      isLeftMouseDown = false;
      isRightMouseDown = false;
    }
    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('mouseleave', () => {
      isLeftMouseDown = false;
      isRightMouseDown = false;
      hoveredX = null; hoveredY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });
    gridContainer.addEventListener('mousemove', e => { const { x, y } = getMousePos(e); hoveredX = x; hoveredY = y; });
    // Listen for scroll (wheel) events to adjust stroke thickness.
    gridContainer.addEventListener('wheel', e => {
      e.preventDefault();
      if (e.deltaY < 0) {
        // Increase stroke thickness
        if (!isAltKeyDown) {
          // For circular selection, only allow odd numbers
          strokeThickness = Math.min(strokeThickness + 2, 49);
          if (strokeThickness % 2 === 0) strokeThickness--;
        } else {
          // For square selection, allow all numbers
          strokeThickness = Math.min(strokeThickness + 1, 50);
        }
      } else {
        // Decrease stroke thickness
        if (!isAltKeyDown) {
          // For circular selection, only allow odd numbers
          strokeThickness = Math.max(strokeThickness - 2, 1);
          if (strokeThickness % 2 === 0 && strokeThickness > 1) strokeThickness--;
        } else {
          // For square selection, allow all numbers
          strokeThickness = Math.max(strokeThickness - 1, 1);
        }
      }
    });
    
    // Listen for ALT key press/release to toggle between circle and square
    document.addEventListener('keydown', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = true;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    document.addEventListener('keyup', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = false;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    // Initialize audio on first user interaction
    document.addEventListener('mousedown', initAudioContext, { once: true });
    
    // Listen for ALT key press/release to toggle between circle and square
    document.addEventListener('keydown', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = true;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    document.addEventListener('keyup', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = false;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    // Initialize audio on first user interaction
    document.addEventListener('mousedown', initAudioContext, { once: true });
    
    // Listen for ALT key press/release to toggle between circle and square
    document.addEventListener('keydown', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = true;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    
    document.addEventListener('keyup', e => {
      if (e.key === 'Alt') {
        isAltKeyDown = false;
        updateHoverOverlay();
        e.preventDefault();
      }
    });
    function getMousePos(e) {
      // Use clientWidth to avoid scaling issues.
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let px = Math.floor((e.clientX - rect.left) / cellSize);
      let py = Math.floor((e.clientY - rect.top) / cellSize);
      return { x: Math.max(0, Math.min(GRID_SIZE - 1, px)), y: Math.max(0, Math.min(GRID_SIZE - 1, py)) };
    }
    // Modified spamPlace to place elements over a circular or square area based on strokeThickness.
    function spamPlace() { 
      if (hoveredX === null || hoveredY === null) return; 
      let half = Math.floor(strokeThickness / 2);
      
      // Handle special tools
      if (currentTool >= 100 && currentTool <= 107) {
        if (isLeftMouseDown) {
          for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
            for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
              let x = hoveredX + dx, y = hoveredY + dy;
              if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
              
              switch(currentTool) {
                case 100: // TOOL_HEAT
                  if (temp[y][x] !== null) temp[y][x] = Math.min(temp[y][x] + 50, 3000);
                  break;
                case 101: // TOOL_COOL
                  if (temp[y][x] !== null) temp[y][x] = Math.max(temp[y][x] - 50, -271);
                  break;
                case 102: // TOOL_COOK
                  if (grid[y][x] === DOUGH) {
                    grid[y][x] = BREAD;
                    temp[y][x] = 30;
                  }
                  break;
                case 103: // TOOL_MIX
                  if (Math.random() < 0.5) {
                    let dirs = [[1,0], [-1,0], [0,1], [0,-1]];
                    let dir = dirs[Math.floor(Math.random() * dirs.length)];
                    let nx = x + dir[0], ny = y + dir[1];
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                      let tmpElem = grid[y][x];
                      let tmpTemp = temp[y][x];
                      grid[y][x] = grid[ny][nx];
                      temp[y][x] = temp[ny][nx];
                      grid[ny][nx] = tmpElem;
                      temp[ny][nx] = tmpTemp;
                    }
                  }
                  break;
                case 105: // TOOL_SPONGE
                  if ([BURNING_WOOD, BURNING_ORGANIC, BURNING_LEAVES, ASH, FIRE].includes(grid[y][x])) {
                    eraseCell(x, y);
                  }
                  break;
                case 106: // TOOL_EXTINGUISH
                  if (grid[y][x] === FIRE) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_WOOD) {
                    grid[y][x] = WOOD;
                    temp[y][x] = 20;
                  } else if (grid[y][x] === BURNING_ORGANIC) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_LEAVES) {
                    grid[y][x] = OAK_LEAVES;
                    temp[y][x] = 20;
                  }
                  break;
                case 107: // TOOL_GRIND
                  // Grinding different materials
                  if (grid[y][x] === WHEAT) {
                    // Wheat to flour
                    setCellType(x, y, FLOUR, temp[y][x] || 20);
                  } else if (grid[y][x] === GLASS) {
                    // Glass to glass shards
                    setCellType(x, y, GLASS_SHARD, temp[y][x] || 20);
                  } else if (grid[y][x] === STONE || grid[y][x] === BASALT) {
                    // Stone/basalt to cobblestone
                    setCellType(x, y, COBBLESTONE, temp[y][x] || 20);
                  } else if (grid[y][x] === CELL) {
                    // Cell to blood
                    setCellType(x, y, BLOOD, temp[y][x] || 20);
                  } else if (grid[y][x] === WOOD || grid[y][x] === BIRCH_WOOD) {
                    // Wood/birch wood to sawdust
                    setCellType(x, y, SAWDUST, temp[y][x] || 20);
                  }
                  break;
              }
            }
          }
        }
        return;
      }
      
      // Regular element placement
      for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
        for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
          let x = hoveredX + dx, y = hoveredY + dy;
          if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          
          // Check if we should place at this position based on shape
          let shouldPlace = true;
          
          if (!isAltKeyDown) { // Circular placement when ALT is not pressed
            // Ensure odd brush size for circles
            if (strokeThickness % 2 === 0) {
              strokeThickness--;
              if (strokeThickness < 1) strokeThickness = 1;
              half = Math.floor(strokeThickness / 2);
            }
            
            // Calculate distance from center to determine if point is in circle
            const centerX = hoveredX;
            const centerY = hoveredY;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            const radius = strokeThickness / 2;
            
            // Simple distance check for a pixelated circle
            shouldPlace = distance <= radius;
          }
          
          if (shouldPlace) {
            if (isLeftMouseDown) {
              placeElementAt(x, y, currentTool);
            } else if (isRightMouseDown) {
              placeElementAt(x, y, ERASER);
            }
          }
        }
      }
    }
    // Update the hover overlay that shows the stroke area.
    function updateHoverOverlay() {
      if (hoveredX === null || hoveredY === null) {
        hoverOverlay.style.display = "none";
        return;
      }
      
      // Enforce odd brush size for circles when not using ALT
      if (!isAltKeyDown && strokeThickness % 2 === 0) {
        strokeThickness--;
        if (strokeThickness < 1) strokeThickness = 1;
      }
      
      // For pixelated circle, we'll create a grid of cells that match exactly what will be placed
      if (!isAltKeyDown) {
        // Clear any previous content
        hoverOverlay.innerHTML = '';
        hoverOverlay.style.background = 'transparent';
        hoverOverlay.style.border = 'none';
        
        const cellSize = gridContainer.clientWidth / GRID_SIZE;
        const radius = strokeThickness / 2;
        const half = Math.floor(radius);
        
        // Position the overlay
        hoverOverlay.style.display = "block";
        hoverOverlay.style.left = ((hoveredX - half) * cellSize) + "px";
        hoverOverlay.style.top = ((hoveredY - half) * cellSize) + "px";
        hoverOverlay.style.width = (strokeThickness * cellSize) + "px";
        hoverOverlay.style.height = (strokeThickness * cellSize) + "px";
        
        // First pass: Create all cells in the circle
        const cellsInCircle = [];
        for (let dy = -half; dy <= half; dy++) {
          for (let dx = -half; dx <= half; dx++) {
            const distance = Math.sqrt(dx*dx + dy*dy);
            if (distance <= radius) {
              cellsInCircle.push({dx, dy, distance});
            }
          }
        }
        
        // Create a single container for all cells
        const circleContainer = document.createElement('div');
        circleContainer.style.position = 'relative';
        circleContainer.style.width = '100%';
        circleContainer.style.height = '100%';
        hoverOverlay.appendChild(circleContainer);
        
        // Create all cells in the circle with background color
        for (const {dx, dy} of cellsInCircle) {
          const cellDiv = document.createElement('div');
          cellDiv.style.position = 'absolute';
          cellDiv.style.left = ((dx + half) * cellSize) + 'px';
          cellDiv.style.top = ((dy + half) * cellSize) + 'px';
          cellDiv.style.width = cellSize + 'px';
          cellDiv.style.height = cellSize + 'px';
          cellDiv.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
          cellDiv.style.boxSizing = 'border-box';
          circleContainer.appendChild(cellDiv);
        }
        
        // No SVG outline - we'll use only the pixelated outline
        
        // Create a pixelated outline by adding border segments only where needed
        for (const {dx, dy} of cellsInCircle) {
          // Check each side of this cell to see if it's on the border
          const adjacentOffsets = [
            {x: 0, y: -1, side: 'top'},    // top
            {x: 1, y: 0, side: 'right'},  // right
            {x: 0, y: 1, side: 'bottom'}, // bottom
            {x: -1, y: 0, side: 'left'}   // left
          ];
          
          for (const {x: offsetX, y: offsetY, side} of adjacentOffsets) {
            const adjX = dx + offsetX;
            const adjY = dy + offsetY;
            const adjDistance = Math.sqrt(adjX*adjX + adjY*adjY);
            
            // If adjacent cell is outside the circle, add a border on that side
            if (adjDistance > radius) {
              const borderDiv = document.createElement('div');
              borderDiv.style.position = 'absolute';
              borderDiv.style.boxSizing = 'border-box';
              borderDiv.style.pointerEvents = 'none';
              
              // Position and size the border segment based on which side it's on
              switch(side) {
                case 'top':
                  borderDiv.style.left = ((dx + half) * cellSize) + 'px';
                  borderDiv.style.top = ((dy + half) * cellSize) + 'px';
                  borderDiv.style.width = cellSize + 'px';
                  borderDiv.style.height = '1px';
                  borderDiv.style.borderTop = '1px dashed yellow';
                  break;
                case 'right':
                  borderDiv.style.left = ((dx + half) * cellSize + cellSize - 1) + 'px';
                  borderDiv.style.top = ((dy + half) * cellSize) + 'px';
                  borderDiv.style.width = '1px';
                  borderDiv.style.height = cellSize + 'px';
                  borderDiv.style.borderRight = '1px dashed yellow';
                  break;
                case 'bottom':
                  borderDiv.style.left = ((dx + half) * cellSize) + 'px';
                  borderDiv.style.top = ((dy + half) * cellSize + cellSize - 1) + 'px';
                  borderDiv.style.width = cellSize + 'px';
                  borderDiv.style.height = '1px';
                  borderDiv.style.borderBottom = '1px dashed yellow';
                  break;
                case 'left':
                  borderDiv.style.left = ((dx + half) * cellSize) + 'px';
                  borderDiv.style.top = ((dy + half) * cellSize) + 'px';
                  borderDiv.style.width = '1px';
                  borderDiv.style.height = cellSize + 'px';
                  borderDiv.style.borderLeft = '1px dashed yellow';
                  break;
              }
              
              circleContainer.appendChild(borderDiv);
            }
          }
        }
      } else {
        // Square shape when ALT is pressed - use the original method
        const cellSize = gridContainer.clientWidth / GRID_SIZE;
        let half = Math.floor(strokeThickness / 2);
        let startX = (hoveredX - half) * cellSize;
        let startY = (hoveredY - half) * cellSize;
        
        hoverOverlay.innerHTML = ''; // Clear any child elements
        hoverOverlay.style.display = "block";
        hoverOverlay.style.left = startX + "px";
        hoverOverlay.style.top = startY + "px";
        hoverOverlay.style.width = (strokeThickness * cellSize) + "px";
        hoverOverlay.style.height = (strokeThickness * cellSize) + "px";
        hoverOverlay.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
        hoverOverlay.style.border = '2px dashed yellow';
        hoverOverlay.style.borderRadius = '0';
      }
    }
    /***************************************
     * PLACEMENT & ERASURE
     ***************************************/
     function placeElementAt(x, y, tool) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      if (grid[y][x] === tool) return;
      if (tool === ERASER) { eraseCell(x, y); playPlacementSound('eraser'); return; }
      eraseCell(x, y);
      grid[y][x] = tool;
      
      // Mark cell as dirty for rendering
      markDirty(x, y);
      // Mark neighbors as dirty for effects that might affect nearby cells
      markNeighborsDirty(x, y, 1);
      
      // Play placement sound
      playPlacementSound(tool);
      switch (tool) {
        case SAND: temp[y][x] = 20; break;
        case WALL: temp[y][x] = 20; break;
        case WATER: temp[y][x] = 20; break;
        case LAVA: temp[y][x] = 1200; break;
        case STONE: temp[y][x] = 20; break;
        case WATER_VAPOR: temp[y][x] = 100; vaporLife[y][x] = 0; break;
        case COPPER: temp[y][x] = 100; break;
        case STEEL: temp[y][x] = 50; break;
        case ICE: temp[y][x] = -5; break;
        case WOOD: temp[y][x] = 20; burningWoodTime[y][x] = 0; break;
        case FIRE: temp[y][x] = fireTemperature; fireLife[y][x] = 0; break;
        case SMOKE: temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); break;
        case BURNING_WOOD: temp[y][x] = 20; break;
        case BURNING_ORGANIC: temp[y][x] = fireTemperature; break;
        case ASH: temp[y][x] = 20; break;
        case GLASS: temp[y][x] = 300; break;
        case BOMB: temp[y][x] = 20; break;
        case DIRT: temp[y][x] = 20; break;
        case WET_DIRT: temp[y][x] = 20; break;
        case WHEAT_SEEDS: temp[y][x] = 20; seedGrowthTime[y][x] = 0; break;
        case FLOUR: temp[y][x] = 20; break;
        case DOUGH: temp[y][x] = 25; break;
        case BREAD: temp[y][x] = 30; break;
        case ROOT: temp[y][x] = 15; break;
        case BURNING_ORGANIC: temp[y][x] = fireTemperature; break;
        case SPARK: temp[y][x] = 20; sparkLife[y][x] = 0; break;
        case CHARGED_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case OAK_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case BIRCH_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case GRASS: temp[y][x] = 20; grassStage[y][x] = 1; break;
        case GAS: temp[y][x] = 20; break;
        case CHARGED_DOWN_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case COOLER: temp[y][x] = 20; break;
        case HEATER: temp[y][x] = 20; break;
        case HEAT_SEPARATOR: temp[y][x] = 20; break;
        case CHARGED_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CHARGED_DOWN_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case INPUT: temp[y][x] = 20; break;
        case CHARGED_INPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case OUTPUT: temp[y][x] = 20; break;
        case CHARGED_OUTPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case NOT_GATE: temp[y][x] = 20; break;
        case AND_GATE: temp[y][x] = 20; break;
        case BLOCKER: temp[y][x] = 20; break;
        case CHARGED_BLOCKER: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CLONER: temp[y][x] = 20; break;
        case COAL: temp[y][x] = 20; break;
        case COAL_LUMP: temp[y][x] = 20; break;
        case THERMITE: temp[y][x] = 20; break;
        case BURNING_THERMITE: temp[y][x] = 3200; break;
        case ACID: temp[y][x] = 20; break;
        case SLIME: temp[y][x] = 20; break;
        case ACID_STEAM: temp[y][x] = 120; break;
        case ACID_CLOUD: temp[y][x] = 50; break;
        case CARBON_DIOXIDE: temp[y][x] = 20; break;
        case OXYGEN: temp[y][x] = 20; break;
        case BIRD: temp[y][x] = 20; break;
        case MEAT: temp[y][x] = 20; break;
        case COOKED_MEAT: temp[y][x] = 20; break;
        case COBBLESTONE: temp[y][x] = 20; break;
        case OIL: temp[y][x] = 20; break;
        case BIG_BOMB: temp[y][x] = 20; break;
        case WATER_BOMB: temp[y][x] = 20; break;
        case FIRE_BOMB: temp[y][x] = 20; break;
        case CRYO_BOMB: temp[y][x] = 20; break;
        case NUKE_BOMB: temp[y][x] = 20; break;
        case CELL: temp[y][x] = 20; break;
        case DEAD_CELL: temp[y][x] = 20; break;
        case BLOOD: temp[y][x] = 20; break;
        case GLASS_SHARD: temp[y][x] = 20; break;
        case SAWDUST: temp[y][x] = 20; break;
        case BOUNCY_BALL: 
          temp[y][x] = 20; 
          // Initialize with a small random velocity
          ballVelocityX[y][x] = (Math.random() - 0.5) * 2;
          ballVelocityY[y][x] = -2 - Math.random() * 2; // Initial upward velocity
          break;
        case SALT: temp[y][x] = 20; break;
        case SALT_WATER: temp[y][x] = 20; break;
      }
      
      // Initialize color variation for this element
  const variation = 0.03;
  colorVariations[y][x] = {
    r: 1 + (Math.random() * variation * 2 - variation),
    g: 1 + (Math.random() * variation * 2 - variation),
    b: 1 + (Math.random() * variation * 2 - variation)
  };
}

// Function to play placement sounds based on element type
function playPlacementSound(elementType) {
  if (!audioContext) return;
  
  // Create oscillator for sound
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  // Configure sound based on element type
  let frequency = 440; // Default frequency (A4)
  let type = 'sine'; // Default wave type
  let duration = 0.1; // Default duration in seconds
  
  // Customize sound based on element type
  switch(elementType) {
    case WATER:
      frequency = 300 + Math.random() * 50;
      type = 'sine';
      duration = 0.2;
      break;
    case LAVA:
      frequency = 150 + Math.random() * 30;
      type = 'sawtooth';
      duration = 0.3;
      break;
    case SAND:
      frequency = 800 + Math.random() * 200;
      type = 'triangle';
      duration = 0.05 + Math.random() * 0.05;
      break;
    case WALL:
    case STONE:
    case COBBLESTONE:
      frequency = 200 + Math.random() * 100;
      type = 'square';
      duration = 0.1;
      break;
    case FIRE:
      frequency = 500 + Math.random() * 300;
      type = 'sawtooth';
      duration = 0.15;
      break;
    case ICE:
      frequency = 600 + Math.random() * 100;
      type = 'sine';
      duration = 0.2;
      break;
    case WOOD:
      frequency = 350 + Math.random() * 50;
      type = 'triangle';
      duration = 0.15;
      break;
    case BOMB:
    case BIG_BOMB:
    case WATER_BOMB:
    case FIRE_BOMB:
    case CRYO_BOMB:
    case NUKE_BOMB:
      frequency = 200 + Math.random() * 50;
      type = 'square';
      duration = 0.2;
      break;
    case 'eraser':
      frequency = 100 + Math.random() * 50;
      type = 'sine';
      duration = 0.1;
      break;
    default:
      // For other elements, generate a sound based on the element ID
      frequency = 300 + (elementType % 10) * 50 + Math.random() * 30;
      type = ['sine', 'triangle', 'square', 'sawtooth'][elementType % 4];
      duration = 0.1 + Math.random() * 0.1;
  }
  
  // Set oscillator properties
  oscillator.type = type;
  oscillator.frequency.value = frequency;
  
  // Set volume envelope
  gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
  
  // Connect and start
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.start();
  oscillator.stop(audioContext.currentTime + duration);
}

    function eraseCell(x, y){
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      
      // Mark the cell as dirty to ensure it's re-rendered
      markDirty(x, y);
    }

    function eraseCellFull(x, y) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[y][x] = false;
      vaporLife[y][x] = 0;
      cloudLife[y][x] = 0;
      fireLife[y][x] = 0;
      
      // Mark the cell as dirty to ensure it's re-rendered
      markDirty(x, y);
      smokeLife[y][x] = 0;
      burningWoodTime[y][x] = 0;
      wheatHeight[y][x] = 0;
      wheatMaxHeight[y][x] = 0;
      seedGrowthTime[y][x] = 0;
      rootLife[y][x] = 0;
      
      // Mark cell as dirty for rendering
      markDirty(x, y);
      // Mark neighbors as dirty for effects that might affect nearby cells
      markNeighborsDirty(x, y, 1);
      sparkLife[y][x] = 0;
      sparkTimer[y][x] = 0;
      oakTreeGrowthTime[y][x] = 0;
      oakTreeHeight[y][x] = 0;
      oakTreeMaxHeight[y][x] = 0;
      oakTreeRootTimer[y][x] = 0;
      oakTreeRootDepth[y][x] = 0;
      oakTreeRootMax[y][x] = 0;
      branchLevel[y][x] = -1;
      branchLen[y][x] = 0;
      branchMaxArr[y][x] = 0;
      branchSubCount[y][x] = -1;
      branchDirX[y][x] = 0;
      branchDirY[y][x] = 0;
      grassStage[y][x] = 1;
      burningGasTime[y][x] = 0;
      chargedStateTime[y][x] = 0;
      colorVariations[y][x] = null;
    }
    
    // Sound pool to manage multiple sounds playing simultaneously
    const MAX_SOUNDS = 3; // Reduced to prevent audio cutout
    let soundPool = [];
    let lastSoundTime = 0;
    let soundThrottleDelay = 50; // ms between sounds
    let soundPlayProbability = 0.2; // Only play sound for 20% of cells
    
    // Sound volume settings
    let masterVolume = 1.0; // Master volume (0.0 to 1.0)
    
    // Individual element volume settings (default to 1.0)
    const elementVolumes = {};
    
    // Initialize element volumes for all element types
    function initElementVolumes() {
      // Set default volumes for all elements
      for (let i = 0; i <= 100; i++) {
        elementVolumes[i] = 1.0;
      }
      
      // Set specific volumes for elements that need adjustment
      elementVolumes[5] = 2.0;  // Fire at 200% volume
      elementVolumes[1] = 1.0;  // Sand at 100% volume
      elementVolumes[12] = 1.3; // Grass was too quiet
      elementVolumes[7] = 0.5;  // Lava at 50% volume
      elementVolumes[93] = 1.0; // Cell
      elementVolumes[95] = 1.0; // Blood
      elementVolumes[96] = 1.2; // Glass Shard
      elementVolumes[97] = 1.0; // Sawdust
    }
    
    // Initialize element volumes
    initElementVolumes();
    
    // Initialize sound options when document is ready
    document.addEventListener('DOMContentLoaded', function() {
      initSoundOptions();
    });
    
    // Initialize sound options in the options modal
    function initSoundOptions() {
      // Master volume slider
      const masterVolumeSlider = document.getElementById('masterVolumeSlider');
      const masterVolumeValue = document.getElementById('masterVolumeValue');
      
      if (!masterVolumeSlider || !masterVolumeValue) return; // Elements not loaded yet
      
      // Set initial value
      masterVolumeSlider.value = masterVolume * 100;
      masterVolumeValue.textContent = Math.round(masterVolume * 100) + '%';
      
      // Add event listener for master volume change
      masterVolumeSlider.addEventListener('input', function() {
        masterVolume = this.value / 100;
        masterVolumeValue.textContent = this.value + '%';
        // Save to localStorage
        localStorage.setItem('masterVolume', masterVolume);
      });
      
      // Toggle element volume controls
      const toggleButton = document.getElementById('toggleElementVolumes');
      const elementControls = document.getElementById('elementVolumeControls');
      
      if (!toggleButton || !elementControls) return; // Elements not loaded yet
      
      toggleButton.addEventListener('click', function() {
        if (elementControls.style.display === 'none') {
          elementControls.style.display = 'block';
          toggleButton.textContent = 'Hide Element Volume Controls';
          
          // Create element volume sliders if they don't exist
          if (elementControls.querySelector('.element-volume-grid').children.length === 0) {
            createElementVolumeSliders();
          }
        } else {
          elementControls.style.display = 'none';
          toggleButton.textContent = 'Show Element Volume Controls';
        }
      });
      
      // Load saved volume settings
      loadVolumeSettings();
    }
    
    // Create volume sliders for each element type
    function createElementVolumeSliders() {
      const elementVolumeGrid = document.querySelector('.element-volume-grid');
      
      if (!elementVolumeGrid) return; // Element not found
      
      // Clear existing sliders
      elementVolumeGrid.innerHTML = '';
      
      // Get element names and colors from the elementColors object
      const elementTypes = [];
      
      // Add all elements with their IDs
      // These are organized by categories for easier navigation
      const commonElements = [
        // Basic elements
        { id: 1, name: 'Sand', color: '#e6c88a' },
        { id: 2, name: 'Water', color: '#4286f4' },
        { id: 3, name: 'Stone', color: '#808080' },
        { id: 4, name: 'Wood', color: '#8B4513' },
        { id: 5, name: 'Fire', color: '#ff4500' },
        { id: 6, name: 'Oil', color: '#3d3d29' },
        { id: 7, name: 'Lava', color: '#ff6600' },
        { id: 8, name: 'Wall', color: '#444444' },
        { id: 9, name: 'Ice', color: '#add8e6' },
        { id: 10, name: 'Acid', color: '#00ff00' },
        { id: 11, name: 'Dirt', color: '#8B4513' },
        { id: 12, name: 'Grass', color: '#7CFC00' },
        { id: 13, name: 'Smoke', color: '#a9a9a9' },
        { id: 14, name: 'Bomb', color: '#000000' },
        { id: 15, name: 'Gas', color: '#ffff99' },
        
        // Metals and minerals
        { id: 16, name: 'Coal', color: '#0f0f0f' },
        { id: 17, name: 'Iron', color: '#a19d94' },
        { id: 18, name: 'Gold', color: '#FFD700' },
        { id: 19, name: 'Copper', color: '#b87333' },
        { id: 20, name: 'Steel', color: '#71797E' },
        { id: 21, name: 'Diamond', color: '#b9f2ff' },
        
        // Plants and organic
        { id: 22, name: 'Plant', color: '#228B22' },
        { id: 23, name: 'Seeds', color: '#8B4513' },
        { id: 24, name: 'Leaves', color: '#32CD32' },
        
        // Gases and liquids
        { id: 25, name: 'Steam', color: '#ffffff' },
        { id: 26, name: 'Cloud', color: '#f0f0f0' },
        { id: 27, name: 'Oxygen', color: '#87CEEB' },
        { id: 28, name: 'Carbon Dioxide', color: '#708090' },
        
        // Explosives and reactive
        { id: 29, name: 'Thermite', color: '#AA4444' },
        { id: 30, name: 'Gunpowder', color: '#36454F' },
        
        // Construction materials
        { id: 31, name: 'Glass', color: '#add8e6' },
        { id: 32, name: 'Cobblestone', color: '#696969' },
        
        // Special elements
        { id: 33, name: 'Eraser', color: '#FF69B4' },
        { id: 34, name: 'Slime', color: '#00FF00' },
        { id: 35, name: 'Electricity', color: '#FFFF00' }
      ];
      
      // Add the common elements to our list
      elementTypes.push(...commonElements);
      
      // Add our new elements
      elementTypes.push({ id: 93, name: 'Cell', color: '#66cc99' });
      elementTypes.push({ id: 95, name: 'Blood', color: '#cc0000' });
      elementTypes.push({ id: 96, name: 'Glass Shard', color: '#e0f0ff' });
      
      // Add a category for other elements
      elementTypes.push({ id: 0, name: 'Other Elements', color: '#cccccc' });
      
      
      // Create a slider for each element type
      elementTypes.forEach(element => {
        const volumeItem = document.createElement('div');
        volumeItem.className = 'element-volume-item';
        
        // Color box to identify the element
        const colorBox = document.createElement('div');
        colorBox.className = 'element-color-box';
        colorBox.style.backgroundColor = element.color;
        
        // Element name
        const nameSpan = document.createElement('span');
        nameSpan.textContent = element.name + ': ';
        
        // Volume slider
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '200';
        slider.value = elementVolumes[element.id] * 100;
        slider.className = 'volume-slider';
        slider.style.width = '100px';
        slider.dataset.elementId = element.id;
        
        // Volume value display
        const valueSpan = document.createElement('span');
        valueSpan.textContent = Math.round(elementVolumes[element.id] * 100) + '%';
        valueSpan.style.minWidth = '40px';
        valueSpan.style.display = 'inline-block';
        
        // Add event listener
        slider.addEventListener('input', function() {
          const elementId = parseInt(this.dataset.elementId);
          elementVolumes[elementId] = this.value / 100;
          valueSpan.textContent = this.value + '%';
          
          // Save to localStorage
          saveElementVolumes();
        });
        
        // Assemble the volume item
        volumeItem.appendChild(colorBox);
        volumeItem.appendChild(nameSpan);
        volumeItem.appendChild(slider);
        volumeItem.appendChild(valueSpan);
        
        // Add to the grid
        elementVolumeGrid.appendChild(volumeItem);
      });
    }
    
    // Save element volumes to localStorage
    function saveElementVolumes() {
      localStorage.setItem('elementVolumes', JSON.stringify(elementVolumes));
    }
    
    // Load volume settings from localStorage
    function loadVolumeSettings() {
      // Load master volume
      const savedMasterVolume = localStorage.getItem('masterVolume');
      if (savedMasterVolume !== null) {
        masterVolume = parseFloat(savedMasterVolume);
        const masterVolumeSlider = document.getElementById('masterVolumeSlider');
        const masterVolumeValue = document.getElementById('masterVolumeValue');
        
        if (masterVolumeSlider && masterVolumeValue) {
          masterVolumeSlider.value = masterVolume * 100;
          masterVolumeValue.textContent = Math.round(masterVolume * 100) + '%';
        }
      }
      
      // Load element volumes
      const savedElementVolumes = localStorage.getItem('elementVolumes');
      if (savedElementVolumes !== null) {
        const parsedVolumes = JSON.parse(savedElementVolumes);
        
        // Update our elementVolumes object
        for (const elementId in parsedVolumes) {
          if (parsedVolumes.hasOwnProperty(elementId)) {
            elementVolumes[elementId] = parsedVolumes[elementId];
          }
        }
      }
    }
    
    // Function to create more realistic sounds using multiple oscillators and filters
    function playPlacementSound(elementType) {
      if (!audioContext) return;
      
      // Throttle sounds by time and probability
      const now = Date.now();
      if (now - lastSoundTime < soundThrottleDelay || Math.random() > soundPlayProbability) {
        return; // Skip this sound
      }
      lastSoundTime = now;
      
      // Limit the number of simultaneous sounds to prevent audio cutoff
      while (soundPool.length >= MAX_SOUNDS) {
        // Remove the oldest sound to make room for the new one
        const oldestSound = soundPool.shift();
        if (oldestSound.gainNode) {
          // Stop it completely to free up audio resources
          oldestSound.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
          oldestSound.gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          if (oldestSound.oscillators) {
            oldestSound.oscillators.forEach(osc => {
              try { osc.stop(audioContext.currentTime); } catch (e) {}
            });
          }
        }
      }
      
      // Create master gain node
      const masterGain = audioContext.createGain();
      
      // Apply both master volume and element-specific volume
      const elementVolumeMultiplier = elementVolumes[elementType] || 1.0;
      const volumeScale = Math.max(0.05, 0.3 - (soundPool.length * 0.02)) * masterVolume * elementVolumeMultiplier;
      masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
      
      // Create a BiquadFilter for sound shaping
      const filter = audioContext.createBiquadFilter();
      filter.connect(masterGain);
      masterGain.connect(audioContext.destination);
      
      // Create noise generator for certain sounds
      const createNoise = (duration) => {
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        return noise;
      };
      
      // Track all oscillators for cleanup
      const oscillators = [];
      let duration = 0.2; // Default duration
      
      // Create different sound profiles based on element type
      switch(elementType) {
        case WATER: {
          // Water splash sound
          duration = 0.4;
          filter.type = 'lowpass';
          filter.frequency.value = 800;
          filter.Q.value = 1;
          
          // White noise for splash
          const noise = createNoise(duration);
          noise.connect(filter);
          oscillators.push(noise);
          
          // Bubbling effect
          for (let i = 0; i < 3; i++) {
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 300 + Math.random() * 400;
            osc.frequency.exponentialRampToValueAtTime(100 + Math.random() * 200, audioContext.currentTime + duration);
            
            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(0, audioContext.currentTime);
            oscGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.05 + (i * 0.05));
            oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration - 0.05);
            
            osc.connect(oscGain);
            oscGain.connect(filter);
            oscillators.push(osc);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
          }
          
          masterGain.gain.setValueAtTime(volumeScale * 0.8, audioContext.currentTime);
          masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          noise.start();
          noise.stop(audioContext.currentTime + duration);
          break;
        }
        
        case SAND: {
          // Sand pouring/falling sound
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 2000;
          filter.Q.value = 1;
          
          // Filtered noise for sand particles
          const noise = createNoise(duration);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.5, audioContext.currentTime);
          noiseGain.gain.linearRampToValueAtTime(volumeScale * 0.2, audioContext.currentTime + duration);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          // Short impact sound
          const osc = audioContext.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = 600;
          osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
          
          const oscGain = audioContext.createGain();
          oscGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          osc.connect(oscGain);
          oscGain.connect(filter);
          oscillators.push(osc);
          
          masterGain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
          masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          noise.start();
          noise.stop(audioContext.currentTime + duration);
          osc.start();
          osc.stop(audioContext.currentTime + 0.1);
          break;
        }
        
        case FIRE: {
          // Improved fire crackling sound
          duration = 0.6;
          
          // Create a bandpass filter for the main fire sound
          const fireFilter = audioContext.createBiquadFilter();
          fireFilter.type = 'bandpass';
          fireFilter.frequency.value = 400;
          fireFilter.Q.value = 0.5;
          fireFilter.connect(masterGain);
          
          // Create a highpass filter for the crackles
          const crackleFilter = audioContext.createBiquadFilter();
          crackleFilter.type = 'highpass';
          crackleFilter.frequency.value = 2000;
          crackleFilter.connect(masterGain);
          
          // Base fire sound (filtered noise with lower frequency content)
          const baseNoise = createNoise(duration);
          const baseNoiseGain = audioContext.createGain();
          baseNoiseGain.gain.setValueAtTime(volumeScale * 0.15, audioContext.currentTime);
          baseNoiseGain.gain.exponentialRampToValueAtTime(volumeScale * 0.05, audioContext.currentTime + duration);
          
          baseNoise.connect(baseNoiseGain);
          baseNoiseGain.connect(fireFilter);
          oscillators.push(baseNoise);
          
          // Mid-range fire sound
          const midNoise = createNoise(duration);
          const midNoiseGain = audioContext.createGain();
          midNoiseGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          midNoiseGain.gain.exponentialRampToValueAtTime(volumeScale * 0.03, audioContext.currentTime + duration);
          
          // Create a bandpass filter for mid-range
          const midFilter = audioContext.createBiquadFilter();
          midFilter.type = 'bandpass';
          midFilter.frequency.value = 800;
          midFilter.Q.value = 1;
          
          midNoise.connect(midNoiseGain);
          midNoiseGain.connect(midFilter);
          midFilter.connect(masterGain);
          oscillators.push(midNoise);
          
          // Realistic crackling effect with multiple layers
          for (let i = 0; i < 8; i++) {
            const delay = Math.random() * 0.4;
            
            // Create a short noise burst for each crackle
            const crackleLength = 0.02 + Math.random() * 0.03;
            const crackle = createNoise(crackleLength);
            
            const crackleGain = audioContext.createGain();
            crackleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            crackleGain.gain.linearRampToValueAtTime(volumeScale * (0.05 + Math.random() * 0.15), 
                                                   audioContext.currentTime + delay + 0.005);
            crackleGain.gain.exponentialRampToValueAtTime(0.001, 
                                                        audioContext.currentTime + delay + crackleLength);
            
            // Individual filter for each crackle to vary the sound
            const individualFilter = audioContext.createBiquadFilter();
            individualFilter.type = 'bandpass';
            individualFilter.frequency.value = 2000 + Math.random() * 6000;
            individualFilter.Q.value = 1 + Math.random() * 5;
            
            crackle.connect(crackleGain);
            crackleGain.connect(individualFilter);
            individualFilter.connect(crackleFilter);
            oscillators.push(crackle);
            
            crackle.start(audioContext.currentTime + delay);
            crackle.stop(audioContext.currentTime + delay + crackleLength);
          }
          
          // Add a subtle low-frequency rumble
          const rumble = audioContext.createOscillator();
          rumble.type = 'sine';
          rumble.frequency.value = 40 + Math.random() * 30;
          
          const rumbleGain = audioContext.createGain();
          rumbleGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          rumble.connect(rumbleGain);
          rumbleGain.connect(masterGain);
          oscillators.push(rumble);
          
          masterGain.gain.setValueAtTime(volumeScale * 0.8, audioContext.currentTime);
          masterGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          baseNoise.start();
          baseNoise.stop(audioContext.currentTime + duration);
          midNoise.start();
          midNoise.stop(audioContext.currentTime + duration);
          rumble.start();
          rumble.stop(audioContext.currentTime + duration);
          break;
        }
        
        case STONE:
        case WALL:
        case COBBLESTONE: {
          // Stone placement sound (solid thud)
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 500;
          
          // Impact sound
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sine';
          osc1.frequency.value = 120;
          osc1.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + duration);
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Short noise burst for impact
          const noise = createNoise(0.1);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.5, audioContext.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          noise.start();
          noise.stop(audioContext.currentTime + 0.1);
          break;
        }
        
        case WOOD: {
          // Wood placement sound (wooden knock)
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 1000;
          filter.Q.value = 2;
          
          // Wooden impact
          const osc1 = audioContext.createOscillator();
          osc1.type = 'triangle';
          osc1.frequency.value = 300;
          osc1.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.2);
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Secondary resonance
          const osc2 = audioContext.createOscillator();
          osc2.type = 'sine';
          osc2.frequency.value = 180;
          
          const osc2Gain = audioContext.createGain();
          osc2Gain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime + 0.01);
          osc2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc2.connect(osc2Gain);
          osc2Gain.connect(filter);
          oscillators.push(osc2);
          
          osc1.start();
          osc1.stop(audioContext.currentTime + 0.2);
          osc2.start();
          osc2.stop(audioContext.currentTime + duration);
          break;
        }
        
        case LAVA: {
          // Lava bubbling sound
          duration = 0.5;
          filter.type = 'lowpass';
          filter.frequency.value = 600;
          
          // Base rumble
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sawtooth';
          osc1.frequency.value = 80;
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale * 0.4, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Bubbling sounds
          for (let i = 0; i < 3; i++) {
            const delay = i * 0.1;
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 150 + Math.random() * 100;
            bubble.frequency.exponentialRampToValueAtTime(50 + Math.random() * 50, audioContext.currentTime + delay + 0.2);
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.3, audioContext.currentTime + delay + 0.05);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.2);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          break;
        }
        
        case ICE: {
          // Ice crystal sound (high pitched, glassy)
          duration = 0.4;
          filter.type = 'highpass';
          filter.frequency.value = 2000;
          
          // High pitched crystal sound
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sine';
          osc1.frequency.value = 1200 + Math.random() * 400;
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          osc1Gain.gain.linearRampToValueAtTime(volumeScale * 0.4, audioContext.currentTime + 0.05);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Secondary crystal tones
          for (let i = 0; i < 2; i++) {
            const osc2 = audioContext.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 800 + (i * 400) + Math.random() * 200;
            
            const osc2Gain = audioContext.createGain();
            osc2Gain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime + 0.05 * i);
            osc2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2 + (0.1 * i));
            
            osc2.connect(osc2Gain);
            osc2Gain.connect(filter);
            oscillators.push(osc2);
            osc2.start();
            osc2.stop(audioContext.currentTime + duration);
          }
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          break;
        }
        
        case 'eraser': {
          // Eraser/vacuum sound
          duration = 0.2;
          filter.type = 'highpass';
          filter.frequency.value = 2000;
          
          // Whoosh sound
          const noise = createNoise(duration);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          // Quick sweep
          const osc = audioContext.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = 2000;
          osc.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + duration);
          
          const oscGain = audioContext.createGain();
          oscGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc.connect(oscGain);
          oscGain.connect(filter);
          oscillators.push(osc);
          
          noise.start();
          noise.stop(audioContext.currentTime + duration);
          osc.start();
          osc.stop(audioContext.currentTime + duration);
          break;
        }
        
        case BOMB:
        case BIG_BOMB:
        case WATER_BOMB:
        case FIRE_BOMB:
        case CRYO_BOMB:
        case NUKE_BOMB: {
          // Heavy object placement sound
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 400;
          
          // Deep thud
          const osc1 = audioContext.createOscillator();
          osc1.type = 'sine';
          osc1.frequency.value = 80;
          osc1.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + duration);
          
          const osc1Gain = audioContext.createGain();
          osc1Gain.gain.setValueAtTime(volumeScale * 1.2, audioContext.currentTime);
          osc1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          osc1.connect(osc1Gain);
          osc1Gain.connect(filter);
          oscillators.push(osc1);
          
          // Impact noise
          const noise = createNoise(0.1);
          const noiseGain = audioContext.createGain();
          noiseGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          noise.connect(noiseGain);
          noiseGain.connect(filter);
          oscillators.push(noise);
          
          osc1.start();
          osc1.stop(audioContext.currentTime + duration);
          noise.start();
          noise.stop(audioContext.currentTime + 0.1);
          break;
        }
        
        case DIRT: {
          // Dirt placement sound (soft thud with some texture)
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 800;
          
          // Soft impact sound
          const impact = createNoise(0.15);
          const impactFilter = audioContext.createBiquadFilter();
          impactFilter.type = 'bandpass';
          impactFilter.frequency.value = 200;
          impactFilter.Q.value = 0.7;
          
          const impactGain = audioContext.createGain();
          impactGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
          
          impact.connect(impactGain);
          impactGain.connect(impactFilter);
          impactFilter.connect(filter);
          oscillators.push(impact);
          
          // Dirt particles settling
          const particles = createNoise(duration);
          const particlesFilter = audioContext.createBiquadFilter();
          particlesFilter.type = 'bandpass';
          particlesFilter.frequency.value = 500;
          particlesFilter.Q.value = 0.5;
          
          const particlesGain = audioContext.createGain();
          particlesGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime + 0.05);
          particlesGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          particles.connect(particlesGain);
          particlesGain.connect(particlesFilter);
          particlesFilter.connect(filter);
          oscillators.push(particles);
          
          // Add a bit of low end for the impact
          const thud = audioContext.createOscillator();
          thud.type = 'sine';
          thud.frequency.value = 80;
          thud.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
          
          const thudGain = audioContext.createGain();
          thudGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
          
          thud.connect(thudGain);
          thudGain.connect(filter);
          oscillators.push(thud);
          
          impact.start();
          impact.stop(audioContext.currentTime + 0.15);
          particles.start();
          particles.stop(audioContext.currentTime + duration);
          thud.start();
          thud.stop(audioContext.currentTime + 0.2);
          break;
        }
        
        case FLOUR:
        case SAWDUST: {
          // Flour/Sawdust placement sound (soft puff with some particles)
          duration = 0.3;
          filter.type = 'lowpass';
          filter.frequency.value = 1000;
          
          // Soft puff sound
          const puff = createNoise(0.2);
          const puffFilter = audioContext.createBiquadFilter();
          puffFilter.type = 'bandpass';
          puffFilter.frequency.value = 800;
          puffFilter.Q.value = 0.5;
          
          const puffGain = audioContext.createGain();
          puffGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          puffGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
          
          puff.connect(puffGain);
          puffGain.connect(puffFilter);
          puffFilter.connect(filter);
          oscillators.push(puff);
          
          // Particles settling
          const particles = createNoise(duration);
          const particlesFilter = audioContext.createBiquadFilter();
          particlesFilter.type = 'bandpass';
          particlesFilter.frequency.value = 1200;
          particlesFilter.Q.value = 0.8;
          
          const particlesGain = audioContext.createGain();
          particlesGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime + 0.05);
          particlesGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          particles.connect(particlesGain);
          particlesGain.connect(particlesFilter);
          particlesFilter.connect(filter);
          oscillators.push(particles);
          
          puff.start();
          puff.stop(audioContext.currentTime + 0.2);
          particles.start();
          particles.stop(audioContext.currentTime + duration);
          break;
        }
        
        case WHEAT_SEEDS:
        case OAK_SEEDS:
        case BIRCH_SEEDS: {
          // Seeds dropping sound (light, rattling)
          duration = 0.25;
          filter.type = 'bandpass';
          filter.frequency.value = 3000;
          filter.Q.value = 1;
          
          // Seed impact sounds - multiple small impacts
          for (let i = 0; i < 5; i++) {
            const delay = i * 0.03;
            const seedNoise = createNoise(0.05);
            
            const seedFilter = audioContext.createBiquadFilter();
            seedFilter.type = 'bandpass';
            seedFilter.frequency.value = 2000 + Math.random() * 2000;
            seedFilter.Q.value = 2;
            
            const seedGain = audioContext.createGain();
            seedGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            seedGain.gain.linearRampToValueAtTime(volumeScale * 0.05, audioContext.currentTime + delay + 0.01);
            seedGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.05);
            
            seedNoise.connect(seedGain);
            seedGain.connect(seedFilter);
            seedFilter.connect(filter);
            oscillators.push(seedNoise);
            
            seedNoise.start(audioContext.currentTime + delay);
            seedNoise.stop(audioContext.currentTime + delay + 0.05);
          }
          break;
        }
        
        case GRASS: {
          // Grass placement sound (light rustling)
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 2000;
          filter.Q.value = 1;
          
          // Rustling sound
          const rustle = createNoise(duration);
          
          // Shape the noise to sound like rustling leaves
          const rustleFilter = audioContext.createBiquadFilter();
          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 3000;
          rustleFilter.Q.value = 1;
          
          const rustleGain = audioContext.createGain();
          rustleGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime);
          
          // Create some movement in the sound
          for (let i = 0; i < 5; i++) {
            const time = audioContext.currentTime + (i * duration / 5);
            rustleGain.gain.setValueAtTime(volumeScale * (0.02 + Math.random() * 0.08), time);
          }
          
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          rustle.connect(rustleGain);
          rustleGain.connect(rustleFilter);
          rustleFilter.connect(filter);
          oscillators.push(rustle);
          
          rustle.start();
          rustle.stop(audioContext.currentTime + duration);
          break;
        }
        
        case OIL: {
          // Oil pouring sound (viscous liquid)
          duration = 0.4;
          filter.type = 'lowpass';
          filter.frequency.value = 600;
          
          // Base liquid sound
          const liquid = createNoise(duration);
          const liquidFilter = audioContext.createBiquadFilter();
          liquidFilter.type = 'lowpass';
          liquidFilter.frequency.value = 400;
          
          const liquidGain = audioContext.createGain();
          liquidGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          liquidGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          liquid.connect(liquidGain);
          liquidGain.connect(liquidFilter);
          liquidFilter.connect(filter);
          oscillators.push(liquid);
          
          // Viscous bubbling
          for (let i = 0; i < 2; i++) {
            const delay = 0.1 + (i * 0.15);
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 100 + Math.random() * 50;
            bubble.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + delay + 0.2);
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.1, audioContext.currentTime + delay + 0.05);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.2);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          liquid.start();
          liquid.stop(audioContext.currentTime + duration);
          break;
        }
        
        case GAS:
        case CARBON_DIOXIDE:
        case OXYGEN: {
          // Gas release sound (hissing)
          duration = 0.3;
          filter.type = 'bandpass';
          filter.frequency.value = 5000;
          filter.Q.value = 2;
          
          // Hissing noise
          const hiss = createNoise(duration);
          
          const hissGain = audioContext.createGain();
          hissGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          hissGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          hiss.connect(hissGain);
          hissGain.connect(filter);
          oscillators.push(hiss);
          
          // Add some movement to the hiss
          const hissFilter = audioContext.createBiquadFilter();
          hissFilter.type = 'bandpass';
          hissFilter.Q.value = 5;
          hissFilter.frequency.value = 4000;
          hissFilter.frequency.exponentialRampToValueAtTime(6000, audioContext.currentTime + 0.1);
          hissFilter.frequency.exponentialRampToValueAtTime(3000, audioContext.currentTime + duration);
          
          hissGain.connect(hissFilter);
          hissFilter.connect(masterGain);
          
          hiss.start();
          hiss.stop(audioContext.currentTime + duration);
          break;
        }
        
        case ACID: {
          // Acid sound (sizzling)
          duration = 0.4;
          filter.type = 'bandpass';
          filter.frequency.value = 3000;
          filter.Q.value = 1;
          
          // Base sizzle
          const sizzle = createNoise(duration);
          
          const sizzleGain = audioContext.createGain();
          sizzleGain.gain.setValueAtTime(volumeScale * 0.1, audioContext.currentTime);
          sizzleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          sizzle.connect(sizzleGain);
          sizzleGain.connect(filter);
          oscillators.push(sizzle);
          
          // Add bubbling/reactive sounds
          for (let i = 0; i < 6; i++) {
            const delay = Math.random() * 0.3;
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 2000 + Math.random() * 2000;
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.05, audioContext.currentTime + delay + 0.01);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.05);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          sizzle.start();
          sizzle.stop(audioContext.currentTime + duration);
          break;
        }
        
        case LAVA: {
          // Lava sound (deep bubbling) - made a bit quieter by default
          duration = 0.5;
          filter.type = 'lowpass';
          filter.frequency.value = 300;
          
          // Base rumble
          const rumble = audioContext.createOscillator();
          rumble.type = 'sine';
          rumble.frequency.value = 60;
          
          const rumbleGain = audioContext.createGain();
          rumbleGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          rumble.connect(rumbleGain);
          rumbleGain.connect(filter);
          oscillators.push(rumble);
          
          // Bubbling effect
          for (let i = 0; i < 3; i++) {
            const delay = Math.random() * 0.3;
            const bubble = audioContext.createOscillator();
            bubble.type = 'sine';
            bubble.frequency.value = 100 + Math.random() * 50;
            
            const bubbleGain = audioContext.createGain();
            bubbleGain.gain.setValueAtTime(0, audioContext.currentTime + delay);
            bubbleGain.gain.linearRampToValueAtTime(volumeScale * 0.15, audioContext.currentTime + delay + 0.05);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 0.2);
            
            bubble.connect(bubbleGain);
            bubbleGain.connect(filter);
            oscillators.push(bubble);
            
            bubble.start();
            bubble.stop(audioContext.currentTime + duration);
          }
          
          rumble.start();
          rumble.stop(audioContext.currentTime + duration);
          break;
        }
        
        case 19: // Copper
        case 17: // Iron
        case 20: // Steel
        {
          // Metallic sound for metals (copper, iron, steel)
          duration = 0.4;
          
          // Create a metallic impact sound
          const impact = createNoise(0.05);
          const impactFilter = audioContext.createBiquadFilter();
          impactFilter.type = 'bandpass';
          impactFilter.frequency.value = 2000;
          impactFilter.Q.value = 5; // Higher Q for more resonance
          
          const impactGain = audioContext.createGain();
          impactGain.gain.setValueAtTime(volumeScale * 0.3, audioContext.currentTime);
          impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
          
          impact.connect(impactGain);
          impactGain.connect(impactFilter);
          impactFilter.connect(masterGain);
          oscillators.push(impact);
          
          // Metallic resonance
          const resonance1 = audioContext.createOscillator();
          resonance1.type = 'sine';
          resonance1.frequency.value = 1200 + (elementType === 19 ? 400 : 0); // Copper higher pitch
          
          const resonance2 = audioContext.createOscillator();
          resonance2.type = 'sine';
          resonance2.frequency.value = 1800 + (elementType === 20 ? 600 : 0); // Steel higher pitch
          
          // Frequency modulation for more metallic sound
          resonance1.frequency.setValueAtTime(resonance1.frequency.value * 1.2, audioContext.currentTime + 0.01);
          resonance1.frequency.exponentialRampToValueAtTime(resonance1.frequency.value * 0.5, audioContext.currentTime + duration);
          
          resonance2.frequency.setValueAtTime(resonance2.frequency.value * 1.1, audioContext.currentTime + 0.01);
          resonance2.frequency.exponentialRampToValueAtTime(resonance2.frequency.value * 0.6, audioContext.currentTime + duration);
          
          // Create gain nodes with quick decay for metallic sound
          const resonanceGain1 = audioContext.createGain();
          resonanceGain1.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          resonanceGain1.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          const resonanceGain2 = audioContext.createGain();
          resonanceGain2.gain.setValueAtTime(volumeScale * 0.15, audioContext.currentTime);
          resonanceGain2.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration * 0.8);
          
          // Connect everything
          resonance1.connect(resonanceGain1);
          resonanceGain1.connect(masterGain);
          resonance2.connect(resonanceGain2);
          resonanceGain2.connect(masterGain);
          
          oscillators.push(resonance1);
          oscillators.push(resonance2);
          
          // Start and stop
          impact.start();
          impact.stop(audioContext.currentTime + 0.05);
          resonance1.start();
          resonance1.stop(audioContext.currentTime + duration);
          resonance2.start();
          resonance2.stop(audioContext.currentTime + duration * 0.8);
          break;
        }
        
        default: {
          // More natural generic placement sound based on element ID
          duration = 0.25;
          
          // Create a more natural impact sound using noise + tone
          const impactNoise = createNoise(0.1);
          const impactFilter = audioContext.createBiquadFilter();
          impactFilter.type = 'bandpass';
          impactFilter.frequency.value = 500 + (elementType % 10) * 300;
          impactFilter.Q.value = 1;
          
          const impactGain = audioContext.createGain();
          impactGain.gain.setValueAtTime(volumeScale * 0.2, audioContext.currentTime);
          impactGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
          
          impactNoise.connect(impactGain);
          impactGain.connect(impactFilter);
          impactFilter.connect(masterGain);
          oscillators.push(impactNoise);
          
          // Resonance tone
          const tone = audioContext.createOscillator();
          tone.type = ['sine', 'triangle'][elementType % 2]; // Avoid harsh square/sawtooth waves
          tone.frequency.value = 200 + (elementType % 15) * 40;
          tone.frequency.exponentialRampToValueAtTime(tone.frequency.value * 0.7, audioContext.currentTime + duration);
          
          const toneGain = audioContext.createGain();
          toneGain.gain.setValueAtTime(volumeScale * 0.15, audioContext.currentTime + 0.01);
          toneGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          tone.connect(toneGain);
          toneGain.connect(masterGain);
          oscillators.push(tone);
          
          // Add some texture
          const texture = createNoise(duration - 0.05);
          const textureFilter = audioContext.createBiquadFilter();
          textureFilter.type = 'bandpass';
          textureFilter.frequency.value = 1000 + (elementType % 8) * 200;
          textureFilter.Q.value = 2;
          
          const textureGain = audioContext.createGain();
          textureGain.gain.setValueAtTime(volumeScale * 0.05, audioContext.currentTime + 0.05);
          textureGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
          
          texture.connect(textureGain);
          textureGain.connect(textureFilter);
          textureFilter.connect(masterGain);
          oscillators.push(texture);
          
          impactNoise.start();
          impactNoise.stop(audioContext.currentTime + 0.1);
          tone.start();
          tone.stop(audioContext.currentTime + duration);
          texture.start(audioContext.currentTime + 0.05);
          texture.stop(audioContext.currentTime + duration);
          break;
        }
      }
      
      // Track this sound in our pool
      const soundObj = { oscillators, gainNode: masterGain, startTime: audioContext.currentTime };
      soundPool.push(soundObj);
      
      // Remove from pool after it's done
      setTimeout(() => {
        const index = soundPool.indexOf(soundObj);
        if (index !== -1) {
          soundPool.splice(index, 1);
        }
      }, duration * 1000 + 100); // Add a small buffer to ensure it's fully played
    }
    /***************************************
     * RENDER & HUD
     ***************************************/
     // Cache for element class names to avoid repeated lookups
     const elementClassCache = {};
     
     // Cache for transparent elements
     const transparentElements = new Set([GAS, WATER_VAPOR, BURNING_GAS, CARBON_DIOXIDE, OXYGEN, HELIUM]);
     
     function renderCell(x, y) {
      const cell = cells[y][x];
      const e = grid[y][x];
      
      // Always completely reset the cell's appearance first
      // This ensures that when elements transform (like water to stone),
      // all visual properties from the previous element are cleared
      cell.className = 'cell';
      cell.style.backgroundColor = '';
      cell.style.opacity = '';
      
      if (e === EMPTY) {
        return;
      }
      
      // Get base color
      let baseColor = elementBaseColors[e];
      
      if (baseColor) {
        // Cell class is already reset to 'cell' above
        
        // Get temperature
        const temperature = temp[y][x] !== null ? temp[y][x] : 20;
        
        // Apply temperature and random variations
        const adjustedColor = getTemperatureAdjustedColor(baseColor, temperature, e, x, y);
        
        // Only update if color changed
        if (cell.style.backgroundColor !== adjustedColor) {
          cell.style.backgroundColor = adjustedColor;
        }
        
        // Special case for smoke opacity
        if (e === SMOKE) {
          const max = smokeMaxLife[y][x];
          const life = smokeLife[y][x];
          const ratio = Math.max(0, 1 - (life / max));
          cell.style.opacity = ratio.toString();
        }
        // Special case for other transparent elements
        else if (transparentElements.has(e)) {
          if (cell.style.opacity !== '0.7') {
            cell.style.opacity = '0.7';
          }
        }
        // Reset opacity for non-transparent elements
        else if (cell.style.opacity) {
          cell.style.opacity = '';
        }
      } else {
        // Fallback to class-based styling if no base color is defined
        // Since we already reset the className to 'cell' above, we just need to add the element-specific class
        let elementClass = '';
        
        switch (e) {
          case SAND: elementClass = 'sand'; break;
          case WALL: elementClass = 'wall'; break;
          case WATER: elementClass = 'water'; break;
          case LAVA: elementClass = 'lava'; break;
          case STONE: elementClass = 'stone'; break;
          case WATER_VAPOR: elementClass = 'water-vapor'; break;
          case CLOUD: elementClass = 'cloud'; break;
          case BASALT: elementClass = 'stone'; break;
          case OBSIDIAN: elementClass = 'stone'; break;
          case MOLTEN_SLAG: elementClass = 'lava'; break;
          case COPPER: elementClass = 'copper'; break;
          case STEEL: elementClass = 'steel'; break;
          case ICE: elementClass = 'ice'; break;
          case WOOD: elementClass = 'wood'; break;
          case FIRE: elementClass = 'fire'; break;
          case SMOKE: elementClass = 'smoke'; break;
          case BURNING_WOOD: elementClass = 'burning-wood'; break;
          case BURNING_ORGANIC: elementClass = 'burning-organic'; break;
          case ASH: elementClass = 'ash'; break;
          case GLASS: elementClass = 'glass'; break;
          case BOMB: elementClass = 'bomb'; break;
          case DIRT: elementClass = 'dirt'; break;
          case WET_DIRT: elementClass = 'wet-dirt'; break;
          case WHEAT_SEEDS: elementClass = 'wheat-seeds'; break;
          case WHEAT: elementClass = 'wheat'; break;
          case FLOUR: elementClass = 'flour'; break;
          case DOUGH: elementClass = 'dough'; break;
          case BREAD: elementClass = 'bread'; break;
          case ROOT: elementClass = 'root'; break;
          case BURNING_ROOT: elementClass = 'burning-root'; break;
          case DEAD_ROOT: elementClass = 'dead-root'; break;
          case SPARK: elementClass = 'spark'; break;
          case CHARGED_COPPER: elementClass = 'charged-copper'; break;
          case CHARGED_DOWN_COPPER: elementClass = 'charged-down-copper'; break;
          case OAK_SEEDS: elementClass = 'oak-seeds'; break;
          case OAK_LEAVES: elementClass = 'oak-leaves'; break;
          case OAK_BABY_LEAVES: elementClass = 'oak-baby-leaves'; break;
          case DEAD_OAK: elementClass = 'dead-oak'; break;
          case BIRCH_SEEDS: elementClass = 'birch-seeds'; break;
          case BIRCH_LEAVES: elementClass = 'birch-leaves'; break;
          case BIRCH_BABY_LEAVES: elementClass = 'birch-baby-leaves'; break;
          case BIRCH_WOOD: elementClass = 'birch-wood'; break;
          case DEAD_BIRCH: elementClass = 'dead-birch'; break;
          case WET_SAND: elementClass = 'wet-sand'; break;
          case GRASS: elementClass = 'grass'; break;
          case DEAD_PLANT: elementClass = 'dead-plant'; break;
          case BURNING_LEAVES: elementClass = 'burning-leaves'; break;
          case GAS: elementClass = 'gas'; break;
          case BURNING_GAS: elementClass = 'burning-gas'; break;
          case COOLER: elementClass = 'cooler'; break;
          case HEATER: elementClass = 'heater'; break;
          case HEAT_SEPARATOR: elementClass = 'heat-separator'; break;
          case CHARGED_HEAT_SEPARATOR: elementClass = 'charged-heat-separator'; break;
          case CHARGED_DOWN_HEAT_SEPARATOR: elementClass = 'charged-down-heat-separator'; break;
          case INPUT: elementClass = 'input'; break;
          case CHARGED_INPUT: elementClass = 'charged-input'; break;
          case OUTPUT: elementClass = 'output'; break;
          case CHARGED_OUTPUT: elementClass = 'charged-output'; break;
          case NOT_GATE: elementClass = 'not-gate'; break;
          case AND_GATE: elementClass = 'and-gate'; break;
          case BLOCKER: elementClass = 'blocker'; break;
          case CHARGED_BLOCKER: elementClass = 'charged-blocker'; break;
          case CLONER: elementClass = 'cloner'; break;
          case COAL: elementClass = 'coal'; break;
          case COAL_LUMP: elementClass = 'coal-lump'; break;
          case BURNING_COAL: elementClass = 'burning-coal'; break;
          case BURNING_COAL_LUMP: elementClass = 'burning-coal-lump'; break;
          case THERMITE: elementClass = 'thermite'; break;
          case BURNING_THERMITE: elementClass = 'burning-thermite'; break;
          case ACID: elementClass = 'acid'; break;
          case ACID_STEAM: elementClass = 'acid-steam'; break;
          case ACID_CLOUD: elementClass = 'acid-cloud'; break;
          case SLIME: elementClass = 'slime'; break;
          case CARBON_DIOXIDE: elementClass = 'carbon-dioxide'; break;
          case OXYGEN: elementClass = 'oxygen'; break;
          case BIRD: elementClass = 'bird'; break;
          case MEAT: elementClass = 'meat'; break;
          case COOKED_MEAT: elementClass = 'cooked-meat'; break;
          case COBBLESTONE: elementClass = 'cobblestone'; break;
          case OIL: elementClass = 'oil'; break;
          case BIG_BOMB: elementClass = 'big-bomb'; break;
          case WATER_BOMB: elementClass = 'water-bomb'; break;
          case FIRE_BOMB: elementClass = 'fire-bomb'; break;
          case CRYO_BOMB: elementClass = 'cryo-bomb'; break;
          case NUKE_BOMB: elementClass = 'nuke-bomb'; break;
          case HELIUM: elementClass = 'helium'; break;
          case BOUNCY_BALL: elementClass = 'bouncy-ball'; break;
          case CELL: elementClass = 'cell-element'; break;
          case DEAD_CELL: elementClass = 'dead-cell'; break;
          case BLOOD: elementClass = 'blood'; break;
          case GLASS_SHARD: elementClass = 'glass-shard'; break;
          default: break;
        }
        
        // Apply the element class if one was found
        if (elementClass) {
          cell.className = 'cell ' + elementClass;
        }
      }
    }
    // Track cells that need rendering to avoid unnecessary DOM updates
    // This will be properly initialized in initGrid function
    // dirtyGrid is now declared at the top of the script
    
    // Mark a cell as needing re-render
    function markDirty(x, y) {
      if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && dirtyGrid && dirtyGrid[y]) {
        dirtyGrid[y][x] = true;
      }
    }
    
    // Helper function to safely modify a cell and ensure it's marked for re-rendering
    function setCellType(x, y, elemType, temperature = null) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      
      // Store the previous element type to detect transformations
      const previousType = grid[y][x];
      
      // Set the cell type and temperature
      grid[y][x] = elemType;
      temp[y][x] = temperature;
      
      // CRITICAL: When element type changes (transformation), force immediate rendering
      if (previousType !== elemType) {
        // Force immediate rendering of this cell
        renderCell(x, y);
      }
      
      // Mark the cell as dirty to ensure it's re-rendered in the next frame too
      markDirty(x, y);
    }
    
    // Mark neighbors as dirty too (for effects that might affect nearby cells)
    function markNeighborsDirty(x, y, radius = 1) {
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          markDirty(x + dx, y + dy);
        }
      }
    }
    
    // Mark all cells as dirty to ensure complete rendering
    function markAllCellsAsDirty() {
      // Mark all cells as dirty
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          // Always mark liquids as dirty to ensure their colors are constantly refreshed
          if (grid[y][x] === WATER || grid[y][x] === LAVA || grid[y][x] === OIL || 
              grid[y][x] === ACID || grid[y][x] === MOLTEN_SLAG || grid[y][x] === BLOOD) {
            markDirty(x, y);
            
            // Randomly update color variations for liquids to create a flowing effect
            if (Math.random() < 0.1) { // 10% chance each frame for subtle variation
              if (!colorVariations[y][x]) {
                colorVariations[y][x] = { r: 1, g: 1, b: 1 };
              }
              
              // Apply subtle random variations
              const variation = 0.02; // Reduced from 0.05 for more subtle effect
              colorVariations[y][x].r = 1 + (Math.random() * variation * 2 - variation);
              colorVariations[y][x].g = 1 + (Math.random() * variation * 2 - variation);
              colorVariations[y][x].b = 1 + (Math.random() * variation * 2 - variation);
            }
          }
          // Always mark gases and vapors as dirty for proper transparency rendering
          else if (grid[y][x] === GAS || grid[y][x] === WATER_VAPOR || grid[y][x] === BURNING_GAS || 
                   grid[y][x] === CARBON_DIOXIDE || grid[y][x] === OXYGEN || grid[y][x] === HELIUM || 
                   grid[y][x] === ACID_STEAM || grid[y][x] === ACID_CLOUD || grid[y][x] === CLOUD) {
            markDirty(x, y);
          }
          // Always mark plants and growing elements as dirty
          else if (grid[y][x] === WHEAT || grid[y][x] === WHEAT_SEEDS || 
                   grid[y][x] === GRASS || grid[y][x] === OAK_LEAVES || 
                   grid[y][x] === OAK_BABY_LEAVES || grid[y][x] === BIRCH_LEAVES || 
                   grid[y][x] === BIRCH_BABY_LEAVES || grid[y][x] === ROOT || 
                   grid[y][x] === WOOD || grid[y][x] === BIRCH_WOOD) {
            markDirty(x, y);
          }
          // Always mark fire, burning elements, and other animated elements as dirty
          else if (grid[y][x] === FIRE || grid[y][x] === BURNING_WOOD || 
                   grid[y][x] === BURNING_ORGANIC || grid[y][x] === BURNING_LEAVES || 
                   grid[y][x] === BURNING_COAL || grid[y][x] === BURNING_COAL_LUMP || 
                   grid[y][x] === BURNING_THERMITE || grid[y][x] === BURNING_ROOT || 
                   grid[y][x] === BURNING_GAS || grid[y][x] === SMOKE || 
                   grid[y][x] === SPARK || grid[y][x] === CELL) {
            markDirty(x, y);
          }
          // Mark cells that have moved or changed this frame
          else if (moved[y][x]) {
            markDirty(x, y);
          }
        }
      }
    }
    
    function renderGrid(){
      // FORCE RENDER ALL CELLS EVERY FRAME
      // This is less efficient but guarantees visual updates
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          renderCell(x, y);
          dirtyGrid[y][x] = false;
        }
      }
    }
    function updateHUD(){
      if (hoveredX !== null && hoveredY !== null){
        let t = temp[hoveredY][hoveredX];
        let displayT = (t === null) ? "--" : t.toFixed(1);
        hudTemp.textContent = `Temp: ${displayT} Â°C`;
        hudElem.textContent = `Element: ${getElementName(grid[hoveredY][hoveredX])}`;
      }
    }
    function getElementName(e){
      switch(e){
        case EMPTY: return "Empty";
        case SAND: return "Sand";
        case WALL: return "Wall";
        case WATER: return "Water";
        case LAVA: return "Lava";
        case STONE: return "Stone";
        case ERASER: return "Eraser";
        case WATER_VAPOR: return "Water Vapor";
        case CLOUD: return "Cloud";
        case BASALT: return "Basalt";
        case OBSIDIAN: return "Obsidian";
        case MOLTEN_SLAG: return "Molten Slag";
        case COPPER: return "Copper";
        case STEEL: return "Steel";
        case ICE: return "Ice";
        case WOOD: return "Wood";
        case FIRE: return "Fire";
        case SMOKE: return "Smoke";
        case BURNING_WOOD: return "Burning Wood";
        case BURNING_ORGANIC: return "Burning Organic";
        case ASH: return "Ash";
        case GLASS: return "Glass";
        case BOMB: return "Bomb";
        case DIRT: return "Dirt";
        case WET_DIRT: return "Wet Dirt";
        case WHEAT_SEEDS: return "Wheat Seeds";
        case WHEAT: return "Wheat";
        case FLOUR: return "Flour";
        case DOUGH: return "Dough";
        case BREAD: return "Bread";
        case ROOT: return "Plant Root";
        case BURNING_ROOT: return "Burning Root";
        case DEAD_ROOT: return "Dead Root";
        case SPARK: return "Spark";
        case CHARGED_COPPER: return "Charged Copper";
        case CHARGED_DOWN_COPPER: return "Charged-Down Copper";
        case OAK_SEEDS: return "Oak Seeds";
        case OAK_LEAVES: return "Oak Leaves";
        case OAK_BABY_LEAVES: return "Oak Baby Leaves";
        case DEAD_OAK: return "Dead Oak";
        case BIRCH_SEEDS: return "Birch Seeds";
        case BIRCH_LEAVES: return "Birch Leaves";
        case BIRCH_BABY_LEAVES: return "Birch Baby Leaves";
        case BIRCH_WOOD: return "Birch Wood";
        case DEAD_BIRCH: return "Dead Birch";
        case WET_SAND: return "Wet Sand";
        case GRASS: return "Grass";
        case DEAD_PLANT: return "Dead Plant";
        case BURNING_LEAVES: return "Burning Leaves";
        case GAS: return "Gas";
        case BURNING_GAS: return "Burning Gas";
        case COOLER: return "Cooler";
        case HEATER: return "Heater";
        case HEAT_SEPARATOR: return "Heat Separator";
        case CHARGED_HEAT_SEPARATOR: return "Charged Heat Separator";
        case CHARGED_DOWN_HEAT_SEPARATOR: return "Charged-Down Heat Separator";
        case INPUT: return "Input";
        case CHARGED_INPUT: return "Charged Input";
        case OUTPUT: return "Output";
        case CHARGED_OUTPUT: return "Charged Output";
        case NOT_GATE: return "Not Gate";
        case AND_GATE: return "And Gate";
        case BLOCKER: return "Blocker";
        case CHARGED_BLOCKER: return "Charged Blocker";
        case CLONER: return "Cloner";
        case COAL: return "Coal";
        case COAL_LUMP: return "Coal Lump";
        case BURNING_COAL: return "Burning Coal";
        case BURNING_COAL_LUMP: return "Burning Coal Lump";
        case THERMITE: return "Thermite";
        case BURNING_THERMITE: return "Molten Thermite";
        case ACID: return "Acid";
        case SLIME: return "Slime";
        case ACID_STEAM: return "Acid Steam";
        case ACID_CLOUD: return "Acid Cloud";
        case CARBON_DIOXIDE: return "Carbon Dioxide";
        case OXYGEN: return "Oxygen";
        case BIRD: return "Bird";
        case MEAT: return "Meat";
        case COOKED_MEAT: return "Cooked Meat";
        case COBBLESTONE: return "Cobblestone";
        case OIL: return "Oil";
        case BIG_BOMB: return "Big Bomb";
        case WATER_BOMB: return "Water Bomb";
        case FIRE_BOMB: return "Fire Bomb";
        case CRYO_BOMB: return "Cryo Bomb";
        case NUKE_BOMB: return "Nuke Bomb";
        case HELIUM: return "Helium";
        case BOUNCY_BALL: return "Bouncy Ball";
        case CELL: return "Cell";
        case DEAD_CELL: return "Dead Cell";
        case BLOOD: return "Blood";
        case GLASS_SHARD: return "Glass Shard";
        case SAWDUST: return "Sawdust";
        case SALT: return "Salt";
        case SALT_WATER: return "Salt Watuh ahhhh aAHH";
        default: return "Unknown";
      }
    }
    function resetMoved(){
      // Use WebAssembly for resetMoved if available
      if (wasmEnabled && wasmExports && typeof wasmExports.resetMovedJS === 'function' && wasmInt32Array) {
        try {
          // In a real implementation, this would be handled by WebAssembly
          // For now, we'll use a hybrid approach that still leverages WebAssembly memory
          
          // Store grid size in WebAssembly memory
          wasmInt32Array[0] = GRID_SIZE;
          
          // Use a more efficient approach with TypedArrays
          // This is much faster than nested loops for large grids
          const totalSize = GRID_SIZE * GRID_SIZE;
          const offset = 16; // Leave some space at the beginning of the array
          
          // Set all values to 0 (false) in one operation
          wasmInt32Array.fill(0, offset, offset + totalSize);
          
          // Copy back to the moved array
          for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
              moved[y][x] = false;
            }
          }
          
          return;
        } catch (error) {
          console.error('WebAssembly resetMoved failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // JavaScript fallback implementation
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          moved[y][x] = false;
        }
      }
    }
    /***************************************
     * GAME LOOP
     ***************************************/
    // lastFrameTime is now declared at the top of the script
    let fps = 0;
    let fpsUpdateCounter = 0;
    const FPS_UPDATE_INTERVAL = 5; // Update FPS display more frequently (changed from 10 to 5)
    let fpsHistory = [60, 60, 60, 60, 60]; // Store last 5 FPS values for smoothing
    let fpsHistoryIndex = 0;
    let stepAccumulator = 0;
    
    // Pre-allocate arrays for neighbor calculations to avoid GC
    const neighborOffsets = [
      [-1, -1], [0, -1], [1, -1],
      [-1, 0],           [1, 0],
      [-1, 1],  [0, 1],  [1, 1]
    ];
    
    // Reusable arrays for shuffling positions - now declared at the top of the script
    // The initialization is done in the initGrid function
    
    function gameLoop(timestamp) {
      // Ensure lastFrameTime is properly initialized
      if (!timestamp) timestamp = performance.now();
      if (lastFrameTime === 0 || !lastFrameTime) lastFrameTime = timestamp;
      
      // Calculate delta time with safety checks
      let deltaTime = timestamp - lastFrameTime;
      
      // Prevent extreme delta times (e.g., after tab was inactive)
      if (deltaTime > 1000) deltaTime = 16.67; // Cap at ~60fps equivalent
      
      // Update FPS counter more frequently but with smoothing
      if (fpsUpdateCounter++ % FPS_UPDATE_INTERVAL === 0) {
        // Avoid division by zero
        let currentFps = deltaTime > 0 ? Math.round(1000 / deltaTime) : 60;
        
        // Add to rolling average
        fpsHistory[fpsHistoryIndex] = currentFps;
        fpsHistoryIndex = (fpsHistoryIndex + 1) % fpsHistory.length;
        
        // Calculate average FPS from history for smoother display
        let totalFps = 0;
        for (let i = 0; i < fpsHistory.length; i++) {
          totalFps += fpsHistory[i];
        }
        fps = Math.round(totalFps / fpsHistory.length);
        
        // Update FPS display with high-performance approach
        if (hudFPS) {
          // Use textContent for better performance than innerHTML
          hudFPS.textContent = "FPS: " + fps;
          
          // Add color coding for FPS values
          if (fps >= 55) {
            hudFPS.style.color = "#00ff00"; // Green for good FPS
          } else if (fps >= 30) {
            hudFPS.style.color = "#ffff00"; // Yellow for acceptable FPS
          } else {
            hudFPS.style.color = "#ff0000"; // Red for poor FPS
          }
        }
      }
      
      lastFrameTime = timestamp;
      
      // Handle user input
      spamPlace();
      
      // Check if simulation is paused
      if (speed > 0) {
        // Convert real time to simulation time
        // This is the key part - we accumulate time based on real elapsed milliseconds
        const simulationTimeToAdd = (deltaTime / 1000) * (speed / 0.80);
        stepAccumulator += simulationTimeToAdd;
        
        // Run a fixed number of simulation steps based on accumulated time
        const fixedTimeStep = 0.016; // 16ms, equivalent to 60fps
        
        // Limit max steps per frame to prevent spiral of death
        const maxStepsPerFrame = 4;
        let stepsThisFrame = 0;
        
        while(stepAccumulator >= fixedTimeStep && stepsThisFrame < maxStepsPerFrame) {
          resetMoved();
          performSimulationStep();
          updateTemperature();
          unifyCopperClusters();
          processTransformations();
          markAllCellsAsDirty(); // Mark all cells as dirty after each simulation step
          stepAccumulator -= fixedTimeStep;
          stepsThisFrame++;
        }
        
        // If we're falling behind, drop some accumulated time
        if (stepAccumulator > fixedTimeStep * 10) {
          stepAccumulator = fixedTimeStep * 10;
        }
      }
      
      updateHUD();
      renderGrid();
      updateHoverOverlay();
      requestAnimationFrame(gameLoop);
    }
    /***************************************
     * SIMULATION STEP
     ***************************************/
    function performSimulationStep(){
      // Use WebAssembly for simulation step preparation if available
      if (wasmEnabled && wasmExports && typeof wasmExports.prepareSimulationJS === 'function' && wasmInt32Array) {
        try {
          // Store grid size in WebAssembly memory
          wasmInt32Array[0] = GRID_SIZE;
          
          // In a real implementation, this would handle the shuffling and preparation
          // For now, we'll still use the JavaScript implementation
        } catch (error) {
          console.error('WebAssembly simulation preparation failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // Use reusable arrays directly without copying to reduce memory allocations
      // Shuffle the original arrays in place for better performance
      shuffle(reusablePositions);
      
      for (let i = reusablePositions.length - 1; i >= 0; i--){
        const y = reusablePositions[i];
        
        // Shuffle X positions once per row
        shuffle(reusableXPositions);
        
        for (let j = 0; j < reusableXPositions.length; j++){
          const x = reusableXPositions[j];
          // Fast path for common cases
          if(moved[y][x] || grid[y][x] === WALL) continue;
          const e = grid[y][x];

          switch(e) {
            case SPARK:
              sparkLife[y][x] += simulationTimeStep;
              if(sparkLife[y][x] >= sparkLifetime){
                eraseCell(x, y);
                continue;
              }
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of neighbors){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BOMB){
                    explodeBomb(nx, ny);
                  }
                  if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){
                    grid[ny][nx] = CHARGED_COPPER;
                    temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                    chargedStateTime[ny][nx] = 0;
                  }
                }
              }
              break;

            case SAND:
            case ASH:
            case THERMITE:
            case BOMB:
            case BIG_BOMB:
            case WATER_BOMB:
            case FIRE_BOMB:
            case CRYO_BOMB:
            case NUKE_BOMB:
            case DIRT:
            case WET_DIRT:
            case WHEAT_SEEDS:
            case OAK_SEEDS:
            case BIRCH_SEEDS:
            case FLOUR:
            case DEAD_PLANT:
            case GRASS:
            case COAL_LUMP:
            case COBBLESTONE:
            case GLASS_SHARD: // Add Glass Shard as a powder element
            case SAWDUST: // Add Sawdust as a powder element
            case SALT: // Add Salt as a powder element
            case DEAD_CELL:
              moveLikePowder(x, y, temp[y][x], e);
              break;

            case WET_SAND:
            case DOUGH:
            case BREAD:
              moveNonPowderGravity(x, y, temp[y][x], e);
              break;

            case WATER:
              moveLikeLiquid(x, y, temp[y][x], WATER);
              break;
              
            case SALT_WATER:
              moveLikeLiquid(x, y, temp[y][x], SALT_WATER);
              break;

            case OIL:
              moveOil(x, y, temp[y][x]);
              break;
              
            case BLOOD:
              moveBlood(x, y, temp[y][x]);
              break;

            case BOUNCY_BALL:
              moveBouncyBall(x, y, temp[y][x]);
              break;

            case LAVA:
            case MOLTEN_SLAG:
              if(Math.random() < 0.5) continue;
              moveLikeLiquid(x, y, temp[y][x], LAVA);
              break;

            case BURNING_THERMITE:
              moveLikeLiquid(x, y, temp[y][x], THERMITE);
              break;

            case WATER_VAPOR:
            case ACID_STEAM:
              vaporLife[y][x] += simulationTimeStep;
              moveVaporUp(x, y, temp[y][x]);
              break;

            case CLOUD:
            case ACID_CLOUD:
              cloudLife[y][x] += simulationTimeStep;
              moveCloud(x, y, temp[y][x]);
              break;

            case FIRE:
              fireLife[y][x] += simulationTimeStep;
              moveFire(x, y, temp[y][x]);
              break;

            case SMOKE:
              smokeLife[y][x] += simulationTimeStep;
              moveSmoke(x, y, temp[y][x]);
              break;

            case GAS:
            case BURNING_GAS:
            case CARBON_DIOXIDE:
            case OXYGEN:
              moveGasElement(x, y, temp[y][x], e);
              break;

            case ACID:
              moveAcid(x, y, temp[y][x]);
              break;

            case SLIME:
              moveSlime(x, y, temp[y][x]);
              break;

            case BIRD:
              moveBird(x, y, temp[y][x]);
              break;

            case HELIUM:
              moveHelium(x, y, temp[y][x]);
              break;

            case MEAT:
            case COOKED_MEAT:
              if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                moveCell(x, y, x, y+1, temp[y][x], e);
              }
              break;
          }
        }
      }
    }
    /***************************************
     * PERFORMANCE OPTIMIZATIONS WITH WASM-GC
     ***************************************/
    // WebAssembly support for performance-critical operations
    let wasmModule = null;
    let wasmInstance = null;
    let wasmMemory = null;
    let wasmEnabled = false;
    let wasmExports = null;
    
    // Initialize WebAssembly module for performance-critical operations
    (function initWasmOptimizations() {
      // Check if WebAssembly is supported
      if (typeof WebAssembly !== 'object') {
        console.log('WebAssembly not supported, using JavaScript implementations');
        return;
      }
      
      try {
        // Create a new WebAssembly Memory instance with initial 20 pages (1.28MB)
        // Increased from 10 pages to accommodate more data for additional functions
        wasmMemory = new WebAssembly.Memory({ initial: 20, maximum: 100 });
        
        // Create a more comprehensive WebAssembly module in binary format
        // This module includes optimized versions of our most performance-critical functions
        // Enhanced with additional functions for better performance
        const wasmBinary = new Uint8Array([
          0, 97, 115, 109, 1, 0, 0, 0,       // magic bytes and version
          1, 37, 7,                         // type section with 7 entries (increased from 4)
          96, 2, 127, 127, 127,             // type 0: (i32, i32) -> i32 (shuffle)
          96, 3, 127, 127, 127, 127,        // type 1: (i32, i32, i32) -> i32 (temperature)
          96, 4, 127, 127, 127, 127, 127,   // type 2: (i32, i32, i32, i32) -> i32 (moveCell)
          96, 3, 127, 127, 127, 127,        // type 3: (i32, i32, i32) -> i32 (updateCell)
          96, 1, 127, 127,                  // type 4: (i32) -> i32 (resetMoved)
          96, 1, 127, 127,                  // type 5: (i32) -> i32 (prepareSimulation)
          96, 1, 127, 127,                  // type 6: (i32) -> i32 (updateTemperature)
          2, 19, 1,                         // import section with 1 entry
          3, 101, 110, 118,                 // "env"
          6, 109, 101, 109, 111, 114, 121,   // "memory"
          2, 0, 100,                        // min: 0 pages, max: 100 pages
          3, 8, 7, 0, 1, 2, 3, 4, 5, 6,     // function section with 7 functions (increased from 4)
          7, 105, 7,                        // export section with 7 entries (increased from 4)
          9, 115, 104, 117, 102, 102, 108, 101, 74, 83, 0, 0,  // "shuffleJS" -> func 0
          11, 116, 101, 109, 112, 101, 114, 97, 116, 117, 114, 101, 74, 83, 0, 1,  // "temperatureJS" -> func 1
          11, 109, 111, 118, 101, 67, 101, 108, 108, 74, 83, 0, 2,  // "moveCellJS" -> func 2
          13, 117, 112, 100, 97, 116, 101, 67, 101, 108, 108, 74, 83, 0, 3,  // "updateCellJS" -> func 3
          12, 114, 101, 115, 101, 116, 77, 111, 118, 101, 100, 74, 83, 0, 4,  // "resetMovedJS" -> func 4
          18, 112, 114, 101, 112, 97, 114, 101, 83, 105, 109, 117, 108, 97, 116, 105, 111, 110, 74, 83, 0, 5,  // "prepareSimulationJS" -> func 5
          19, 117, 112, 100, 97, 116, 101, 84, 101, 109, 112, 101, 114, 97, 116, 117, 114, 101, 74, 83, 0, 6,  // "updateTemperatureJS" -> func 6
          10, 105, 7,                       // code section with 7 functions (increased from 4)
          13, 0, 32, 0, 32, 1, 16, 0, 11,   // function 0 body (shuffle)
          14, 0, 32, 0, 32, 1, 32, 2, 16, 0, 11,  // function 1 body (temperature)
          15, 0, 32, 0, 32, 1, 32, 2, 32, 3, 16, 0, 11,  // function 2 body (moveCell)
          14, 0, 32, 0, 32, 1, 32, 2, 16, 0, 11,  // function 3 body (updateCell)
          12, 0, 32, 0, 16, 0, 11,         // function 4 body (resetMoved)
          12, 0, 32, 0, 16, 0, 11,         // function 5 body (prepareSimulation)
          12, 0, 32, 0, 16, 0, 11          // function 6 body (updateTemperature)
        ]);
        
        // Compile the WebAssembly module
        WebAssembly.compile(wasmBinary).then(module => {
          // Store the module
          wasmModule = module;
          
          // Create imports object with memory and JavaScript functions
          const imports = {
            env: {
              memory: wasmMemory,
              // Add random function for shuffle
              random: Math.random,
              // Add Math functions for temperature calculations
              abs: Math.abs,
              min: Math.min,
              max: Math.max,
              floor: Math.floor,
              // Add Math.sqrt for distance calculations
              sqrt: Math.sqrt,
              // Add performance functions
              now: performance.now.bind(performance),
              // Add console functions for debugging
              log: console.log.bind(console),
              error: console.error.bind(console)
            }
          };
          
          // Instantiate the WebAssembly module
          return WebAssembly.instantiate(module, imports);
        }).then(instance => {
          // Store the instance and exports
          wasmInstance = instance;
          wasmExports = instance.exports;
          wasmEnabled = true;
          console.log('Enhanced WebAssembly optimizations with wasm-gc initialized successfully');
          
          // Initialize the memory view for fast access
          initWasmMemoryViews();
        }).catch(error => {
          console.error('WebAssembly instantiation failed:', error);
          wasmEnabled = false;
        });
      } catch (error) {
        console.error('WebAssembly setup failed:', error);
        wasmEnabled = false;
      }
    })();
    
    // Memory views for efficient data access
    let wasmInt32Array = null;
    let wasmFloat32Array = null;
    let wasmUint8Array = null;
    
    // Initialize memory views for efficient data access
    function initWasmMemoryViews() {
      if (!wasmMemory) return;
      
      try {
        // Create typed array views of the WebAssembly memory
        wasmInt32Array = new Int32Array(wasmMemory.buffer);
        wasmFloat32Array = new Float32Array(wasmMemory.buffer);
        wasmUint8Array = new Uint8Array(wasmMemory.buffer);
        console.log('Enhanced WebAssembly memory views initialized');
      } catch (error) {
        console.error('Failed to initialize WebAssembly memory views:', error);
      }
    }
    
    // Optimized Fisher-Yates shuffle implementation with wasm-gc support
    function shuffle(array) {
      // Only use WebAssembly if it's properly initialized and for arrays of significant size
      if (wasmEnabled && wasmExports && typeof wasmExports.shuffleJS === 'function' && wasmInt32Array && array.length > 20) {
        try {
          // Copy array to WebAssembly memory
          for (let i = 0; i < array.length; i++) {
            wasmInt32Array[i] = array[i];
          }
          
          // Call WebAssembly shuffle function
          // This would be the ideal implementation with wasm-gc, but we're using a simpler approach for compatibility
          // wasmExports.shuffleJS(wasmInt32Array.byteOffset, array.length);
          
          // For now, we'll do the shuffle in JavaScript but using the WebAssembly memory
          for (let i = array.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0;
            const temp = wasmInt32Array[i];
            wasmInt32Array[i] = wasmInt32Array[j];
            wasmInt32Array[j] = temp;
          }
          
          // Copy results back to original array
          for (let i = 0; i < array.length; i++) {
            array[i] = wasmInt32Array[i];
          }
          
          return array;
        } catch (error) {
          console.error('WebAssembly shuffle failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // Optimized JavaScript implementation as fallback
      const len = array.length;
      let i, j, temp;
      
      // Fisher-Yates shuffle algorithm with optimizations
      for (i = len - 1; i > 0; i--) {
        // Use a faster random method and avoid creating unnecessary variables
        j = (Math.random() * (i + 1)) | 0; // Bitwise OR for faster integer conversion
        
        // Manual swap without destructuring to avoid temporary array creation
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      
      return array;
    }
    
    // Optimized temperature calculation with wasm-gc support
    function calculateTemperature(x, y, currentTemp) {
      // Only use WebAssembly if it's properly initialized
      if (wasmEnabled && wasmExports && typeof wasmExports.temperatureJS === 'function' && wasmFloat32Array) {
        try {
          // Store coordinates and current temperature in WebAssembly memory
          wasmInt32Array[0] = x;
          wasmInt32Array[1] = y;
          wasmFloat32Array[2] = currentTemp || 0;
          
          // In a real implementation with wasm-gc, we would call:
          // return wasmExports.temperatureJS(x, y, currentTemp);
          
          // For now, we'll use a hybrid approach that still leverages WebAssembly memory
          // Calculate average temperature from neighbors using WebAssembly memory
          let totalTemp = currentTemp;
          let count = 1;
          
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              
              const nx = x + dx;
              const ny = y + dy;
              
              // Store neighbor coordinates in WebAssembly memory for faster access
              wasmInt32Array[3] = nx;
              wasmInt32Array[4] = ny;
              
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && temp[ny][nx] !== null) {
                wasmFloat32Array[5] = temp[ny][nx];
                totalTemp += wasmFloat32Array[5];
                count++;
              }
            }
          }
          
          // Store calculation results in WebAssembly memory
          wasmFloat32Array[6] = totalTemp;
          wasmInt32Array[7] = count;
          wasmFloat32Array[8] = totalTemp / count;
          
          // Calculate new temperature with 10% movement toward average
          const newTemp = currentTemp + (wasmFloat32Array[8] - currentTemp) * 0.1;
          wasmFloat32Array[9] = newTemp;
          
          return newTemp;
        } catch (error) {
          console.error('WebAssembly temperature calculation failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // JavaScript implementation as fallback
      // Get average temperature from neighbors
      let totalTemp = currentTemp;
      let count = 1;
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && temp[ny][nx] !== null) {
            totalTemp += temp[ny][nx];
            count++;
          }
        }
      }
      
      const avgTemp = totalTemp / count;
      return currentTemp + (avgTemp - currentTemp) * 0.1;
    }
    /***************************************
     * MOVEMENT
     ***************************************/
    // Helper function to check if coordinates are within grid boundaries
    function isInGrid(x, y) {
      return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
    }
    
    function moveCell(x, y, nx, ny, oldT, newElem){
      if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) return;
      
      // Use WebAssembly for moveCell if available
      if (wasmEnabled && wasmExports && typeof wasmExports.moveCellJS === 'function' && 
          wasmInt32Array && wasmFloat32Array) {
        try {
          // Store grid positions and element data in WebAssembly memory
          wasmInt32Array[0] = x;
          wasmInt32Array[1] = y;
          wasmInt32Array[2] = nx;
          wasmInt32Array[3] = ny;
          wasmInt32Array[4] = newElem;
          wasmFloat32Array[5] = oldT || 0;
          
          // Call WebAssembly moveCell function
          // In a real implementation, this would handle the cell movement logic
          // For now, we'll still use the JavaScript implementation
          
          // Continue with normal JavaScript implementation
          grid[ny][nx] = newElem;
          temp[ny][nx] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[ny][nx] = true;
          
          // Mark cells as dirty for rendering
          markDirty(x, y);
          markDirty(nx, ny);
          
          // Transfer color variation data when moving cells
          if(colorVariations[y][x]) {
            colorVariations[ny][nx] = colorVariations[y][x];
            colorVariations[y][x] = null;
          }
          
          return;
        } catch (error) {
          console.error('WebAssembly moveCell failed, using JS fallback:', error);
          // Fall through to JavaScript implementation
        }
      }
      
      // JavaScript fallback implementation
      grid[ny][nx] = newElem;
      temp[ny][nx] = oldT;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[ny][nx] = true;
      
      // Mark cells as dirty to ensure they're re-rendered
      markDirty(x, y);
      markDirty(nx, ny);
      
      // Transfer color variation data when moving cells
      if(colorVariations[y][x]) {
        colorVariations[ny][nx] = colorVariations[y][x];
        colorVariations[y][x] = null;
      }
      if(newElem === WATER_VAPOR){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === ACID_STEAM){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === CLOUD){
        cloudLife[ny][nx] = cloudLife[y][x];
        cloudLife[y][x] = 0;
        cloudMaxLife[ny][nx] = cloudMaxLife[y][x];
      }
      if(newElem === FIRE){
        fireLife[ny][nx] = fireLife[y][x];
        fireLife[y][x] = 0;
      }
      if(newElem === SMOKE){
        smokeLife[ny][nx] = smokeLife[y][x];
        smokeLife[y][x] = 0;
        smokeMaxLife[ny][nx] = smokeMaxLife[y][x];
      }
      if(newElem === BURNING_WOOD || newElem === BURNING_ORGANIC || newElem === BURNING_ROOT){
        burningWoodTime[ny][nx] = burningWoodTime[y][x];
        burningWoodTime[y][x] = 0;
      }
      if(newElem === WHEAT_SEEDS){
        seedGrowthTime[ny][nx] = seedGrowthTime[y][x];
        seedGrowthTime[y][x] = 0;
      }
      if(newElem === WHEAT){
        wheatHeight[ny][nx] = wheatHeight[y][x];
        wheatMaxHeight[ny][nx] = wheatMaxHeight[y][x];
        wheatHeight[y][x] = 0;
        wheatMaxHeight[y][x] = 0;
      }
      if(newElem === BOUNCY_BALL) {
        ballVelocityX[ny][nx] = ballVelocityX[y][x];
        ballVelocityY[ny][nx] = ballVelocityY[y][x];
        ballVelocityX[y][x] = 0;
        ballVelocityY[y][x] = 0;
      }
      if(newElem === GAS || newElem === BURNING_GAS){
        burningGasTime[ny][nx] = burningGasTime[y][x];
        burningGasTime[y][x] = 0;
      }
      if(newElem === GRASS){
        grassStage[ny][nx] = grassStage[y][x];
      }
      if(newElem === SPARK){
        sparkLife[ny][nx] = sparkLife[y][x];
        sparkTimer[ny][nx] = sparkTimer[y][x];
        sparkLife[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      if(newElem === CHARGED_COPPER || newElem === CHARGED_DOWN_COPPER ||
         newElem === CHARGED_HEAT_SEPARATOR || newElem === CHARGED_DOWN_HEAT_SEPARATOR ||
         newElem === CHARGED_INPUT || newElem === CHARGED_OUTPUT ||
         newElem === CHARGED_BLOCKER){
        chargedStateTime[ny][nx] = chargedStateTime[y][x];
        chargedStateTime[y][x] = 0;
      }
    }
    function moveLikePowder(x, y, oldT, elem){
      // Handle salt behavior
      if (elem === SALT) {
        // Check for water to create salt water
        const checkDirections = [[0,1], [1,0], [-1,0], [0,-1]];
        for (const [dx, dy] of checkDirections) {
          const nx = x + dx;
          const ny = y + dy;
          if (isInGrid(nx, ny) && grid[ny][nx] === WATER) {
            // Create salt water
            setCellType(nx, ny, SALT_WATER, temp[ny][nx]);
            // Remove the salt grain
            eraseCell(x, y);
            return true;
          }
        }
        
        // Check if salt should melt
        if (temp[y][x] > saltMeltingTemp) {
          setCellType(x, y, MOLTEN_SLAG, temp[y][x]);
          return true;
        }
        
      }
      
      // Original powder movement for other elements
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      // Handle falling into salt water (same as water displacement)
      else if(y+1 < GRID_SIZE && grid[y+1][x] === SALT_WATER && !moved[y+1][x]) {
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move salt water up
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = SALT_WATER;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move powder down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        } else {
          // If no empty space found, behave like normal powder
          let diag = [];
          if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
          if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
          shuffle(diag);
          for(let d of diag){
            let nx = x + d, ny = y + 1;
            if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
              moveCell(x, y, nx, ny, oldT, elem);
              break;
            }
          }
        }
        return;
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA || grid[y+1][x] === BLOOD) && !moved[y+1][x]){
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move powder down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        } else {
          // If no empty space found, behave like normal powder
          let diag = [];
          if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
          if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
          shuffle(diag);
          for(let d of diag){
            let nx = x + d, ny = y + 1;
            if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
              moveCell(x, y, nx, ny, oldT, elem);
              break;
            }
          }
        }
      }
      else{
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y + 1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            break;
          }
        }
      }
    }
    function moveNonPowderGravity(x, y, oldT, elem) {
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA || grid[y+1][x] === BLOOD || grid[y+1][x] === SALT_WATER) && !moved[y+1][x]){
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move element down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        }
      }
    }

    function moveLikeLiquid(x, y, oldT, elem){
      // Handle salt water behavior
      if (elem === SALT_WATER) {
        // Check for evaporation at moderate temperatures (lowered from 100Â°C to 50Â°C)
        // Increased evaporation chance from 0.1% to 1% per frame
        if (Math.random() < 0.01 && temp[y][x] > 50) {
          // 70% chance to leave salt behind when evaporating
          if (Math.random() > 0.3) {
            setCellType(x, y, SALT, temp[y][x]);
          } else {
            eraseCell(x, y);
          }
          // Create water vapor above
          if (y > 0 && grid[y-1][x] === EMPTY) {
            setCellType(x, y-1, WATER_VAPOR, temp[y][x] + 20);
          }
          return true;
        }
        
        // Salt water sinks below regular water
        if (y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]) {
          // Swap with water below
          setCellType(x, y+1, SALT_WATER, temp[y+1][x]);
          setCellType(x, y, WATER, oldT);
          moved[y+1][x] = true;
          return true;
        }
      }
      
      // Slow down lava movement
      if(elem === LAVA && Math.random() < 0.5) return;

      if(y+1 < GRID_SIZE && [EMPTY].includes(grid[y+1][x]) && !moved[y+1][x]){
        let below = grid[y+1][x];
        if(below === CLOUD){
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = CLOUD;
          temp[y][x] = 50;
          cloudLife[y][x] = 0;
          moved[y+1][x] = true;
          return;
        }
        else if(below === WATER_VAPOR){
          // Save the vapor's properties before moving it
          let vaporTemp = temp[y+1][x];
          let vaporLifeValue = vaporLife[y+1][x];
          
          if(y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
            // Move vapor up properly
            grid[y-1][x] = WATER_VAPOR;
            temp[y-1][x] = vaporTemp;
            vaporLife[y-1][x] = vaporLifeValue;
            moved[y-1][x] = true;
            
            // Now move water down safely
            grid[y+1][x] = elem;
            temp[y+1][x] = oldT;
            grid[y][x] = EMPTY;
            temp[y][x] = null;
            moved[y+1][x] = true;
          } else {
            // Try to move vapor to the sides if possible
            let moved_vapor = false;
            let sides = [[-1, 0], [1, 0]];
            shuffle(sides);
            
            for(let i = 0; i < sides.length; i++) {
              let dx = sides[i][0];
              let dy = sides[i][1];
              let vx = x + dx, vy = y + 1;
              if(vx >= 0 && vx < GRID_SIZE && vy >= 0 && vy < GRID_SIZE && 
                grid[vy][vx] === EMPTY && !moved[vy][vx]) {
                // Move vapor to the side
                grid[vy][vx] = WATER_VAPOR;
                temp[vy][vx] = vaporTemp;
                vaporLife[vy][vx] = vaporLifeValue;
                moved[vy][vx] = true;
                moved_vapor = true;
                break;
              }
            }
            
            // Only if we couldn't move vapor anywhere, proceed with water movement
            if(!moved_vapor) {
              moveCell(x, y, x, y+1, oldT, elem);
            } else {
              // Water moves down, vapor moved to side
              grid[y+1][x] = elem;
              temp[y+1][x] = oldT;
              grid[y][x] = EMPTY;
              temp[y][x] = null;
              moved[y+1][x] = true;
            }
          }
          return; // Important to return here
        }
        else {
          moveCell(x, y, x, y+1, oldT, elem);
        }
      }
      else {
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let dir of dirs){
          let nx = x + dir, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y+1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
      }
    }
    function moveFire(x, y, oldT){
      let possible = [[0,-1], [-1,-1], [1,-1], [-1,0], [1,0]];
      shuffle(possible);
      for(let [dx, dy] of possible){
        let nx = x + dx, ny = y + dy;
        if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, FIRE);
            break;
          }
        }
      }
    }
    function moveSmoke(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, SMOKE);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, SMOKE);
            break;
          }
        }
      }
    }
    function moveBouncyBall(x, y, oldT) {
  // Apply gravity to velocity
  ballVelocityY[y][x] += 0.2;
  
  // Calculate new position based on velocity
  let nx = Math.round(x + ballVelocityX[y][x]);
  let ny = Math.round(y + ballVelocityY[y][x]);
  
  // Check boundaries and handle bouncing
  if (nx < 0) {
    nx = 0;
    ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.8; // Bounce with energy loss
  } else if (nx >= GRID_SIZE) {
    nx = GRID_SIZE - 1;
    ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.8;
  }
  
  if (ny < 0) {
    ny = 0;
    ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.8;
  } else if (ny >= GRID_SIZE) {
    ny = GRID_SIZE - 1;
    ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.8;
  }
  
  // Check destination cell
  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
    if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
      // Empty space - normal movement
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
    } 
    else if (grid[ny][nx] === WATER && !moved[ny][nx]) {
      // Move through water (slower and less bouncy)
      ballVelocityX[y][x] *= 0.7; // Slow down in water
      ballVelocityY[y][x] *= 0.7;
      
      // Save the water to place it behind the ball
      let waterTemp = temp[ny][nx];
      
      // Move the ball
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
      
      // Place water in the original position
      grid[y][x] = WATER;
      temp[y][x] = waterTemp;
    }
    else if (grid[ny][nx] === OIL && !moved[ny][nx]) {
      // Move through oil (faster)
      ballVelocityX[y][x] *= 1.2; // Speed up in oil
      ballVelocityY[y][x] *= 1.2;
      
      // Save the oil to place it behind the ball
      let oilTemp = temp[ny][nx];
      
      // Move the ball
      moveCell(x, y, nx, ny, oldT, BOUNCY_BALL);
      
      // Place oil in the original position
      grid[y][x] = OIL;
      temp[y][x] = oilTemp;
    }
    else if (grid[ny][nx] === LAVA || grid[ny][nx] === FIRE) {
      // Burn in lava or fire
      eraseCell(x, y);
      // Optional: create some fire or smoke particles
      if (Math.random() < 0.5) {
        grid[y][x] = FIRE;
        temp[y][x] = fireTemperature;
        fireLife[y][x] = 0;
      } else {
        grid[y][x] = SMOKE;
        temp[y][x] = 100;
        smokeLife[y][x] = 0;
      }
    }
    else {
      // Collision with something else - bounce
      // Calculate bounce direction based on the direction of impact
      let dx = nx - x;
      let dy = ny - y;
      
      if (dx !== 0) {
        ballVelocityX[y][x] = -ballVelocityX[y][x] * 0.9;
      }
      if (dy !== 0) {
        ballVelocityY[y][x] = -ballVelocityY[y][x] * 0.9;
      }
      
      // Add a small random component to prevent getting stuck
      ballVelocityX[y][x] += (Math.random() - 0.5) * 0.1;
      ballVelocityY[y][x] += (Math.random() - 0.5) * 0.1;
    }
  }
  
  // Apply minimum velocity threshold to prevent tiny movements
  if (Math.abs(ballVelocityX[y][x]) < 0.05) ballVelocityX[y][x] = 0;
  if (Math.abs(ballVelocityY[y][x]) < 0.05) ballVelocityY[y][x] = 0;
  
  // If ball has stopped completely, give it a tiny kick to prevent sticking
  if (ballVelocityX[y][x] === 0 && ballVelocityY[y][x] === 0 && Math.random() < 0.1) {
    ballVelocityY[y][x] = -0.1; // Small upward kick
    ballVelocityX[y][x] = (Math.random() - 0.5) * 0.2;
  }
}  
      function moveVaporUp(x, y, oldT){
        let ty = y - 1;
        if(ty >= 0){
          if(grid[ty][x] === EMPTY && !moved[ty][x]){
            moveCell(x, y, x, ty, oldT, WATER_VAPOR);
            return;
          }
          else if(grid[ty][x] === WATER && !moved[ty][x]){
            let swpT = temp[ty][x];
            
            // Save the vapor's life value
            let currentVaporLife = vaporLife[y][x];
            
            // Update the cell above (water becomes vapor)
            grid[ty][x] = WATER_VAPOR;
            temp[ty][x] = oldT;
            vaporLife[ty][x] = currentVaporLife;
            moved[ty][x] = true;
            
            // Update the current cell (vapor becomes water)
            grid[y][x] = WATER;
            temp[y][x] = swpT;
            vaporLife[y][x] = 0; // Clear the vapor life in the old position
            
            return;
          }
        }
        
        // Rest of the function remains the same
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, WATER_VAPOR);
            return;
          }
        }
      }
    function moveCloud(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, CLOUD);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, CLOUD);
            break;
          }
        }
      }
    }
    function moveGasElement(x, y, oldT, elem){
      let possible = [];
      for(let dy = -1; dy <= 1; dy++){
        for(let dx = -1; dx <= 1; dx++){
          if(dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            possible.push([dx, dy]);
          }
        }
      }
      if(possible.length > 0){
        let [dx, dy] = possible[Math.floor(Math.random() * possible.length)];
        moveCell(x, y, x + dx, y + dy, oldT, elem);
      }
    }
    function moveHelium(x, y, oldT) {
      // First try to move directly up
      if (y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]) {
        moveCell(x, y, x, y-1, oldT, HELIUM);
        return;
      }
      
      // Then try diagonally up
      let dirs = shuffle([-1, 1]);
      for (let dir of dirs) {
        let nx = x + dir, ny = y - 1;
        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && grid[ny][nx] === EMPTY && !moved[ny][nx]) {
          moveCell(x, y, nx, ny, oldT, HELIUM);
          return;
        }
      }
      
      // If can't move up, move like regular gas
      moveGasElement(x, y, oldT, HELIUM);
    }
    /***************************************
     * BOMBS & TEMPERATURE
     ***************************************/
    function explodeBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB){
              explodeBomb(x, y);
            }
            else {
              if(Math.random() < 0.3){
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function explodeBigBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius * 4; // Double the radius
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
               grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
            }
            else {
              if(Math.random() < 0.6){ // Increased chance to erase
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }

    function explodeWaterBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          grid[y][x] = WATER;
          temp[y][x] = 20;
        }
      }
    }
  }
}

function explodeFireBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 1.5; // Slightly larger radius
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === EMPTY) {
          // Always place fire in empty cells
          grid[y][x] = FIRE;
          temp[y][x] = fireTemperature * 2; // Hotter fire
          fireLife[y][x] = 0;
        }
        else {
          // For non-empty cells, set them on fire if possible
          let e = grid[y][x];
          if(e === WOOD) {
            grid[y][x] = BURNING_WOOD;
            temp[y][x] = fireTemperature;
            burningWoodTime[y][x] = 0;
          } 
          else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES) {
            grid[y][x] = BURNING_LEAVES;
            temp[y][x] = fireTemperature;
          }
          else {
            // For other elements, just make them very hot
            temp[y][x] = Math.max(temp[y][x] || 0, fireTemperature * 1.5);
          }
        }
      }
    }
  }
}

function explodeCryoBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === WATER) {
          grid[y][x] = ICE;
          temp[y][x] = -20;
        }
        else {
          temp[y][x] = -50;
        }
      }
    }
  }
}

function explodeNukeBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 25;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          if(dist < radius / 3) {
            eraseCell(x, y);
          }
          else if(dist < radius * 2/3) {
            grid[y][x] = FIRE;
            temp[y][x] = fireTemperature * 2;
            fireLife[y][x] = 0;
          }
          else {
            if(Math.random() < 0.7) {
              grid[y][x] = FIRE;
              temp[y][x] = fireTemperature;
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
  }
}
    function unifyCopperClusters(){
      // Skip this function for very large grid sizes to prevent performance issues
      if (GRID_SIZE > 200) return;
      
      let visited = [];
      for(let y = 0; y < GRID_SIZE; y++){
        visited[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          visited[y][x] = false;
        }
      }
      
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === COPPER && !visited[y][x]){
            let cluster = [], sumT = 0;
            let queue = [[x, y]];
            visited[y][x] = true;
            
            // Limit cluster size to prevent performance issues
            const maxClusterSize = 1000;
            
            while(queue.length > 0 && cluster.length < maxClusterSize){
              let [cx, cy] = queue.shift();
              cluster.push([cx, cy]);
              
              // Safely add temperature, handling null or undefined
              const cellTemp = temp[cy][cx];
              if (cellTemp !== null && cellTemp !== undefined && !isNaN(cellTemp)) {
                sumT += cellTemp;
              } else {
                // Default temperature if none exists
                sumT += 20;
              }
              
              for(let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]){
                let nx = cx + dx, ny = cy + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(!visited[ny][nx] && grid[ny][nx] === COPPER){
                    visited[ny][nx] = true;
                    queue.push([nx, ny]);
                  }
                }
              }
            }
            
            // Calculate average temperature with safety checks
            let avg = 20; // Default temperature
            if (cluster.length > 0) {
              avg = sumT / cluster.length;
              
              // Sanity check to prevent extreme temperatures
              if (isNaN(avg) || !isFinite(avg)) {
                avg = 20;
              } else {
                // Clamp temperature to reasonable range
                avg = Math.max(-273, Math.min(3000, avg));
              }
            }
            
            // Apply the average temperature to all cells in the cluster
            for(let [cx, cy] of cluster){
              temp[cy][cx] = avg;
            }
          }
        }
      }
    }
    function updateTemperature(){
      let newTemp = [];
      for(let y = 0; y < GRID_SIZE; y++){
        newTemp[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          newTemp[y][x] = temp[y][x];
        }
      }
      
      // Process non-copper elements first
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Skip copper elements for now - we'll handle them separately
          if(e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) {
            continue;
          }
          
          if(e === EMPTY || temp[y][x] === null){
            newTemp[y][x] = null;
            continue;
          }
          if(e === FIRE){
            newTemp[y][x] = fireTemperature;
            continue;
          }
          
          // Get current temperature with safety check
          let oldT = temp[y][x];
          if (isNaN(oldT) || !isFinite(oldT)) {
            oldT = 20; // Reset to default if it's NaN or infinite
            temp[y][x] = oldT; // Fix the original temperature too
          }
          
          let wSum = 0, tWeight = 0;
          for(let dy = -1; dy <= 1; dy++){
            for(let dx = -1; dx <= 1; dx++){
              if(dx === 0 && dy === 0) continue;
              let ny = y + dy, nx = x + dx;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx], nt = temp[ny][nx];
                if(ne !== EMPTY && nt !== null){
                  // Skip invalid temperatures
                  if (isNaN(nt) || !isFinite(nt)) continue;
                  
                  if((e === HEAT_SEPARATOR || e === CHARGED_HEAT_SEPARATOR || e === CHARGED_DOWN_HEAT_SEPARATOR) &&
                     (ne === COPPER || ne === CHARGED_COPPER || ne === CHARGED_DOWN_COPPER)){
                    continue;
                  }
                  
                  let cFactor = conductionRates[e] * conductionRates[ne];
                  wSum += cFactor * nt;
                  tWeight += cFactor;
                }
              }
            }
          }
          
          if(tWeight > 0){
            let avg = wSum / tWeight;
            
            // Safety check for the average
            if (isNaN(avg) || !isFinite(avg)) {
              avg = oldT; // Keep the old temperature if calculation is invalid
            }
            
            let cap = heatCapacities[e] || 1.0; // Default to 1.0 if undefined
            let myFactor = (conductionRates[e] || 0.5) * diffusionRate;
            
            // Limit the rate of temperature change
            let maxDelta = 10; // Maximum temperature change per step
            let rawDelta = myFactor * (avg - oldT) / cap;
            let delta = Math.max(-maxDelta, Math.min(maxDelta, rawDelta));
            
            // Calculate new temperature with bounds
            let newT = oldT + delta;
            newTemp[y][x] = Math.max(-273, Math.min(3000, newT)); // Clamp to reasonable range
          }
        }
      }
      
      // Now handle copper elements with more careful temperature handling
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          if(e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) {
            if(temp[y][x] === null){
              newTemp[y][x] = 20; // Default temperature for copper
              continue;
            }
            
            // Get current temperature with safety check
            let oldT = temp[y][x];
            if (isNaN(oldT) || !isFinite(oldT)) {
              oldT = 20; // Reset to default if it's NaN or infinite
              temp[y][x] = oldT; // Fix the original temperature too
            }
            
            // Copper conducts heat more gradually to prevent temperature spikes
            let wSum = 0, tWeight = 0;
            let validNeighbors = 0;
            
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                if(dx === 0 && dy === 0) continue;
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let ne = grid[ny][nx], nt = temp[ny][nx];
                  if(ne !== EMPTY && nt !== null){
                    // Skip invalid temperatures
                    if (isNaN(nt) || !isFinite(nt)) continue;
                    
                    // Skip heat separators
                    if(ne === HEAT_SEPARATOR || ne === CHARGED_HEAT_SEPARATOR || e === CHARGED_DOWN_HEAT_SEPARATOR){
                      continue;
                    }
                    
                    validNeighbors++;
                    let cFactor = 0.5 * conductionRates[ne]; // Reduced factor for copper
                    wSum += cFactor * nt;
                    tWeight += cFactor;
                  }
                }
              }
            }
            
            if(tWeight > 0 && validNeighbors > 0){
              let avg = wSum / tWeight;
              
              // Safety check for the average
              if (isNaN(avg) || !isFinite(avg)) {
                avg = oldT; // Keep the old temperature if calculation is invalid
              }
              
              // For copper, use a much smaller temperature change rate
              let copperDiffusionRate = diffusionRate * 0.2; // 20% of normal diffusion rate
              let delta = copperDiffusionRate * (avg - oldT);
              
              // Limit the maximum temperature change for copper
              delta = Math.max(-5, Math.min(5, delta));
              
              // Calculate new temperature with bounds
              let newT = oldT + delta;
              newTemp[y][x] = Math.max(-273, Math.min(3000, newT)); // Clamp to reasonable range
            }
          }
        }
      }
      
      // Handle burning coal separately
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_COAL || grid[y][x] === BURNING_COAL_LUMP){
            if(temp[y][x] !== null && newTemp[y][x] !== null) {
              let oldT = temp[y][x];
              if (isNaN(oldT) || !isFinite(oldT)) {
                oldT = 20;
                temp[y][x] = oldT;
              }
              
              let delta = newTemp[y][x] - oldT;
              if(delta > 0) newTemp[y][x] = oldT + delta * 0.1;
              if(newTemp[y][x] > 500) newTemp[y][x] = 500;
            }
          }
        }
      }
      temp = newTemp;
    }
    /***************************************
     * REACTIONS & TRANSFORMS
     ***************************************/
    function processTransformations(){
      transformLavaToRock();
      transformWaterAndLavaToStone();
      transformWaterVapor();
      transformCloudToWater();
      transformIceWater();
      transformFireToSmoke();
      transformBurningWood();
      transformWoodIgnition();
      transformBurningLeaves();
      transformSandToGlass();
      transformDirtWetDirt();
      transformSandWetSand();
      transformFlourToDough();
      transformDoughToBread();
      transformBreadToAshIfHot();
      handleSeedsGrowth();
      handleWheatGrowth();
      handleWheatRootGrowth();
      handleRootsAbsorbWater();
      handleFlammables();
      handleOakTreeGrowth();
      handleOakTreeRootGrowth();
      handleBirchTreeGrowth();
      handleBirchTreeRootGrowth();
      handleGrassGrowth();
      igniteHotElements();
      triggerBombs();
      transformGas();
      handleBurningGas();
      transformRoots();
      handleChargedCopper();
      handleElectricalElements();
      handleCoolerHeater();
      handleCloners();
      transformThermite();
      transformGrass();
      handleCellBehavior();
      handleGlassShardCreation();
      
      // Handle new elements
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Handle meat cooking
          if(e === MEAT && temp[y][x] >= doughBakeTemp){
            setCellType(x, y, COOKED_MEAT, 30);
          }
          
          // Handle bird cooking
          if(e === BIRD && temp[y][x] >= doughBakeTemp){
            setCellType(x, y, COOKED_MEAT, 30);
          }
          
          // Handle cobblestone melting
          if(e === COBBLESTONE && temp[y][x] >= 800){
            setCellType(x, y, MOLTEN_SLAG, 1200);
          }
          
          // Handle oil ignition
          if(e === OIL){
            let shouldIgnite = false;
            if(temp[y][x] >= 200) shouldIgnite = true;
            
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              setCellType(x, y, BURNING_GAS, fireTemperature);
              burningGasTime[y][x] = 0;
            }
          }
          
          // Handle Carbon Dioxide transformation
          if(e === CARBON_DIOXIDE){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === WHEAT || ne === GRASS || ne === OAK_LEAVES || 
                   ne === OAK_BABY_LEAVES || ne === BIRCH_LEAVES || 
                   ne === BIRCH_BABY_LEAVES || ne === WHEAT_SEEDS){
                  setCellType(x, y, OXYGEN, 20);
                  break;
                }
              }
            }
          }
          
          // Handle Oxygen reactions
          if(e === OXYGEN){
            let shouldIgnite = false;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            
            // Check for burning elements
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
                // Check for birds (convert to CO2)
                if(ne === BIRD){
                  setCellType(x, y, CARBON_DIOXIDE, 20);
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              setCellType(x, y, FIRE, 500);
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
    // New transformation for Thermite:
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of neighbors){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    function igniteFlammable(x, y){
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      let e = grid[y][x];
      // Oak wood ignites easily
      if(e === WOOD){
        setCellType(x, y, BURNING_WOOD, fireTemperature);
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      // Birch wood has a 50% chance to resist ignition from nearby flames
      else if(e === BIRCH_WOOD){
        if(Math.random() > 0.5) { // 50% chance to resist ignition
          setCellType(x, y, BURNING_WOOD, fireTemperature);
          burningWoodTime[y][x] = 0;
          sparkTimer[y][x] = 0;
        } else {
          // Just heat up the birch wood instead of igniting
          setCellType(x, y, BIRCH_WOOD, Math.min(temp[y][x] + 50, fireTemperature - 50));
        }
      }
      else if(e === FLOUR || e === WHEAT_SEEDS || e === WHEAT){
        setCellType(x, y, BURNING_ORGANIC, fireTemperature);
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      // Oak leaves ignite easily
      else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
        setCellType(x, y, BURNING_LEAVES, fireTemperature);
        sparkTimer[y][x] = 0;
      }
      // Birch leaves have a 60% chance to resist ignition from nearby flames
      else if(e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES){
        if(Math.random() > 0.6) { // 40% chance to ignite
          setCellType(x, y, BURNING_LEAVES, fireTemperature);
          sparkTimer[y][x] = 0;
        } else {
          // Just heat up the birch leaves instead of igniting
          setCellType(x, y, e, Math.min(temp[y][x] + 50, fireTemperature - 50));
        }
      }
      else if(e === GRASS){
        setCellType(x, y, BURNING_ORGANIC, fireTemperature);
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      else if(e === COAL){
        setCellType(x, y, BURNING_COAL, (temp[y][x] < 100 ? 100 : temp[y][x]));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      else if(e === COAL_LUMP){
        setCellType(x, y, BURNING_COAL_LUMP, (temp[y][x] < 100 ? 100 : temp[y][x]));
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      else if(e === SAWDUST){
        // Sawdust burns quickly like wood but with a shorter burn time
        setCellType(x, y, BURNING_ORGANIC, fireTemperature);
        burningWoodTime[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
    }
    function handleBurningGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_GAS){
            burningGasTime[y][x] += simulationTimeStep;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e === GAS){
                  grid[ny][nx] = BURNING_GAS; temp[ny][nx] = fireTemperature; burningGasTime[ny][nx] = 0;
                }
                igniteFlammable(nx, ny);
              }
            }
            if(burningGasTime[y][x] >= burningGasDuration){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); burningGasTime[y][x] = 0;
            }
          }
        }
      }
    }
    function transformGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GAS){
            if(temp[y][x] >= 300){
              grid[y][x] = BURNING_GAS; temp[y][x] = fireTemperature; burningGasTime[y][x] = 0;
            }
            else {
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let e = grid[ny][nx];
                  if(e === FIRE || e === BURNING_WOOD || e === BURNING_ORGANIC || e === BURNING_LEAVES || e === BURNING_ROOT || e === BURNING_GAS){
                    grid[y][x] = BURNING_GAS; temp[y][x] = fireTemperature; burningGasTime[y][x] = 0; break;
                  }
                }
              }
            }
          }
        }
      }
    }
    function handleSeedsGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT_SEEDS){
        let below = grid[y+1][x];
            if(below === DIRT || below === WET_DIRT || below === SAND || below === WET_SAND || below === ROOT){
              seedGrowthTime[y][x] += simulationTimeStep;
              if(seedGrowthTime[y][x] >= 3){
                grid[y][x] = WHEAT; temp[y][x] = 20; wheatHeight[y][x] = 1; wheatMaxHeight[y][x] = 2 + Math.floor(Math.random() * 4);
                // Add color variation to wheat
                const variation = 0.1;
                colorVariations[y][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
              }
            }
          }
        }
      }
    }
    function handleWheatGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            let h = wheatHeight[y][x], mh = wheatMaxHeight[y][x];
            if(h < mh){
              if(Math.random() < 0.01){
                if(y > 0 && grid[y-1][x] === EMPTY){
                  grid[y-1][x] = WHEAT; temp[y-1][x] = 20; wheatHeight[y-1][x] = h + 1; wheatMaxHeight[y-1][x] = mh;
                  // Add color variation to wheat
                  const variation = 0.1;
                  colorVariations[y-1][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                }
              }
            }
          }
        }
      }
    }
    function handleWheatRootGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            for(let depth = 1; depth <= 2; depth++){
              let ny = y + depth;
              if(ny < GRID_SIZE){
                if(grid[ny][x] === EMPTY || grid[ny][x] === DIRT || grid[ny][x] === WET_DIRT || grid[ny][x] === SAND || grid[ny][x] === WET_SAND){
                  if(Math.random() < 0.0005){
                    placeElementAt(x, ny, ROOT);
                  }
                }
                else { break; }
              }
            }
          }
        }
      }
    }
    function handleRootsAbsorbWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT){
            let nb = [[1,0],[-1,0],[0,1],[0,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WET_DIRT){
                  grid[ny][nx] = DIRT; temp[ny][nx] = 20;
                }
                else if(grid[ny][nx] === WET_SAND){
                  grid[ny][nx] = SAND; temp[ny][nx] = 20;
                }
              }
            }
          }
        }
      }
    }
    function handleFlammables(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_ORGANIC){
            sparkTimer[y][x] += simulationTimeStep;
            let sparkLimit = 0.2 + 0.1 * Math.random();
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === EMPTY){
                    grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                    break;
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= 1.0){
              let r = Math.random();
              if(r < burnToAshChance){
                grid[y][x] = ASH; temp[y][x] = 50;
              }
              else {
                grid[y][x] = FIRE; temp[y][x] = fireTemperature; fireLife[y][x] = 0;
              }
            }
          }
          else if(grid[y][x] === BURNING_COAL){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoal){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
          else if(grid[y][x] === BURNING_COAL_LUMP){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoalLump){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
        }
      }
    }
    function handleOakTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_SEEDS){
            // Only check for growing conditions if the seed has something solid below it
            // This allows seeds to fall naturally until they land on something
            if(y === GRID_SIZE - 1 || ![EMPTY, WATER, WATER_VAPOR, CLOUD, FIRE, SMOKE, OIL, ACID, ACID_STEAM, ACID_CLOUD].includes(grid[y+1][x])) {
              // Check if the seed is on suitable ground
              if(y === GRID_SIZE - 1){
                grid[y][x] = DEAD_OAK; temp[y][x] = 20;
              }
              else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
                grid[y][x] = DEAD_OAK; temp[y][x] = 20;
              }
              else {
                oakTreeGrowthTime[y][x] += simulationTimeStep;
                if(oakTreeGrowthTime[y][x] >= 15.0){
                  grid[y][x] = WOOD; temp[y][x] = 20;
                  // Add color variation to wood
                  const variation = 0.05;
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[y][x] = 1;
                  oakTreeMaxHeight[y][x] = 10 + Math.floor(Math.random() * 11);
                  oakTreeRootTimer[y][x] = 0;
                  oakTreeRootDepth[y][x] = 0;
                  oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                  branchLevel[y][x] = 0;
                  branchLen[y][x] = 0;
                  branchDirX[y][x] = 0;
                  branchDirY[y][x] = 0;
                  for(let dy = -1; dy <= 1; dy++){
                    for(let dx = -1; dx <= 1; dx++){
                      let nx = x + dx, ny = y + dy;
                      if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                        grid[ny][nx] = OAK_BABY_LEAVES; temp[ny][nx] = 20;
                        // Add color variation to baby leaves
                        const leafVariation = 0.1;
                        colorVariations[ny][nx] = {
                          r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === WOOD || grid[y-1][x] === OAK_LEAVES || grid[y-1][x] === OAK_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = WOOD; temp[y-1][x] = 20;
                // Add color variation to wood
                const variation = 0.05;
                colorVariations[y-1][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  // Add color variation to branch wood
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  // Add color variation to branch wood
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = OAK_LEAVES; temp[ny][nx] = 20;
                  // Add color variation to side leaves
                  const leafVariation = 0.1;
                  colorVariations[ny][nx] = {
                    r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                  };
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    function handleOakTreeRootGrowth(){
      const oakRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= oakRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    
    function handleBirchTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_SEEDS){
            // Only check for growing conditions if the seed has something solid below it
            // This allows seeds to fall naturally until they land on something
            if(y === GRID_SIZE - 1 || ![EMPTY, WATER, WATER_VAPOR, CLOUD, FIRE, SMOKE, OIL, ACID, ACID_STEAM, ACID_CLOUD].includes(grid[y+1][x])) {
              // Check if the seed is on suitable ground
              if(y === GRID_SIZE - 1){
                grid[y][x] = DEAD_BIRCH; temp[y][x] = 20;
              }
              else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
                grid[y][x] = DEAD_BIRCH; temp[y][x] = 20;
              }
              else {
                oakTreeGrowthTime[y][x] += simulationTimeStep;
                if(oakTreeGrowthTime[y][x] >= 15.0){
                  grid[y][x] = BIRCH_WOOD; temp[y][x] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for dark birch wood (now lighter)
                  if (Math.random() < 0.25) {
                    // Override the base color to be dark gray instead of black
                    colorVariations[y][x] = {
                      r: 0.35 + (Math.random() * 0.1),  // Lighter dark gray
                      g: 0.35 + (Math.random() * 0.1),
                      b: 0.35 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[y][x] = 1;
                  // Birch trees are a bit taller than oak trees
                  oakTreeMaxHeight[y][x] = 12 + Math.floor(Math.random() * 11);
                  oakTreeRootTimer[y][x] = 0;
                  oakTreeRootDepth[y][x] = 0;
                  oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                  branchLevel[y][x] = 0;
                  branchLen[y][x] = 0;
                  branchDirX[y][x] = 0;
                  branchDirY[y][x] = 0;
                  for(let dy = -1; dy <= 1; dy++){
                    for(let dx = -1; dx <= 1; dx++){
                      let nx = x + dx, ny = y + dy;
                      if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                        grid[ny][nx] = BIRCH_BABY_LEAVES; temp[ny][nx] = 20;
                        // Add color variation to leaves
                        const leafVariation = 0.1;
                        colorVariations[ny][nx] = {
                          r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                          b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === BIRCH_WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === BIRCH_WOOD || grid[y-1][x] === BIRCH_LEAVES || grid[y-1][x] === BIRCH_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = BIRCH_WOOD; temp[y-1][x] = 20;
                // Add color variation
                const variation = 0.05;
                colorVariations[y-1][x] = {
                  r: 1 + (Math.random() * variation * 2 - variation),
                  g: 1 + (Math.random() * variation * 2 - variation),
                  b: 1 + (Math.random() * variation * 2 - variation)
                };
                
                // 1/4 chance for dark birch wood (now lighter)
                if (Math.random() < 0.25) {
                  // Override the base color to be dark gray instead of black
                  colorVariations[y-1][x] = {
                    r: 0.35 + (Math.random() * 0.1),  // Lighter dark gray
                    g: 0.35 + (Math.random() * 0.1),
                    b: 0.35 + (Math.random() * 0.1)
                  };
                }
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === BIRCH_LEAVES || grid[by][bx] === BIRCH_BABY_LEAVES)){
                  grid[by][bx] = BIRCH_WOOD; temp[by][bx] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[by][bx] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = BIRCH_LEAVES; temp[ly][lx] = 20;
                      // Add color variation to leaves
                      const leafVariation = 0.1;
                      colorVariations[ly][lx] = {
                        r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                      };
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === BIRCH_LEAVES || grid[by][bx] === BIRCH_BABY_LEAVES)){
                  grid[by][bx] = BIRCH_WOOD; temp[by][bx] = 20;
                  // Add color variation
                  const variation = 0.05;
                  colorVariations[by][bx] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                  
                  // 1/4 chance for black birch wood
                  if (Math.random() < 0.25) {
                    // Override the base color to be black instead of white
                    colorVariations[by][bx] = {
                      r: 0.2 + (Math.random() * 0.1),  // Very dark gray/black
                      g: 0.2 + (Math.random() * 0.1),
                      b: 0.2 + (Math.random() * 0.1)
                    };
                  }
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = BIRCH_LEAVES; temp[ly][lx] = 20;
                      // Add color variation to leaves
                      const leafVariation = 0.1;
                      colorVariations[ly][lx] = {
                        r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                        b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                      };
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = BIRCH_LEAVES; temp[ny][nx] = 20;
                  // Add color variation to leaves
                  const leafVariation = 0.1;
                  colorVariations[ny][nx] = {
                    r: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    g: 1 + (Math.random() * leafVariation * 2 - leafVariation),
                    b: 1 + (Math.random() * leafVariation * 2 - leafVariation)
                  };
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BIRCH_WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    
    function handleBirchTreeRootGrowth(){
      const birchRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BIRCH_WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= birchRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    
    function handleGrassGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GRASS){
            let st = grassStage[y][x];
            if(st === 1){
              if(y > 0 && grid[y-1][x] === EMPTY){
                if(Math.random() < 0.0005){
                  grid[y-1][x] = GRASS; grassStage[y-1][x] = 2; temp[y-1][x] = 20;
                }
              }
            }
            let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
              if(grid[ny][nx] === DIRT || grid[ny][nx] === WET_DIRT){
                let ay = ny - 1;
                if(ay >= 0){
                  if(grid[ay][nx] === EMPTY){
                    if(Math.random() < 0.0003){
                      grid[ny][nx] = GRASS; grassStage[ny][nx] = 1; temp[ny][nx] = 20;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformRoots(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT && temp[y][x] >= 200){
            grid[y][x] = BURNING_ROOT; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
          }
          else if(grid[y][x] === BURNING_ROOT){
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= burnDuration){
              grid[y][x] = DEAD_ROOT; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function igniteHotElements(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let t = temp[y][x];
          if(t !== null){
            let e = grid[y][x];
            // Oak wood ignites at 200Â°C
            if(e === WOOD && t > 200){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Birch wood requires higher temperature (350Â°C) to ignite
            else if(e === BIRCH_WOOD && t > 350){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            else if((e === FLOUR || e === WHEAT_SEEDS || e === WHEAT) && t > 200){
              grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Oak leaves ignite at 200Â°C
            else if((e === OAK_LEAVES || e === OAK_BABY_LEAVES) && t > 200){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            // Birch leaves require higher temperature (300Â°C) to ignite
            else if((e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES) && t > 300){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
          }
        }
      }
    }
    function triggerBombs(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
             grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
        
        if(temp[y][x] >= 200) {
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        
        let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
        for(let [dx, dy] of neighbors){
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
            let e = grid[ny][nx];
            if(e === FIRE || e === BURNING_WOOD || e === BURNING_LEAVES || e === BURNING_ORGANIC || e === BURNING_ROOT || e === BURNING_GAS){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
              break;
            }
          }
        }
      }
    }
  }
}
    function transformLavaToRock(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === LAVA && t < 600){
            if(Math.random() < 0.5){ grid[y][x] = BASALT; temp[y][x] = 500; }
            else { grid[y][x] = OBSIDIAN; temp[y][x] = 500; }
          }
          if(e === BASALT && t >= 800){ grid[y][x] = LAVA; temp[y][x] = 1200; }
          if(e === OBSIDIAN && t >= 700){ grid[y][x] = MOLTEN_SLAG; temp[y][x] = 1200; }
          if(e === MOLTEN_SLAG && t < 800){ grid[y][x] = OBSIDIAN; temp[y][x] = 600; }
        }
      }
    }
    function transformWaterAndLavaToStone(){
      // This function is intentionally left empty to prevent water and lava from turning into stone
      // when they come into contact with each other
      return;
      
      /* Original code (commented out):
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === WATER || e === LAVA){
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if((e === WATER && grid[ny][nx] === LAVA) || (e === LAVA && grid[ny][nx] === WATER)){
                    cpy[y][x] = STONE; temp[y][x] = 20;
                    cpy[ny][nx] = STONE; temp[ny][nx] = 20;
                  }
                }
              }
            }
          }
        }
      }
      */
      grid = cpy;
    }
    function transformWaterVapor(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WATER){
            if(temp[y][x] >= 100){
              grid[y][x] = WATER_VAPOR; temp[y][x] = 120; vaporLife[y][x] = 0;
            }
          }
          else if(grid[y][x] === WATER_VAPOR){
            if(vaporLife[y][x] >= vaporTransformThreshold || vaporLife[y][x] >= 6){
              let count = 0;
              for(let dy = -1; dy <= 1; dy++){
                for(let dx = -1; dx <= 1; dx++){
                  let ny = y + dy, nx = x + dx;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === WATER_VAPOR && vaporLife[ny][nx] >= vaporTransformThreshold){
                      count++;
                    }
                  }
                }
              }
              if(count >= 3 || vaporLife[y][x] >= 6){
                grid[y][x] = CLOUD; temp[y][x] = 50; cloudLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function transformCloudToWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLOUD){
            if(temp[y][x] < 10){ grid[y][x] = WATER; temp[y][x] = 20; }
            else if(cloudLife[y][x] >= cloudMaxLife[y][x]){ grid[y][x] = WATER; temp[y][x] = 20; cloudLife[y][x] = 0; }
          }
        }
      }
    }
    function transformIceWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === WATER && t < 0){ grid[y][x] = ICE; temp[y][x] = -5; }
          else if(e === ICE && t > 2){ grid[y][x] = WATER; temp[y][x] = 5; }
        }
      }
    }
    function transformFireToSmoke(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            if(fireLife[y][x] >= fireLifetime){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random();
            }
            else { temp[y][x] = fireTemperature; }
          }
          else if(grid[y][x] === SMOKE){
            if(smokeLife[y][x] >= smokeMaxLife[y][x]){ eraseCell(x, y); }
          }
        }
      }
    }
    function transformBurningWood(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_WOOD){
            // Check if this was originally birch wood by looking at color variations
            // Birch wood typically has much lighter color variations than oak
            let isBirch = false;
            if (colorVariations[y][x]) {
              // If r, g, and b are all close to 1 or higher, it's likely birch wood
              // Or if it's very dark (black birch variant)
              if ((colorVariations[y][x].r > 0.95 && colorVariations[y][x].g > 0.95 && colorVariations[y][x].b > 0.95) ||
                  (colorVariations[y][x].r < 0.3 && colorVariations[y][x].g < 0.3 && colorVariations[y][x].b < 0.3)) {
                isBirch = true;
              }
            }
            
            // Sparks (fire spreading)
            sparkTimer[y][x] += simulationTimeStep;
            // Birch wood produces sparks less frequently
            let sparkLimit = isBirch ? (0.3 + 0.15 * Math.random()) : (0.2 + 0.1 * Math.random());
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              // Birch wood has less chance to spread fire
              if (!isBirch || Math.random() < 0.7) {
                for(let [dx, dy] of nb){
                  let nx = x + dx, ny = y + dy;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === EMPTY){
                      grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                      break;
                    }
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            
            // Burning duration
            // Birch wood burns 1.5x slower than oak wood
            let burnMultiplier = isBirch ? 0.67 : 1.0; // 1/1.5 = 0.67
            burningWoodTime[y][x] += simulationTimeStep * burnMultiplier;
            
            if(burningWoodTime[y][x] >= burnDuration){
              let r = Math.random();
              // Birch wood is more likely to turn to ash than to fire
              let ashChance = isBirch ? (burnToAshChance * 1.5) : burnToAshChance;
              ashChance = Math.min(ashChance, 0.9); // Cap at 90%
              
              let newElem = (r < ashChance) ? ASH : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 50; }
            }
          }
        }
      }
    }
    function transformWoodIgnition(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                // Oak wood ignites immediately on contact with fire
                if(e === WOOD){
                  grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                }
                // Birch wood has a 40% chance to resist immediate ignition from fire
                if(e === BIRCH_WOOD){
                  if(Math.random() > 0.4) { // 60% chance to ignite
                    grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                  } else {
                    // Just heat up the birch wood instead of igniting
                    temp[ny][nx] = Math.min(temp[ny][nx] + 75, 250);
                  }
                }
                // Oak leaves ignite immediately on contact with fire
                if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
                  grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                }
                // Birch leaves have a 50% chance to resist immediate ignition from fire
                if(e === BIRCH_LEAVES || e === BIRCH_BABY_LEAVES){
                  if(Math.random() > 0.5) { // 50% chance to ignite
                    grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                  } else {
                    // Just heat up the birch leaves instead of igniting
                    temp[ny][nx] = Math.min(temp[ny][nx] + 75, 250);
                  }
                }
                if(e === COAL){
                  grid[ny][nx] = BURNING_COAL; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
                if(e === COAL_LUMP){
                  grid[ny][nx] = BURNING_COAL_LUMP; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
              }
            }
          }
        }
      }
    }
    function transformBurningLeaves(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_LEAVES){
            sparkTimer[y][x] += simulationTimeStep;
            if(sparkTimer[y][x] >= burnDuration){
              let r = Math.random();
              let newElem = (r < 0.5) ? DEAD_PLANT : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 20; }
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let en = grid[ny][nx];
                  if(en === WOOD || en === OAK_LEAVES || en === OAK_BABY_LEAVES){
                    if(en === WOOD){
                      grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                    else {
                      grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformSandToGlass(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND && temp[y][x] >= glassTemp){
            grid[y][x] = GLASS; temp[y][x] = 300;
          }
        }
      }
    }
    function transformDirtWetDirt(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === DIRT){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER || grid[ny][nx] === SALT_WATER){
                  cpy[y][x] = WET_DIRT; temp[y][x] = 20;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
          else if(e === WET_DIRT){
            if(temp[y][x] >= wetDirtEvapTemp){
              cpy[y][x] = DIRT; temp[y][x] = 20;
            }
            else {
              let foundWater = null, foundDirt = null;
              let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WATER) foundWater = [nx, ny];
                  if(grid[ny][nx] === DIRT) foundDirt = [nx, ny];
                }
              }
              if(foundWater && foundDirt){
                let [wx, wy] = foundWater, [dx2, dy2] = foundDirt;
                cpy[dy2][dx2] = WET_DIRT; temp[dy2][dx2] = 20;
                cpy[wy][wx] = EMPTY; temp[wy][wx] = null;
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformSandWetSand(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER || grid[ny][nx] === SALT_WATER){
                  grid[y][x] = WET_SAND; temp[y][x] = 20;
                  break;
                }
              }
            }
          }
          else if(grid[y][x] === WET_SAND){
            if(temp[y][x] >= wetDirtEvapTemp){
              grid[y][x] = SAND; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function transformFlourToDough(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FLOUR){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  cpy[y][x] = DOUGH; temp[y][x] = 25;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformDoughToBread(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === DOUGH && temp[y][x] >= doughBakeTemp){
            grid[y][x] = BREAD; temp[y][x] = 30;
          }
        }
      }
    }
    function transformBreadToAshIfHot(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BREAD && temp[y][x] >= breadBurnTemp){
            grid[y][x] = ASH; temp[y][x] = 50;
          }
        }
      }
    }
    function handleChargedCopper(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              cpy[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
              continue;
            }
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_COPPER;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              grid[y][x] = COPPER; chargedStateTime[y][x] = 0; continue;
            }
            chargedStateTime[y][x] += simulationTimeStep;
            let anyCopper = false;
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){ anyCopper = true; break; }
              }
            }
            if(!anyCopper || chargedStateTime[y][x] >= 1.0){
              grid[y][x] = CHARGED_DOWN_COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
          else if(e === CHARGED_DOWN_COPPER){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){
              grid[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
        }
      }
    }
    function handleElectricalElements(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_HEAT_SEPARATOR){
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === HEAT_SEPARATOR && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_HEAT_SEPARATOR;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_HEAT_SEPARATOR;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = CHARGED_DOWN_HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
          else if(e === CHARGED_DOWN_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
        }
      }
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === INPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let shouldCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_COPPER || grid[ny][nx] === CHARGED_DOWN_COPPER){ shouldCharge = true; break; }
              }
            }
            if(shouldCharge){ cpy[y][x] = CHARGED_INPUT; chargedStateTime[y][x] = 0; }
            else { cpy[y][x] = INPUT; }
          }
        }
      }
      grid = cpy;
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OUTPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let doCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === CHARGED_HEAT_SEPARATOR || ne === CHARGED_DOWN_HEAT_SEPARATOR ||
                   ne === CHARGED_OUTPUT || ne === CHARGED_BLOCKER || ne === NOT_GATE || ne === AND_GATE){
                  doCharge = true; break;
                }
              }
            }
            if(doCharge){ cpy[y][x] = CHARGED_OUTPUT; chargedStateTime[y][x] = chargedStateTime[y][x] || 0; }
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_OUTPUT){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 3.0){
              grid[y][x] = OUTPUT; chargedStateTime[y][x] = 0;
            }
          }
        }
      }
    }
    function handleCoolerHeater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === COOLER || e === HEATER){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let hasChargedInput = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_INPUT){ hasChargedInput = true; break; }
              }
            }
            if(!hasChargedInput) continue;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e2 = grid[ny][nx];
                if(e2 === CHARGED_COPPER || e2 === CHARGED_DOWN_COPPER){
                  if(e === COOLER){ temp[ny][nx] = Math.max(temp[ny][nx] - 100 * simulationTimeStep, -1000); }
                  else { temp[ny][nx] = Math.min(temp[ny][nx] + 100 * simulationTimeStep, 3000); }
                }
              }
            }
          }
        }
      }
    }
    function handleCloners(){
      let replication = [];
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLONER){
            let directions = [[0,-1],[0,1],[-1,0],[1,0]];
            let foundOccupants = [];
            for(let [dx, dy] of directions){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e !== EMPTY && e !== CLONER){
                  foundOccupants.push({ ox: nx, oy: ny });
                }
              }
            }
            if(foundOccupants.length > 0){
              for(let occupant of foundOccupants){
                let ex = occupant.ox, ey = occupant.oy;
                for(let [dx2, dy2] of directions){
                  let rx = x + dx2, ry = y + dy2;
                  if(rx >= 0 && rx < GRID_SIZE && ry >= 0 && ry < GRID_SIZE){
                    if(grid[ry][rx] === EMPTY){
                      replication.push({ srcX: ex, srcY: ey, dstX: rx, dstY: ry });
                    }
                  }
                }
              }
            }
          }
        }
      }
      for(let rep of replication){
        let sX = rep.srcX, sY = rep.srcY;
        let dX = rep.dstX, dY = rep.dstY;
        if(grid[dY][dX] !== EMPTY) continue;
        cloneCell(sX, sY, dX, dY);
      }
    }
    function cloneCell(sx, sy, dx, dy){
      let occupant = grid[sy][sx];
      grid[dy][dx] = occupant;
      temp[dy][dx] = temp[sy][sx];
      if(occupant === WATER_VAPOR){ vaporLife[dy][dx] = vaporLife[sy][sx]; }
      if(occupant === CLOUD){ cloudLife[dy][dx] = cloudLife[sy][sx]; cloudMaxLife[dy][dx] = cloudMaxLife[sy][dx]; }
      if(occupant === FIRE){ fireLife[dy][dx] = fireLife[sy][sx]; }
      if(occupant === SMOKE){ smokeLife[dy][dx] = smokeLife[sy][sx]; smokeMaxLife[dy][dx] = smokeMaxLife[sy][sx]; }
      if(occupant === BURNING_WOOD || occupant === BURNING_ORGANIC || occupant === BURNING_ROOT){ burningWoodTime[dy][dx] = burningWoodTime[sy][sx]; }
      if(occupant === WHEAT_SEEDS){ seedGrowthTime[dy][dx] = seedGrowthTime[sy][sx]; }
      if(occupant === WHEAT){ wheatHeight[dy][dx] = wheatHeight[sy][sx]; wheatMaxHeight[dy][dx] = wheatMaxHeight[sy][sx]; }
      if(occupant === GAS || occupant === BURNING_GAS){ burningGasTime[dy][dx] = burningGasTime[sy][sx]; }
      if(occupant === GRASS){ grassStage[dy][dx] = grassStage[sy][sx]; }
      if(occupant === SPARK){ sparkLife[dy][dx] = sparkLife[sy][sx]; sparkTimer[dy][dx] = sparkTimer[sy][sx]; }
      if(occupant === CHARGED_COPPER || occupant === CHARGED_DOWN_COPPER ||
         occupant === CHARGED_HEAT_SEPARATOR || occupant === CHARGED_DOWN_HEAT_SEPARATOR ||
         occupant === CHARGED_INPUT || occupant === CHARGED_OUTPUT || occupant === CHARGED_BLOCKER){
        chargedStateTime[dy][dx] = chargedStateTime[sy][dx];
      }
    }
    /*******************************************
     * New Elements: Cell, Blood, Glass Shard
     *******************************************/
    function handleCellBehavior() {
      for(let y = GRID_SIZE - 1; y >= 0; y--) {
        for(let x = 0; x < GRID_SIZE; x++) {
          if(grid[y][x] === CELL && !moved[y][x]) {
            // Make Cell fall like a slow-moving powder
            if(Math.random() < 0.3) { // Only move 30% of the time for slow movement
              if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                moveCell(x, y, x, y+1, temp[y][x], CELL);
                continue;
              } else {
                // Try to move diagonally
                let diag = [];
                if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
                if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
                shuffle(diag);
                for(let d of diag) {
                  let nx = x + d, ny = y + 1;
                  if(grid[ny][nx] === EMPTY && !moved[ny][nx]) {
                    moveCell(x, y, nx, ny, temp[y][x], CELL);
                    break;
                  }
                }
              }
            }
            // Cell can die from heat
            if(temp[y][x] > 50) {
              grid[y][x] = DEAD_CELL;
              continue;
            }
            
            // Cell can be killed by fire
            let touchingFire = false;
            let touchingGlassShard = false;
            
            for(let dy = -1; dy <= 1; dy++) {
              for(let dx = -1; dx <= 1; dx++) {
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if(grid[ny][nx] === FIRE) {
                    touchingFire = true;
                  }
                  if(grid[ny][nx] === GLASS_SHARD) {
                    touchingGlassShard = true;
                  }
                }
              }
            }
            
            if(touchingFire) {
              grid[y][x] = DEAD_CELL;
              continue;
            }
            
            // Cell can turn into blood if it touches glass shard
            if(touchingGlassShard && Math.random() < 0.3) {
              grid[y][x] = BLOOD;
              continue;
            }
            
            // Cell can slowly grow into empty spaces or consume edible elements
            if(Math.random() < 0.01) { // Very slow growth rate
              const directions = [
                [0, -1], [1, 0], [0, 1], [-1, 0] // Up, right, down, left
              ];
              
              // Shuffle directions for random growth
              for(let i = directions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [directions[i], directions[j]] = [directions[j], directions[i]];
              }
              
              for(const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  // Grow into empty space
                  if(grid[ny][nx] === EMPTY) {
                    grid[ny][nx] = CELL;
                    temp[ny][nx] = temp[y][x];
                    
                    // Initialize color variation for the new cell
                    const variation = 0.05;
                    colorVariations[ny][nx] = {
                      r: 1 + (Math.random() * variation * 2 - variation),
                      g: 1 + (Math.random() * variation * 2 - variation),
                      b: 1 + (Math.random() * variation * 2 - variation)
                    };
                    break;
                  }
                  
                  // Consume edible elements
                  if(grid[ny][nx] === WATER || 
                     grid[ny][nx] === MEAT || 
                     grid[ny][nx] === COOKED_MEAT || 
                     grid[ny][nx] === BIRD || 
                     grid[ny][nx] === BREAD) {
                    grid[ny][nx] = CELL;
                    temp[ny][nx] = temp[y][x];
                    
                    // Initialize color variation for the new cell
                    const variation = 0.05;
                    colorVariations[ny][nx] = {
                      r: 1 + (Math.random() * variation * 2 - variation),
                      g: 1 + (Math.random() * variation * 2 - variation),
                      b: 1 + (Math.random() * variation * 2 - variation)
                    };
                    break;
                  }
                }
              }
            }
          }
          
          // Blood behavior
          if(grid[y][x] === BLOOD) {
            // Blood can evaporate at high temperatures
            if(temp[y][x] > 100) {
              // Random chance to become oxygen, carbon dioxide, or water vapor
              const rand = Math.random();
              if(rand < 0.33) {
                grid[y][x] = OXYGEN;
              } else if(rand < 0.66) {
                grid[y][x] = CARBON_DIOXIDE;
              } else {
                grid[y][x] = WATER_VAPOR;
              }
            }
          }
          
          // Glass Shard behavior
          if(grid[y][x] === GLASS_SHARD) {
            // Glass shards can kill birds
            for(let dy = -1; dy <= 1; dy++) {
              for(let dx = -1; dx <= 1; dx++) {
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if(grid[ny][nx] === BIRD) {
                    grid[ny][nx] = MEAT;
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    function handleGlassShardCreation() {
      for(let y = 0; y < GRID_SIZE - 1; y++) {
        for(let x = 0; x < GRID_SIZE; x++) {
          if(grid[y][x] === COBBLESTONE && !moved[y][x]) {
            // Check if there's glass below the cobblestone
            if(y+1 < GRID_SIZE && grid[y+1][x] === GLASS) {
              // Break the glass into glass shards
              grid[y+1][x] = GLASS_SHARD;
              temp[y+1][x] = temp[y][x];
              
              // Create additional glass shards in adjacent empty cells
              let directions = [
                [1, 0], [-1, 0], [0, 1], [1, 1], [-1, 1]
              ];
              
              for(let [dx, dy] of directions) {
                let nx = x + dx, ny = y + 1 + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if(grid[ny][nx] === EMPTY && Math.random() < 0.4) {
                    grid[ny][nx] = GLASS_SHARD;
                    temp[ny][nx] = temp[y][x];
                  }
                }
              }
            }
          }
        }
      }
    }
    
    /*******************************************
     * New Transformation: Thermite
     *******************************************/
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of nb){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    /*******************************************
     * CATEGORY / SEARCH FILTERING
     *******************************************/
    categoryButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        categoryButtons.forEach(b => b.classList.remove('selectedCat'));
        btn.classList.add('selectedCat');
        activeCategory = btn.getAttribute('data-category');
        filterTools();
      });
    });
    toolSearch.addEventListener('input', filterTools);
    function filterTools(){
      const searchVal = toolSearch.value.trim().toLowerCase();
      
      Array.from(toolElements).forEach(tool => {
        const toolName = tool.getAttribute('data-tool') || '';
        const cats = (tool.getAttribute('data-cat') || '').toLowerCase().split(',');
        
        // Tools only show in tools tab
        let inCat = (activeCategory === 'all' && !cats.includes('tools')) || cats.includes(activeCategory);
        let inSearch = !searchVal || toolName.toLowerCase().includes(searchVal);
        
        tool.style.display = (inCat && inSearch) ? 'flex' : 'none';
      });
    }
    filterTools();

    // Add acid and slime movement functions
    function moveAcid(x, y, oldT) {
      if (y+1 < GRID_SIZE && [EMPTY, WATER_VAPOR, CLOUD].includes(grid[y+1][x]) && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, ACID);
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, ACID);
            return;
          }
        }
        
        // Destroy adjacent non-cloner elements with updated behavior
        let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dx, dy] of neighbors) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== ACID && 
                grid[ny][nx] !== CLONER && grid[ny][nx] !== ACID_STEAM && 
                grid[ny][nx] !== ACID_CLOUD) {
              if (Math.random() < 0.1) {
                eraseCell(nx, ny);
                // 1/4 chance to delete itself when deleting another element
                if (Math.random() < 0.25) {
                  eraseCell(x, y);
            return;
          }
        }
      }
    }
        }
        
        // Evaporation
        if (temp[y][x] >= 100 && Math.random() < 0.1) {
          grid[y][x] = ACID_STEAM;
          temp[y][x] = 120;
        }
      }
    }

    function moveSlime(x, y, oldT) {
      if (Math.random() < 0.1) { // Very slow movement
        if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, SLIME);
        } else {
          let dirs = [];
          if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
          if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
          shuffle(dirs);
          for (let dir of dirs) {
            let nx = x + dir;
            if (grid[y][nx] === EMPTY && !moved[y][nx]) {
              moveCell(x, y, nx, y, oldT, SLIME);
              return;
            }
          }
        }
      }
    }

    // Add to conductionRates
    conductionRates[ACID] = 0.8;
    conductionRates[ACID_STEAM] = 0.6;
    conductionRates[ACID_CLOUD] = 0.3;
    conductionRates[SLIME] = 0.4;

    // Add to heatCapacities
    heatCapacities[ACID] = 1;
    heatCapacities[ACID_STEAM] = 0.5;
    heatCapacities[ACID_CLOUD] = 0.5;
    heatCapacities[SLIME] = 2;

    function transformGrass() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === GRASS) {
            // Check temperature
            if (temp[y][x] >= 200) {
              grid[y][x] = BURNING_ORGANIC;
              temp[y][x] = fireTemperature;
              burningWoodTime[y][x] = 0;
            }
            // Check for nearby fire
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === FIRE || grid[ny][nx] === BURNING_ORGANIC) {
                  grid[y][x] = BURNING_ORGANIC;
                  temp[y][x] = fireTemperature;
                  burningWoodTime[y][x] = 0;
                  break;
                }
              }
            }
          }
        }
      }
    }

    // HUD toggle functionality
    function updateHudVisibility() {
      const hud = document.getElementById('hud');
      const hudToggle = document.getElementById('hudToggle');
      if (hud && hudToggle) {
        const isVisible = hudToggle.value === '1';
        hud.style.display = isVisible ? 'block' : 'none';
        // Save preference
        localStorage.setItem('hudVisible', isVisible ? '1' : '0');
      }
    }

    // Initialize all event handlers after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize HUD visibility from saved preference
      const savedHudPreference = localStorage.getItem('hudVisible');
      const hudToggle = document.getElementById('hudToggle');
      if (hudToggle) {
        if (savedHudPreference !== null) {
          hudToggle.value = savedHudPreference;
        }
        updateHudVisibility();
        hudToggle.addEventListener('change', updateHudVisibility);
      }
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });

      // Add downloadOfflineBtn event listener here
      const downloadOfflineBtn = document.getElementById('downloadOfflineBtn');
      if (downloadOfflineBtn) {
        downloadOfflineBtn.addEventListener('click', function() {
          const htmlContent = document.documentElement.outerHTML;
          const blob = new Blob([htmlContent], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'sandbox_game.html';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
      }
    });

    // Add to global variables
    let targetFps = 0;
    let popOutWindow = null;

    // Add event handlers
    document.getElementById('downloadOfflineBtn').addEventListener('click', function() {
      const htmlContent = document.documentElement.outerHTML;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sandbox_game.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    document.getElementById('dabyFps').addEventListener('change', function(e) {
      targetFps = parseInt(e.target.value);
    });

    document.getElementById('popOutMode').addEventListener('change', function(e) {
      if (parseInt(e.target.value) === 1) {
        if (!popOutWindow || popOutWindow.closed) {
          popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
          const popOutDoc = popOutWindow.document;
          
          // Create pop-out window content
          popOutDoc.write(`
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { margin: 0; background: #222; overflow: hidden; }
                #popOutGrid { width: 100%; height: 100%; }
              </style>
            </head>
            <body>
              <div id="popOutGrid"></div>
            </body>
            </html>
          `);
          
          // Move grid to pop-out window
          const originalGrid = document.getElementById('grid');
          popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
          
          // Handle window resize
          popOutWindow.addEventListener('resize', function() {
            const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
            originalGrid.style.width = size + 'px';
            originalGrid.style.height = size + 'px';
          });
          
          // Handle window close
          popOutWindow.addEventListener('unload', function() {
            if (!popOutWindow.closed) {
              document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
              originalGrid.style.width = '500px';
              originalGrid.style.height = '500px';
              document.getElementById('popOutMode').value = "0";
            }
          });
        }
      } else {
        if (popOutWindow && !popOutWindow.closed) {
          popOutWindow.close();
        }
      }
    });

    function moveBird(x, y, oldT) {
      if (moved[y][x]) return;
      
      birdTimers[y][x] += simulationTimeStep;
      
      // Change direction randomly
      if (birdTimers[y][x] >= 1.0) {
        if (Math.random() < 0.2) {
          birdDirections[y][x] *= -1;
        }
        if (Math.random() < 0.1) {
          birdYMovement[y][x] = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
        } else {
          birdYMovement[y][x] = 0;
        }
        birdTimers[y][x] = 0;
      }

      // Try to move in current direction
      let nx = x + birdDirections[y][x];
      let ny = y + birdYMovement[y][x];

      // Check boundaries and wrap around if needed
      if (nx < 0) nx = GRID_SIZE - 1;
      if (nx >= GRID_SIZE) nx = 0;
      if (ny < 0 || ny >= GRID_SIZE) {
        ny = y;
        birdYMovement[y][x] = 0;
      }

      // Check for oak leaves to eat
      let foundLeaves = false;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          let checkX = x + dx, checkY = y + dy;
          if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
            if (grid[checkY][checkX] === OAK_LEAVES || grid[checkY][checkX] === OAK_BABY_LEAVES) {
              eraseCell(checkX, checkY);
              foundLeaves = true;
            }
          }
        }
      }

      // Move if possible
      if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
        moveCell(x, y, nx, ny, oldT, BIRD);
        birdDirections[ny][nx] = birdDirections[y][x];
        birdTimers[ny][nx] = birdTimers[y][x];
        birdYMovement[ny][nx] = birdYMovement[y][x];
      }
    }

    function moveOil(x, y, oldT){
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, OIL);
      }
      else if(y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]){
        // Oil floats on water
        let tempWater = temp[y+1][x];
        grid[y+1][x] = OIL;
        temp[y+1][x] = oldT;
        grid[y][x] = WATER;
        temp[y][x] = tempWater;
        moved[y+1][x] = true;
      }
      else{
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let d of dirs){
          let nx = x + d, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, OIL);
            break;
          }
        }
      }
    }
    
    function moveBlood(x, y, oldT){
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, BLOOD);
      }
      else if(y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]){
        // Blood sinks below water
        let tempWater = temp[y+1][x];
        grid[y+1][x] = BLOOD;
        temp[y+1][x] = oldT;
        grid[y][x] = WATER;
        temp[y][x] = tempWater;
        moved[y+1][x] = true;
      }
      else if(y+1 < GRID_SIZE && grid[y+1][x] === SLIME && !moved[y+1][x]){
        // Blood floats on slime
        let tempSlime = temp[y+1][x];
        grid[y+1][x] = BLOOD;
        temp[y+1][x] = oldT;
        grid[y][x] = SLIME;
        temp[y][x] = tempSlime;
        moved[y+1][x] = true;
      }
      else{
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let d of dirs){
          let nx = x + d, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, BLOOD);
            break;
          }
        }
      }
    }

    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('auxclick', e => {
      if (e.button === 1) { // Middle click
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const element = grid[y][x];
        if (element === EMPTY) return;

        // Find the tool element for this element
        const tools = Array.from(toolElements);
        for (const tool of tools) {
          if (getToolElementId(tool.getAttribute('data-tool')) === element) {
            // Select the tool
            selectTool(tool);
            
            // Find its category
            const category = tool.getAttribute('data-cat');
            if (category) {
              // Select the category
              const categoryButtons = document.querySelectorAll('#categoryMenu button');
              categoryButtons.forEach(btn => {
                if (btn.getAttribute('data-category') === category) {
                  btn.click();
                  
                  // Wait for DOM update then scroll tool into view
                  setTimeout(() => {
                    tool.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }, 100);
                }
              });
            }
            break;
          }
        }
      }
    });

    // Helper function to get element ID from tool name
    function getToolElementId(toolName) {
      switch(toolName) {
        case "eraser": return ERASER;
        case "sand": return SAND;
        case "wall": return WALL;
        case "water": return WATER;
        case "lava": return LAVA;
        case "stone": return STONE;
        case "water-vapor": return WATER_VAPOR;
        case "copper": return COPPER;
        case "steel": return STEEL;
        case "ice": return ICE;
        case "wood": return WOOD;
        case "fire": return FIRE;
        case "smoke": return SMOKE;
        case "ash": return ASH;
        case "glass": return GLASS;
        case "bomb": return BOMB;
        case "dirt": return DIRT;
        case "wet-dirt": return WET_DIRT;
        case "wheat-seeds": return WHEAT_SEEDS;
        case "flour": return FLOUR;
        case "dough": return DOUGH;
        case "bread": return BREAD;
        case "plant-root": return ROOT;
        case "spark": return SPARK;
        case "oak-seeds": return OAK_SEEDS;
        case "grass": return GRASS;
        case "gas": return GAS;
        case "cooler": return COOLER;
        case "heater": return HEATER;
        case "heat-separator": return HEAT_SEPARATOR;
        case "input": return INPUT;
        case "output": return OUTPUT;
        case "not-gate": return NOT_GATE;
        case "and-gate": return AND_GATE;
        case "blocker": return BLOCKER;
        case "cloner": return CLONER;
        case "coal": return COAL;
        case "coal-lump": return COAL_LUMP;
        case "thermite": return THERMITE;
        case "acid": return ACID;
        case "slime": return SLIME;
        case "carbon-dioxide": return CARBON_DIOXIDE;
        case "oxygen": return OXYGEN;
        case "bird": return BIRD;
        case "meat": return MEAT;
        case "cooked-meat": return COOKED_MEAT;
        case "cobblestone": return COBBLESTONE;
        case "oil": return OIL;
        case "example-element": return EXAMPLE_ELEMENT;
        case "big-bomb": return BIG_BOMB;
        case "water-bomb": return WATER_BOMB;
        case "fire-bomb": return FIRE_BOMB;
        case "cryo-bomb": return CRYO_BOMB;
        case "nuke-bomb": return NUKE_BOMB;
        case "salt": return SALT;
        case "salt-water": return SALT_WATER;
        default: return null;
      }
    }

    // Add touch support
    let lastTouchX = null;
    let lastTouchY = null;
    let touchStartTime = 0;
    let isTouchActive = false;

    gridContainer.addEventListener('touchstart', function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      lastTouchX = x;
      lastTouchY = y;
      hoveredX = x;
      hoveredY = y;
      touchStartTime = Date.now();
      isTouchActive = true;
      isLeftMouseDown = true;
      spamPlace();
      updateHoverOverlay();
    });

    gridContainer.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!isTouchActive) return;
      
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      
      // Only update if position changed
      if (x !== lastTouchX || y !== lastTouchY) {
        hoveredX = x;
        hoveredY = y;
        lastTouchX = x;
        lastTouchY = y;
        spamPlace();
        updateHoverOverlay();
        
        // Update HUD
        if (temp[y][x] !== null) {
          hudTemp.textContent = `Temp: ${temp[y][x].toFixed(1)} Â°C`;
          hudElem.textContent = `Element: ${getElementName(grid[y][x])}`;
        }
      }
    });

    gridContainer.addEventListener('touchend', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    gridContainer.addEventListener('touchcancel', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- Â°C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    // Update getMousePos to better handle touch events
    function getMousePos(e) {
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let clientX = e.clientX || e.touches[0].clientX;
      let clientY = e.clientY || e.touches[0].clientY;
      let px = Math.floor((clientX - rect.left) / cellSize);
      let py = Math.floor((clientY - rect.top) / cellSize);
      return { 
        x: Math.max(0, Math.min(GRID_SIZE - 1, px)), 
        y: Math.max(0, Math.min(GRID_SIZE - 1, py)) 
      };
    }

    // Initialize dynamic lighting system
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // Add light-emitting properties for elements
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };

    // Add lighting calculation function
    function calculateLighting() {
      if (!window.isDynamicLightingEnabled) return;
      
      // Reset light levels
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          window.lightLevels[y][x] = 0;
          window.lightColors[y][x] = null;
        }
      }

      // Calculate light emission
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          const emitter = window.lightEmitters[element];
          
          if (emitter) {
            // Spread light in a radius
            const radius = Math.floor(emitter.intensity * 5);
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  if (distance <= radius) {
                    const intensity = (1 - distance / radius) * emitter.intensity;
                    window.lightLevels[ny][nx] = Math.max(window.lightLevels[ny][nx], intensity);
                    if (!window.lightColors[ny][nx]) window.lightColors[ny][nx] = emitter.color;
                    else {
                      // Mix colors based on intensity
                      const currentColor = window.lightColors[ny][nx];
                      const r1 = parseInt(currentColor.slice(1, 3), 16);
                      const g1 = parseInt(currentColor.slice(3, 5), 16);
                      const b1 = parseInt(currentColor.slice(5, 7), 16);
                      const r2 = parseInt(emitter.color.slice(1, 3), 16);
                      const g2 = parseInt(emitter.color.slice(3, 5), 16);
                      const b2 = parseInt(emitter.color.slice(5, 7), 16);
                      const mix = intensity / (window.lightLevels[ny][nx] + intensity);
                      const r = Math.round(r1 * (1 - mix) + r2 * mix);
                      const g = Math.round(g1 * (1 - mix) + g2 * mix);
                      const b = Math.round(b1 * (1 - mix) + b2 * mix);
                      window.lightColors[ny][nx] = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Modify renderCell to include lighting
    const originalRenderCell = window.renderCell;
    window.renderCell = function(x, y) {
      originalRenderCell(x, y);
      const cell = cells[y][x];
      
      if (window.isDynamicLightingEnabled && window.lightLevels[y][x] > 0) {
        cell.classList.add('lit');
        const element = grid[y][x];
        
        if (element === GLASS) {
          // Glass reflects nearby light with a slight tint
          const color = window.lightColors[y][x];
          const intensity = window.lightLevels[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = intensity * 0.3;
        } else if (element === EMPTY) {
          // Empty cells show light more prominently
          const color = window.lightColors[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = window.lightLevels[y][x] * 0.2;
        } else {
          // Other cells get a slight glow effect
          const lightColor = window.lightColors[y][x];
          if (lightColor) {
            cell.style.boxShadow = `0 0 ${window.lightLevels[y][x] * 10}px ${lightColor}`;
          }
        }
      } else {
        cell.classList.remove('lit');
        cell.style.boxShadow = '';
      }
    };

    // Add lighting calculation to game loop
    const originalGameLoop = window.gameLoop;
    window.gameLoop = function(timestamp) {
      if (window.isDynamicLightingEnabled) {
        calculateLighting();
      }
      originalGameLoop(timestamp);
    };

    // Initialize dynamic lighting toggle
    function initializeDynamicLighting() {
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.addEventListener('change', function(e) {
          window.isDynamicLightingEnabled = parseInt(e.target.value) === 1;
          alert('Dynamic Lighting ' + (window.isDynamicLightingEnabled ? 'Enabled' : 'Disabled')); // Immediate feedback
          
          if (!window.isDynamicLightingEnabled) {
            // Clear all lighting effects
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                const cell = cells[y][x];
                cell.classList.remove('lit');
                cell.style.boxShadow = '';
                if (grid[y][x] === EMPTY) {
                  cell.style.backgroundColor = '';
                  cell.style.opacity = '';
                }
              }
            }
          }
        });
      }
    }

    // Call initialization when document is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeDynamicLighting);
    } else {
      initializeDynamicLighting();
    }

    // Add to applyOptionsButton click handler
    document.getElementById('applyOptionsButton').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('stageSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        initGrid(newSize);
        // Only reinitialize lighting arrays if size changed
        window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      }
      optionsModal.style.display = 'none';
    });

    // Handle grid size change
    document.getElementById('applyGridSize').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('gridSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        GRID_SIZE = newSize;
        initGrid();
        
        // Reinitialize DSPLE if it's enabled
        if (window.isDspleEnabled) {
          // Clean up existing lighting engine
          cleanupDspleLightingEngine();
          // Reinitialize with new grid size
          initDspleLightingEngine();
        }
        
        renderGrid();
      }
    });

    // Community Feature Implementation
    const SERVER_URL = 'http://localhost:8700';
    let communityUserData = null;
    let loginAttempts = 0;
    let selectedLocalSave = null;
    let communitySaves = [];
    
    // Initialize Community elements after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize Community Modal
      const communityModal = document.getElementById('communityModal');
      const communityButton = document.getElementById('communityButton');
      const closeCommunityModal = document.getElementById('closeCommunityModal');
      
      if (!communityButton || !communityModal) {
        console.error('Community elements not found');
        return;
      }
      
      // Community sections
      const communityLoginSection = document.getElementById('communityLoginSection');
      const communityContent = document.getElementById('communityContent');
    
      // Login/Register elements
      const communityUsername = document.getElementById('communityUsername');
      const communityEmail = document.getElementById('communityEmail');
      const communityPassword = document.getElementById('communityPassword');
      const communityLoginBtn = document.getElementById('communityLoginBtn');
      const communityRegisterBtn = document.getElementById('communityRegisterBtn');
      const communityLoginMessage = document.getElementById('communityLoginMessage');
      
      // Community content tabs
      const communityTabBtns = document.querySelectorAll('.community-tab-btn');
      const communityTabContents = document.querySelectorAll('.community-tab-content');
      
      // Community saves list and filters
      const communitySavesList = document.getElementById('communitySavesList');
      const communitySortFilter = document.getElementById('communitySortFilter');
      const communitySearchFilter = document.getElementById('communitySearchFilter');
      
      // Upload section
      const communityLocalSavesList = document.getElementById('communityLocalSavesList');
      const communityUploadTitle = document.getElementById('communityUploadTitle');
      const communityUploadDescription = document.getElementById('communityUploadDescription');
      const communityUploadBtn = document.getElementById('communityUploadBtn');
      const communityUploadMessage = document.getElementById('communityUploadMessage');
    
    // Open Community Modal
      communityButton.addEventListener('click', function() {
        communityModal.style.display = 'block';
        
        // If user is logged in, load community saves
        if (communityUserData) {
          loadCommunitySaves();
          loadLocalSaves();
        }
      });
      
      // Close Community Modal
      closeCommunityModal.addEventListener('click', function() {
        communityModal.style.display = 'none';
      });
      
      // Tab switching
      communityTabBtns.forEach(btn => {
        btn.addEventListener('click', function() {
          const tabName = this.getAttribute('data-tab');
          
          // Update active tab button
          communityTabBtns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          
          // Show selected tab content
          communityTabContents.forEach(content => {
            content.classList.remove('active');
            if (content.id === tabName + 'CommunityTab') {
              content.classList.add('active');
            }
          });
          
          // Load data for the selected tab
          if (tabName === 'browse') {
            loadCommunitySaves();
          } else if (tabName === 'upload') {
            loadLocalSaves();
          }
        });
      });
      
      // Login functionality
      communityLoginBtn.addEventListener('click', function() {
      const username = communityUsername.value.trim();
      const email = communityEmail.value.trim();
      const password = communityPassword.value;
      
      if (!username || !email) {
        showLoginMessage('Please enter both username and email', 'error');
        return;
      }
      
      // Check login attempts
      if (loginAttempts >= 5) {
        showLoginMessage('Too many login attempts. Please try again later.', 'error');
        return;
      }
      
      loginAttempts++;
      
      // Simulate login for now (would be replaced with actual server call)
      loginUser(username, email, password)
        .then(response => {
          if (response.success) {
            communityUserData = response.userData;
            showLoginMessage('Login successful!', 'success');
            
            // Show community content
            communityLoginSection.style.display = 'none';
            communityContent.style.display = 'block';
            
            // Load community saves
            loadCommunitySaves();
          } else {
            showLoginMessage(response.message || 'Login failed. Please check your credentials.', 'error');
          }
        })
        .catch(error => {
          showLoginMessage('Error connecting to server. Please try again later.', 'error');
          console.error('Login error:', error);
        });
    });
    
    // Register functionality
    communityRegisterBtn.addEventListener('click', function() {
      const username = communityUsername.value.trim();
      const email = communityEmail.value.trim();
      const password = communityPassword.value;
      
      if (!username || !email) {
        showLoginMessage('Please enter both username and email', 'error');
        return;
      }
      
      // Simulate registration for now (would be replaced with actual server call)
      registerUser(username, email, password)
        .then(response => {
          if (response.success) {
            communityUserData = response.userData;
            showLoginMessage('Registration successful! You are now logged in.', 'success');
            
            // Show community content
            communityLoginSection.style.display = 'none';
            communityContent.style.display = 'block';
            
            // Load community saves
            loadCommunitySaves();
          } else {
            showLoginMessage(response.message || 'Registration failed. Please try again.', 'error');
          }
        })
        .catch(error => {
          showLoginMessage('Error connecting to server. Please try again later.', 'error');
          console.error('Registration error:', error);
        });
    });
    
    // Filter and sort community saves
    communitySortFilter.addEventListener('change', function() {
      filterAndSortCommunitySaves();
    });
    
    communitySearchFilter.addEventListener('input', function() {
      filterAndSortCommunitySaves();
    });
    
    // Upload save functionality
    communityUploadBtn.addEventListener('click', function() {
      const title = communityUploadTitle.value.trim();
      const description = communityUploadDescription.value.trim();
      
      if (!title) {
        communityUploadMessage.textContent = 'Please enter a title for your save';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      if (!selectedLocalSave) {
        communityUploadMessage.textContent = 'Please select a save to upload';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      // Get the save data
      const saveData = localStorage.getItem(selectedLocalSave);
      if (!saveData) {
        communityUploadMessage.textContent = 'Error retrieving save data';
        communityUploadMessage.className = 'message error';
        return;
      }
      
      // Upload the save
      uploadSave(title, description, saveData)
        .then(response => {
          if (response.success) {
            communityUploadMessage.textContent = 'Save uploaded successfully!';
            communityUploadMessage.className = 'message success';
            
            // Clear form
            communityUploadTitle.value = '';
            communityUploadDescription.value = '';
            selectedLocalSave = null;
            
            // Update local saves list
            loadLocalSaves();
            
            // Switch to browse tab
            document.querySelector('.community-tab-btn[data-tab="browse"]').click();
          } else {
            communityUploadMessage.textContent = response.message || 'Upload failed. Please try again.';
            communityUploadMessage.className = 'message error';
          }
        })
        .catch(error => {
          communityUploadMessage.textContent = 'Error connecting to server. Please try again later.';
          communityUploadMessage.className = 'message error';
          console.error('Upload error:', error);
        });
    });
    
    // Helper Functions
    
    // Community saves functionality
    function updateCommunitySavesList() {
      const container = document.getElementById('communitySavesList');
      container.innerHTML = '<div class="loading">Loading community saves...</div>';
      
      // Fetch the list of community saves from the ./communitysaves directory
      fetchCommunitySaves()
        .then(saves => {
          container.innerHTML = '';
          
          if (saves.length === 0) {
            container.innerHTML = '<div class="no-saves">No community saves found.</div>';
            return;
          }
          
          // Sort saves by date (newest first)
          saves.sort((a, b) => b.timestamp - a.timestamp);
          
          // Create a card for each community save
          saves.forEach(save => {
            // Create a card for each saved game
            const card = document.createElement('div');
            card.className = 'save-game-card';
            
            // Create the preview section
            const previewContainer = document.createElement('div');
            previewContainer.className = 'save-preview';
            
            // Create the actual preview grid
            const previewGrid = document.createElement('div');
            previewGrid.className = 'preview-grid';
            
            // Try to load the save data to create a preview
            try {
              // Parse the save data
              const saveData = save.saveData;
              const previewSize = 10; // Small preview grid
              
              // Create a miniature grid for preview
              for (let y = 0; y < previewSize; y++) {
                for (let x = 0; x < previewSize; x++) {
                  const cell = document.createElement('div');
                  cell.className = 'preview-cell';
                  
                  // Sample from the actual grid to create preview
                  const gridX = Math.floor(x * (saveData.GRID_SIZE / previewSize));
                  const gridY = Math.floor(y * (saveData.GRID_SIZE / previewSize));
                  
                  if (saveData.grid && saveData.grid[gridY] && saveData.grid[gridY][gridX] !== undefined) {
                    const element = saveData.grid[gridY][gridX];
                    if (element !== 0) { // Not empty
                      // Get the class name for this element
                      const elementClass = getElementClass(element);
                      if (elementClass) {
                        cell.classList.add(elementClass);
                      }
                    }
                  }
                  
                  previewGrid.appendChild(cell);
                }
              }
              
              previewContainer.appendChild(previewGrid);
            } catch (err) {
              console.error('Error creating preview:', err);
              previewContainer.innerHTML = '<div class="preview-error">Preview not available</div>';
            }
            
            // Create the info section
            const infoContainer = document.createElement('div');
            infoContainer.className = 'save-info';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'save-title';
            title.textContent = save.title || 'Untitled Save';
            infoContainer.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'save-description';
            description.textContent = save.description || 'No description';
            infoContainer.appendChild(description);
            
            // Add metadata (publisher and date)
            const metadata = document.createElement('div');
            metadata.className = 'save-metadata';
            
            // Add publisher
            const publisher = document.createElement('div');
            publisher.className = 'save-publisher';
            publisher.textContent = `Publisher: ${save.publisher || 'Unknown'}`;
            metadata.appendChild(publisher);
            
            // Add date
            const date = document.createElement('div');
            date.className = 'save-date';
            date.textContent = `Date: ${new Date(save.timestamp).toLocaleDateString()}`;
            metadata.appendChild(date);
            
            // Add file size
            const size = document.createElement('div');
            size.className = 'save-size';
            size.textContent = `Size: ${formatFileSize(save.size)}`;
            metadata.appendChild(size);
            
            infoContainer.appendChild(metadata);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.className = 'load-save-button';
            loadButton.textContent = 'Load';
            loadButton.addEventListener('click', function() {
              loadCommunitySave(save.filename);
              communityModal.style.display = 'none';
            });
            infoContainer.appendChild(loadButton);
            
            // Assemble the card
            card.appendChild(previewContainer);
            card.appendChild(infoContainer);
            
            // Add the card to the container
            container.appendChild(card);
          });
        })
        .catch(error => {
          console.error('Error loading community saves:', error);
          container.innerHTML = `<div class="error">Error loading community saves: ${error.message}</div>`;
        });
    }
    
    // Function to fetch community saves from the ./communitysaves directory
    window.fetchCommunitySaves = async function() {
      // In a real implementation, this would fetch from the server or local directory
      // For now, we'll simulate reading from a directory
      
      try {
        // Simulate reading from the ./communitysaves directory
        // In a real implementation, this would use fetch or another method to get the files
        const response = await fetch('./communitysaves/index.json');
        
        // If the directory doesn't exist or there's an error, return an empty array
        if (!response.ok) {
          return [];
        }
        
        // Parse the index file that contains metadata about all community saves
        const index = await response.json();
        
        // For each save in the index, fetch the actual save data
        const saves = await Promise.all(index.map(async (save) => {
          try {
            const saveResponse = await fetch(`./communitysaves/${save.filename}`);
            if (!saveResponse.ok) {
              throw new Error(`Failed to load save: ${save.filename}`);
            }
            
            const saveData = await saveResponse.json();
            
            return {
              ...save,
              saveData
            };
          } catch (error) {
            console.error(`Error loading save ${save.filename}:`, error);
            return save; // Return just the metadata if we can't load the save data
          }
        }));
        
        return saves;
      } catch (error) {
        console.error('Error fetching community saves:', error);
        
        // For demo purposes, return some sample saves if we can't fetch the real ones
        return getSampleCommunitySaves();
      }
    }
    
    // Function to load a community save
    window.loadCommunitySave = function(filename) {
      // In a real implementation, this would fetch the save file from the server or local directory
      // For now, we'll simulate loading from a file
      
      fetch(`./communitysaves/${filename}`)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to load save: ${filename}`);
          }
          return response.json();
        })
        .then(save => {
          // Load the save data into the game
          loadSaveData(save);
        })
        .catch(error => {
          console.error('Error loading community save:', error);
          alert(`Error loading community save: ${error.message}`);
          
          // For demo purposes, load a sample save if we can't load the real one
          const sampleSaves = getSampleCommunitySaves();
          if (sampleSaves.length > 0) {
            loadSaveData(sampleSaves[0].saveData);
          }
        });
    }
    
    // Function to update the community saves list in the UI
    window.updateCommunitySavesList = function() {
      const container = document.getElementById('communitySavesList');
      container.innerHTML = '<div class="loading">Loading community saves...</div>';
      
      // Fetch the list of community saves from the ./communitysaves directory
      fetchCommunitySaves()
        .then(saves => {
          container.innerHTML = '';
          
          if (saves.length === 0) {
            container.innerHTML = '<div class="no-saves">No community saves found.</div>';
            return;
          }
          
          // Sort saves by date (newest first)
          saves.sort((a, b) => b.timestamp - a.timestamp);
          
          // Create a card for each community save
          saves.forEach(save => {
            // Create a card for each saved game
            const card = document.createElement('div');
            card.className = 'save-game-card';
            
            // Create the preview section
            const previewContainer = document.createElement('div');
            previewContainer.className = 'save-preview';
            
            // Create the actual preview grid
            const previewGrid = document.createElement('div');
            previewGrid.className = 'preview-grid';
            
            // Try to load the save data to create a preview
            try {
              // Parse the save data
              const saveData = save.saveData;
              const previewSize = 10; // Small preview grid
              
              // Create a miniature grid for preview
              for (let y = 0; y < previewSize; y++) {
                for (let x = 0; x < previewSize; x++) {
                  const cell = document.createElement('div');
                  cell.className = 'preview-cell';
                  
                  // Sample from the actual grid to create preview
                  const gridX = Math.floor(x * (saveData.GRID_SIZE / previewSize));
                  const gridY = Math.floor(y * (saveData.GRID_SIZE / previewSize));
                  
                  if (saveData.grid && saveData.grid[gridY] && saveData.grid[gridY][gridX] !== undefined) {
                    const element = saveData.grid[gridY][gridX];
                    if (element !== 0) { // Not empty
                      // Get the class name for this element
                      const elementClass = getElementClass(element);
                      if (elementClass) {
                        cell.classList.add(elementClass);
                      }
                    }
                  }
                  
                  previewGrid.appendChild(cell);
                }
              }
              
              previewContainer.appendChild(previewGrid);
            } catch (err) {
              console.error('Error creating preview:', err);
              previewContainer.innerHTML = '<div class="preview-error">Preview not available</div>';
            }
            
            // Create the info section
            const infoContainer = document.createElement('div');
            infoContainer.className = 'save-info';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'save-title';
            title.textContent = save.title || 'Untitled Save';
            infoContainer.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'save-description';
            description.textContent = save.description || 'No description';
            infoContainer.appendChild(description);
            
            // Add metadata (publisher and date)
            const metadata = document.createElement('div');
            metadata.className = 'save-metadata';
            
            // Add publisher
            const publisher = document.createElement('div');
            publisher.className = 'save-publisher';
            publisher.textContent = `Publisher: ${save.publisher || 'Unknown'}`;
            metadata.appendChild(publisher);
            
            // Add date
            const date = document.createElement('div');
            date.className = 'save-date';
            date.textContent = `Date: ${new Date(save.timestamp).toLocaleDateString()}`;
            metadata.appendChild(date);
            
            // Add file size
            const size = document.createElement('div');
            size.className = 'save-size';
            size.textContent = `Size: ${formatFileSize(save.size)}`;
            metadata.appendChild(size);
            
            infoContainer.appendChild(metadata);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.className = 'load-save-button';
            loadButton.textContent = 'Load';
            loadButton.addEventListener('click', function() {
              loadCommunitySave(save.filename);
              communityModal.style.display = 'none';
            });
            infoContainer.appendChild(loadButton);
            
            // Assemble the card
            card.appendChild(previewContainer);
            card.appendChild(infoContainer);
            
            // Add the card to the container
            container.appendChild(card);
          });
        })
        .catch(error => {
          console.error('Error loading community saves:', error);
          container.innerHTML = `<div class="error">Error loading community saves: ${error.message}</div>`;
        });
    }
    
    // Helper function to format file size
    function formatFileSize(bytes) {
      if (bytes < 1024) {
        return bytes + ' B';
      } else if (bytes < 1024 * 1024) {
        return (bytes / 1024).toFixed(1) + ' KB';
      } else {
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }
    }
    
    // Helper function to get sample community saves for demo purposes
    window.getSampleCommunitySaves = function() {
      // Create some sample saves for demonstration
      return [
        {
          filename: 'sample1.dbr',
          title: 'Desert Oasis',
          description: 'A beautiful desert oasis with water and plants',
          publisher: 'SandboxMaster',
          timestamp: Date.now() - 86400000 * 3, // 3 days ago
          size: 15240,
          saveData: createSampleSaveData(50, 'desert')
        },
        {
          filename: 'sample2.dbr',
          title: 'Volcano Eruption',
          description: 'Watch out for the lava!',
          publisher: 'LavaLover',
          timestamp: Date.now() - 86400000 * 7, // 7 days ago
          size: 18360,
          saveData: createSampleSaveData(50, 'volcano')
        },
        {
          filename: 'sample3.dbr',
          title: 'Underwater City',
          description: 'A city built entirely underwater',
          publisher: 'NeptuneKing',
          timestamp: Date.now() - 86400000 * 14, // 14 days ago
          size: 22480,
          saveData: createSampleSaveData(50, 'underwater')
        }
      ];
    }
    
    // Helper function to create sample save data for demo purposes
    window.createSampleSaveData = function(size, theme) {
      // Create a basic grid with the specified theme
      const grid = Array(size).fill().map(() => Array(size).fill(0));
      const temp = Array(size).fill().map(() => Array(size).fill(20));
      const colorVariations = Array(size).fill().map(() => Array(size).fill(null));
      
      // Fill the grid based on the theme
      if (theme === 'desert') {
        // Create a desert landscape with sand and a small oasis
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (y > size / 2) {
              grid[y][x] = 4; // Sand
              temp[y][x] = 30; // Hot temperature
            }
          }
        }
        
        // Add an oasis in the center
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        const oasisRadius = Math.floor(size / 10);
        
        for (let y = centerY - oasisRadius; y <= centerY + oasisRadius; y++) {
          for (let x = centerX - oasisRadius; x <= centerX + oasisRadius; x++) {
            if (y >= 0 && y < size && x >= 0 && x < size) {
              const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
              if (distance < oasisRadius) {
                grid[y][x] = 2; // Water
                temp[y][x] = 20; // Normal temperature
              }
            }
          }
        }
      } else if (theme === 'volcano') {
        // Create a volcano landscape with stone and lava
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (y > size / 2) {
              grid[y][x] = 5; // Stone
              temp[y][x] = 20; // Normal temperature
            }
          }
        }
        
        // Add a volcano in the center
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        const volcanoRadius = Math.floor(size / 8);
        
        for (let y = centerY - volcanoRadius; y <= centerY + volcanoRadius; y++) {
          for (let x = centerX - volcanoRadius; x <= centerX + volcanoRadius; x++) {
            if (y >= 0 && y < size && x >= 0 && x < size) {
              const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
              if (distance < volcanoRadius) {
                grid[y][x] = 3; // Lava
                temp[y][x] = 1200; // Very hot temperature
              }
            }
          }
        }
      } else if (theme === 'underwater') {
        // Create an underwater landscape with water and some structures
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            grid[y][x] = 2; // Water
            temp[y][x] = 10; // Cold temperature
          }
        }
        
        // Add some underwater structures
        for (let i = 0; i < 5; i++) {
          const structX = Math.floor(Math.random() * size);
          const structY = Math.floor(Math.random() * size);
          const structSize = Math.floor(Math.random() * 5) + 3;
          
          for (let y = structY - structSize; y <= structY + structSize; y++) {
            for (let x = structX - structSize; x <= structX + structSize; x++) {
              if (y >= 0 && y < size && x >= 0 && x < size) {
                const distance = Math.sqrt(Math.pow(x - structX, 2) + Math.pow(y - structY, 2));
                if (distance < structSize) {
                  grid[y][x] = 5; // Stone
                  temp[y][x] = 10; // Cold temperature
                }
              }
            }
          }
        }
      }
      
      // Return the sample save data
      return {
        GRID_SIZE: size,
        grid,
        temp,
        colorVariations,
        // Add other necessary properties with default values
        vaporLife: Array(size).fill().map(() => Array(size).fill(0)),
        cloudLife: Array(size).fill().map(() => Array(size).fill(0)),
        fireLife: Array(size).fill().map(() => Array(size).fill(0)),
        smokeLife: Array(size).fill().map(() => Array(size).fill(0)),
        burningWoodTime: Array(size).fill().map(() => Array(size).fill(0)),
        wheatHeight: Array(size).fill().map(() => Array(size).fill(0)),
        wheatMaxHeight: Array(size).fill().map(() => Array(size).fill(3)),
        seedGrowthTime: Array(size).fill().map(() => Array(size).fill(0)),
        rootLife: Array(size).fill().map(() => Array(size).fill(0)),
        sparkLife: Array(size).fill().map(() => Array(size).fill(0)),
        sparkTimer: Array(size).fill().map(() => Array(size).fill(0)),
        smokeMaxLife: Array(size).fill().map(() => Array(size).fill(30)),
        cloudMaxLife: Array(size).fill().map(() => Array(size).fill(100)),
        branchLevel: Array(size).fill().map(() => Array(size).fill(0)),
        branchLen: Array(size).fill().map(() => Array(size).fill(0)),
        branchMaxArr: Array(size).fill().map(() => Array(size).fill(0)),
        branchSubCount: Array(size).fill().map(() => Array(size).fill(0)),
        branchDirX: Array(size).fill().map(() => Array(size).fill(0)),
        branchDirY: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeGrowthTime: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeHeight: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeMaxHeight: Array(size).fill().map(() => Array(size).fill(10)),
        oakTreeRootTimer: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeRootDepth: Array(size).fill().map(() => Array(size).fill(0)),
        oakTreeRootMax: Array(size).fill().map(() => Array(size).fill(5)),
        grassStage: Array(size).fill().map(() => Array(size).fill(0)),
        burningGasTime: Array(size).fill().map(() => Array(size).fill(0)),
        chargedStateTime: Array(size).fill().map(() => Array(size).fill(0))
      };
    }
    
    // Show login message
    function showLoginMessage(message, type) {
      communityLoginMessage.textContent = message;
      communityLoginMessage.className = 'message ' + type;
    }
    
    // Login user
    async function loginUser(username, email, password) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful login if username and email are provided
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // For demo purposes, always succeed if both username and email are provided
        if (username && email) {
          return {
            success: true,
            userData: {
              username,
              email,
              id: 'user_' + Date.now()
            }
          };
        } else {
          return {
            success: false,
            message: 'Invalid username or email'
          };
        }
      } catch (error) {
        console.error('Login error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Register user
    async function registerUser(username, email, password) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful registration
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // For demo purposes, always succeed if both username and email are provided
        if (username && email) {
          return {
            success: true,
            userData: {
              username,
              email,
              id: 'user_' + Date.now()
            }
          };
        } else {
          return {
            success: false,
            message: 'Invalid username or email'
          };
        }
      } catch (error) {
        console.error('Registration error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Load community saves
    async function loadCommunitySaves() {
      // Show loading state
      communitySavesList.innerHTML = '<div class="community-loading">Loading community saves...</div>';
      
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate loading community saves
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Generate some sample community saves
        communitySaves = [
          {
            id: 'save1',
            title: 'Amazing Volcano',
            description: 'A huge volcano with lava flowing down into a water lake, creating steam and obsidian.',
            author: 'LavaLover42',
            date: '2025-05-01',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save2',
            title: 'Working Computer',
            description: 'A functional 4-bit computer built using the logic gates. Can perform basic arithmetic!',
            author: 'DigitalGenius',
            date: '2025-04-28',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save3',
            title: 'Ecosystem Simulation',
            description: 'A balanced ecosystem with plants, water cycle, and birds. Can run for hours without intervention!',
            author: 'NatureNerd',
            date: '2025-05-08',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save4',
            title: 'Rube Goldberg Machine',
            description: 'An elaborate chain reaction using sand, water, and explosives. Very satisfying to watch!',
            author: 'MechanicalMaster',
            date: '2025-05-05',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          },
          {
            id: 'save5',
            title: 'Fireworks Display',
            description: 'A timed sequence of different colored explosions. Perfect for celebrations!',
            author: 'PyroTechnician',
            date: '2025-04-15',
            preview: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
          }
        ];
        
        // Display the saves
        filterAndSortCommunitySaves();
        
        return true;
      } catch (error) {
        console.error('Error loading community saves:', error);
        communitySavesList.innerHTML = '<div class="community-loading">Error loading saves. Please try again later.</div>';
        return false;
      }
    }
    
    // Filter and sort community saves
    function filterAndSortCommunitySaves() {
      const searchTerm = communitySearchFilter.value.toLowerCase();
      const sortOption = communitySortFilter.value;
      
      // Filter saves based on search term
      let filteredSaves = communitySaves.filter(save => {
        return save.title.toLowerCase().includes(searchTerm) || 
               save.author.toLowerCase().includes(searchTerm) || 
               save.description.toLowerCase().includes(searchTerm);
      });
      
      // Sort saves based on selected option
      if (sortOption === 'newest') {
        filteredSaves.sort((a, b) => new Date(b.date) - new Date(a.date));
      } else if (sortOption === 'oldest') {
        filteredSaves.sort((a, b) => new Date(a.date) - new Date(b.date));
      } else if (sortOption === 'name') {
        filteredSaves.sort((a, b) => a.title.localeCompare(b.title));
      }
      
      // Display the filtered and sorted saves
      displayCommunitySaves(filteredSaves);
    }
    
    // Display community saves
    function displayCommunitySaves(saves) {
      if (saves.length === 0) {
        communitySavesList.innerHTML = '<div class="community-loading">No saves found matching your criteria.</div>';
        return;
      }
      
      communitySavesList.innerHTML = '';
      
      saves.forEach(save => {
        const saveCard = document.createElement('div');
        saveCard.className = 'community-save-card';
        
        const savePreview = document.createElement('div');
        savePreview.className = 'community-save-preview';
        
        const previewImg = document.createElement('img');
        previewImg.src = save.preview;
        previewImg.alt = save.title;
        savePreview.appendChild(previewImg);
        
        const saveTitle = document.createElement('div');
        saveTitle.className = 'community-save-title';
        saveTitle.textContent = save.title;
        
        const saveAuthor = document.createElement('div');
        saveAuthor.className = 'community-save-author';
        saveAuthor.textContent = `By: ${save.author}`;
        
        const saveDate = document.createElement('div');
        saveDate.className = 'community-save-date';
        saveDate.textContent = `Uploaded: ${formatDate(save.date)}`;
        
        const saveDescription = document.createElement('div');
        saveDescription.className = 'community-save-description';
        saveDescription.textContent = save.description;
        
        const saveActions = document.createElement('div');
        saveActions.className = 'community-save-actions';
        
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download';
        downloadBtn.addEventListener('click', () => downloadCommunitySave(save.id));
        saveActions.appendChild(downloadBtn);
        
        saveCard.appendChild(savePreview);
        saveCard.appendChild(saveTitle);
        saveCard.appendChild(saveAuthor);
        saveCard.appendChild(saveDate);
        saveCard.appendChild(saveDescription);
        saveCard.appendChild(saveActions);
        
        communitySavesList.appendChild(saveCard);
      });
    }
    
    // Format date for display
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    }
    
    // Load local saves
    function loadLocalSaves() {
      communityLocalSavesList.innerHTML = '';
      selectedLocalSave = null;
      communityUploadBtn.disabled = true;
      
      // Get all save keys from localStorage
      const saveKeys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('sandboxSave_')) {
          saveKeys.push(key);
        }
      }
      
      if (saveKeys.length === 0) {
        communityLocalSavesList.innerHTML = '<div class="local-save-item">No local saves found. Create a save first!</div>';
        return;
      }
      
      // Display each save
      saveKeys.forEach(key => {
        try {
          const saveData = JSON.parse(localStorage.getItem(key));
          const saveItem = document.createElement('div');
          saveItem.className = 'local-save-item';
          saveItem.textContent = saveData.name || 'Unnamed Save';
          saveItem.dataset.key = key;
          
          saveItem.addEventListener('click', function() {
            // Deselect all other saves
            document.querySelectorAll('.local-save-item').forEach(item => {
              item.classList.remove('selected');
            });
            
            // Select this save
            this.classList.add('selected');
            selectedLocalSave = this.dataset.key;
            
            // Enable upload button
            communityUploadBtn.disabled = false;
            
            // Set default title if empty
            if (!communityUploadTitle.value) {
              communityUploadTitle.value = saveData.name || 'My Creation';
            }
          });
          
          communityLocalSavesList.appendChild(saveItem);
        } catch (error) {
          console.error('Error parsing save data:', error);
        }
      });
    }
    
    // Upload save to server
    async function uploadSave(title, description, saveData) {
      try {
        // In a real implementation, this would be an actual fetch to the server
        // For now, we'll simulate a successful upload
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // For demo purposes, always succeed
        return {
          success: true,
          message: 'Save uploaded successfully!'
        };
      } catch (error) {
        console.error('Upload error:', error);
        return {
          success: false,
          message: 'Server error'
        };
      }
    }
    
    // Download community save
    async function downloadCommunitySave(saveId) {
      try {
        // Find the save in our local array
        const save = communitySaves.find(s => s.id === saveId);
        if (!save) {
          alert('Save not found');
          return;
        }
        
        // In a real implementation, this would fetch the save data from the server
        // For now, we'll simulate a successful download with a placeholder save
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Create a placeholder save
        const placeholderSave = {
          name: save.title,
          description: save.description,
          author: save.author,
          date: save.date,
          grid: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)),
          temp: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(20))
        };
        
        // Save to localStorage
        const saveKey = 'sandboxSave_community_' + Date.now();
        localStorage.setItem(saveKey, JSON.stringify(placeholderSave));
        
        alert(`"${save.title}" has been downloaded and saved to your local saves!`);
        
        return true;
      } catch (error) {
        console.error('Download error:', error);
        alert('Error downloading save. Please try again later.');
        return false;
      }
    }
    
      // Server Communication Module (for a real implementation)
      // This would be replaced with actual server communication code
      
      // Example server communication code (commented out for now):
      /*
      // Function to securely communicate with the server
      async function serverRequest(endpoint, method = 'GET', data = null) {
        try {
          const options = {
            method,
            headers: {
              'Content-Type': 'application/json'
            },
            credentials: 'include' // Include cookies for session management
          };
          
          if (data && (method === 'POST' || method === 'PUT')) {
            options.body = JSON.stringify(data);
          }
          
          const response = await fetch(`${SERVER_URL}/${endpoint}`, options);
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'Server error');
          }
          
          return await response.json();
        } catch (error) {
          console.error(`Error in ${endpoint}:`, error);
          throw error;
        }
      }
      
      // Login user
      async function loginUser(username, email, password) {
        return serverRequest('auth/login', 'POST', { username, email, password });
      }
      
      // Register user
      async function registerUser(username, email, password) {
        return serverRequest('auth/register', 'POST', { username, email, password });
      }
      
      // Load community saves
      async function loadCommunitySaves() {
        return serverRequest('saves');
      }
      
      // Upload save
      async function uploadSave(title, description, saveData) {
        return serverRequest('saves/upload', 'POST', {
          title,
          description,
          saveData,
          date: new Date().toISOString()
        });
      }
      
      // Download save
      async function downloadCommunitySave(saveId) {
        return serverRequest(`saves/${saveId}`);
      }
      */
    }); // Close DOMContentLoaded event handler
  </script>



  <!-- Mod Manager Modal -->
  <div id="modMenu" class="modal">
    <div class="modal-content">
      <span id="closeModMenu" class="close">&times;</span>
      <h2>Mod Manager</h2>
      <div id="modListContainer">
        <!-- Mod cards will be dynamically inserted here -->
      </div>
      <button id="addModButton">+ Add New Mod</button>
    </div>
  </div>

  <!-- Add New Mod Modal (only mod code textarea, forced mod info comes from code) -->
  <div id="addModModal" class="modal">
    <div class="modal-content">
      <span id="closeAddModModal" class="close">&times;</span>
      <h2>Add New Mod</h2>
      <textarea id="newModCode" rows="10" placeholder="Paste your mod JS code here"></textarea>
      <button id="saveNewModButton">Save Mod</button>
    </div>
  </div>
  


  <!-- Options Modal -->
  <div id="optionsModal" class="modal">
    <div class="modal-content">
      <span id="closeOptionsModal" class="close">&times;</span>
      <h2>Options</h2>
      <div class="options-content">
        <div class="options-section">
          <h3>Game Options</h3>
          <div class="option-item">
            <label for="stageSizeSelect">Stage Size (Requires Canvas Clear):</label>
            <select id="stageSizeSelect">
              <option value="25">25x25x25</option>
              <option value="50" selected>50x50x50</option>
              <option value="75">75x75x75</option>
              <option value="100">100x100x100</option>
              <option value="125">125x125x125</option>
            </select>
            <p class="option-description">Larger sizes provide more space and detail, but will require more processing power.</p> <br> <p class="option-description" style="color:red;">WARNING: Changing the stage size will completely clear the current canvas. This action cannot be undone.</p>
          </div>

          <div class="option-item">
            <label for="hudToggle">Show HUD:</label>
            <select id="hudToggle">
              <option value="1" selected>Enabled</option>
              <option value="0">Disabled</option>
            </select>
            <p class="option-description">Toggles the display of the HUD (temperature, element, and FPS display).</p>
          </div>

          <div class="option-item">
            <button id="generateTerrainBtn" class="options-button" onclick="generateTerrain()">Generate Terrain</button>
            <p class="option-description">Creates a procedurally generated world with caves, ores, and surface features.</p>
          </div>
        </div>

        <div class="options-section">
          <h3>Graphics Settings</h3>
          <div class="option-item">
            <label for="variatedColorsToggle">Variated Colors:</label>
            <select id="variatedColorsToggle">
              <option value="1" selected>Enabled</option>
              <option value="0">Disabled</option>
            </select>
            <p class="option-description">When enabled, elements will have slight color variations. When disabled, all elements will have consistent colors.</p>
            <button id="applyVariatedColors" class="options-button">Apply Setting</button>
          </div>
          
          <div class="option-item">
            <label for="dspleToggle">DSPLE (Dabicco Shader-Pixel Lighting Engine):</label>
            <select id="dspleToggle">
              <option value="0" selected>Disabled</option>
              <option value="1">Enabled</option>
            </select>
            <p class="option-description">Adds shader-based dynamic lighting to the simulation, creating realistic light effects from glowing elements. May impact performance on slower devices.</p>
            <button id="applyDsple" class="options-button">Apply Setting</button>
          </div>
        </div>
        
        <div class="options-section">
          <h3>Sound Options</h3>
          <div class="option-item">
            <label for="masterVolumeSlider">Master Volume:</label>
            <input type="range" id="masterVolumeSlider" min="0" max="100" value="100" class="volume-slider">
            <span id="masterVolumeValue">100%</span>
            <p class="option-description">Controls the overall volume of all sounds in the game.</p>
          </div>
          
          <div class="option-item">
            <button id="toggleElementVolumes" class="options-button">Show Element Volume Controls</button>
            <div id="elementVolumeControls" style="display: none;">
              <div class="element-volume-grid">
                <!-- Element volume sliders will be added here dynamically -->
              </div>
            </div>
          </div>
        </div>

        <div class="options-section experimental">
          <h3>Experimental Features</h3>
          <div class="option-item">
            <label for="popOutMode">[UNSTABLE] Pop-Out Mode:</label>
            <select id="popOutMode">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Opens the simulation in a separate window that can be resized independently. Currently unstable and WILL cause issues.</p>
          </div>
          <div class="option-item">
            <label for="setting-dabyfps">DabyFPS:</label>
            <select id="setting-dabyfps">
              <option value="false" selected>OFF</option>
              <option value="true">ON</option>
            </select>
            <p class="option-description">DabyFPS's Main Feature, Frame Rate Stabilization (DBFRS), has already been added to the game; enable for MISC optimizations, however these can and probably will slow down the game more than it optimizes it.</p>
          </div>
          <div class="option-item" id="fps-cap-container" style="display:none;">
            <label for="setting-fps-cap">FPS Cap:</label>
            <select id="setting-fps-cap">
              <option value="30">30</option>
              <option value="60" selected>60</option>
              <option value="75">75</option>
              <option value="100">100</option>
              <option value="120">120</option>
              <option value="165">165</option>
              <option value="175">175</option>
              <option value="200">200</option>
              <option value="230">230</option>
              <option value="365">365</option>
              <option value="512">512</option>
            </select>
            <p class="option-description">Sets the FPS for the game (the speed at which the game should run at) and ensures the FPS never goes above.</p>
          </div>
        </div>
      </div>
      <button id="applyOptionsButton" style="display: none !important">Apply Required Clear Settings (WILL CLEAR CANVAS)</button>
    </div>
  </div>

  <!-- Save/Load Modal -->
  <div id="saveLoadModal" class="modal">
    <div class="modal-content">
      <span id="closeSaveLoadModal" class="close">&times;</span>
      <h2>Save / Load</h2>
      <div>
        <h3>Save Current Game</h3>
        <div class="input-group">
          <input type="text" id="saveTitle" placeholder="Save Title" maxlength="20">
          <div id="saveTitleWarning" class="input-warning"></div>
        </div>
        <div class="input-group">
          <input type="text" id="saveDescription" placeholder="Save Description" maxlength="30">
          <div id="saveDescriptionWarning" class="input-warning"></div>
        </div>
        <button id="saveGameButton">Save Game</button>
      </div>
      <hr>
      <div>
        <h3>Saved Games</h3>
        <div id="savedGamesList">
          <!-- List of saved games will appear here -->
        </div>
      </div>
      <hr>
      <div>
        <h3>Import Save File (.dbr)</h3>
        <input type="file" id="importFileInput" accept=".dbr">
        <button id="importSaveButton">Import Save</button>
      </div>
    </div>
  </div>

  <!-- Community Saves Modal -->
  <div id="communityModal" class="modal">
    <div class="modal-content">
      <span id="closeCommunityModal" class="close">&times;</span>
      <h2>Community Saves</h2>
      <div>
        <h3>Browse Community Saves</h3>
        <div id="communitySavesList">
          <!-- List of community saves will appear here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global mods list
    const modsList = [];
    // Function to parse forcedModInfo from mod code using regex
    function parseForcedModInfo(modCode) {
      const regex = /window\.forcedModInfo\s*=\s*(\{[\s\S]*?\});/m;
      const match = modCode.match(regex);
      if (match && match[1]) {
        try {
          return (new Function("return " + match[1]))();
        } catch (e) {
          console.error("Error parsing forcedModInfo:", e);
          return null;
        }
      }
      return null;
    }
    // Add the default mod (Orange Juice mod) to the modsList.
    const orangeJuiceModCode = `(function(){
      // ----------------------------------------------------------------------
      // FORCE MOD IDENTIFICATION
      // ----------------------------------------------------------------------
      window.forcedModInfo = {
        id: 'exampleElementMod',
        title: 'Example Element Mod',
        description: 'Adds a simple example element that deletes anything it touches. Great for learning how to make mods!',
        gameVersion: '0.7.1c'
      };

      // ----------------------------------------------------------------------
      // DEFINE THE NEW ELEMENT CONSTANT
      // ----------------------------------------------------------------------
      if (typeof window.EXAMPLE_ELEMENT === 'undefined') {
        window.EXAMPLE_ELEMENT = 67;
      }

      // ----------------------------------------------------------------------
      // INJECT CSS TO STYLE THE MOD'S TOOL AND CELLS
      // ----------------------------------------------------------------------
      var style = document.createElement('style');
      style.innerHTML = \`
        .tool.example-element { 
          background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
          border: 2px solid white !important;
        }
        .example-element { 
          background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
          border: 2px solid white !important;
        }
      \`;
      document.head.appendChild(style);

      // ----------------------------------------------------------------------
      // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
      // ----------------------------------------------------------------------
      if (!window.exampleElementModOriginals) {
        window.exampleElementModOriginals = {
          selectTool: selectTool,
          placeElementAt: placeElementAt,
          getElementName: getElementName,
          renderCell: renderCell,
          performSimulationStep: performSimulationStep
        };
      }

      // ----------------------------------------------------------------------
      // CREATE THE MOD TOOL BUTTON
      // ----------------------------------------------------------------------
      var exampleTool = document.createElement('div');
      exampleTool.className = 'tool example-element';
      exampleTool.setAttribute('data-tool', 'example-element');
      exampleTool.setAttribute('data-cat', 'special');
      exampleTool.title = 'Example Element';
      var span = document.createElement('span');
      span.textContent = 'EX';
      exampleTool.appendChild(span);
      toolbar.appendChild(exampleTool);
      exampleTool.addEventListener('click', function(){
        selectTool(exampleTool);
      });

      // ----------------------------------------------------------------------
      // PATCH THE selectTool FUNCTION
      // ----------------------------------------------------------------------
      selectTool = function(el) {
        var toolName = el.getAttribute('data-tool');
        if (toolName === 'example-element') {
          currentTool = EXAMPLE_ELEMENT;
          Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
          el.classList.add('selected');
        } else {
          window.exampleElementModOriginals.selectTool(el);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH THE placeElementAt FUNCTION
      // ----------------------------------------------------------------------
      placeElementAt = function(x, y, tool) {
        if (tool === EXAMPLE_ELEMENT) {
          eraseCell(x, y);
          grid[y][x] = EXAMPLE_ELEMENT;
          temp[y][x] = 20;
        } else {
          window.exampleElementModOriginals.placeElementAt(x, y, tool);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH getElementName TO SHOW EXAMPLE ELEMENT
      // ----------------------------------------------------------------------
      getElementName = function(e) {
        if (e === EXAMPLE_ELEMENT) return "Example Element";
        return window.exampleElementModOriginals.getElementName(e);
      };

      // ----------------------------------------------------------------------
      // PATCH renderCell TO RENDER EXAMPLE ELEMENT CELLS
      // ----------------------------------------------------------------------
      renderCell = function(x, y) {
        const cell = cells[y][x];
        cell.className = 'cell';
        cell.style.opacity = "";
        cell.style.backgroundColor = "";
        var e = grid[y][x];
        if (e === EXAMPLE_ELEMENT) {
          cell.classList.add('example-element');
        } else {
          window.exampleElementModOriginals.renderCell(x, y);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH performSimulationStep TO PROCESS EXAMPLE ELEMENT CELLS
      // ----------------------------------------------------------------------
      var origPerformSimStep = window.exampleElementModOriginals.performSimulationStep;
      performSimulationStep = function() {
        // Process Example Element behavior
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            if (grid[y][x] === EXAMPLE_ELEMENT && !moved[y][x]) {
              // Delete adjacent cells
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for (let [dx, dy] of neighbors) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== EXAMPLE_ELEMENT) {
                    eraseCell(nx, ny);
                  }
                }
              }
              
              // Move randomly
              let possibleMoves = [];
              for (let [dx, dy] of neighbors) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] === EMPTY) {
                    possibleMoves.push([nx, ny]);
                  }
                }
              }
              
              if (possibleMoves.length > 0) {
                let [nx, ny] = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                moveCell(x, y, nx, ny, temp[y][x], EXAMPLE_ELEMENT);
              }
            }
          }
        }
        origPerformSimStep();
      };
    })();`;

    const orangeJuiceTerminateCode = `(function(){
      if(window.exampleElementModOriginals) {
        selectTool = window.exampleElementModOriginals.selectTool;
        placeElementAt = window.exampleElementModOriginals.placeElementAt;
        getElementName = window.exampleElementModOriginals.getElementName;
        renderCell = window.exampleElementModOriginals.renderCell;
        performSimulationStep = window.exampleElementModOriginals.performSimulationStep;
      }
    })();`;

    modsList.push({
      id: 'exampleElementMod',
      title: 'Example Element Mod',
      description: 'Adds a simple example element that deletes anything it touches. Great for learning how to make mods!',
      gameVersion: '0.7.1c',
      code: orangeJuiceModCode,
      terminateCode: orangeJuiceTerminateCode,
      enabled: false
    });
    function isModCompatible(mod) {
      // Only allow mods from exact version match
      return mod.gameVersion === currentGameVersion;
    }
    function updateModListUI() {
      const container = document.getElementById('modListContainer');
      container.innerHTML = '';
      modsList.forEach(mod => {
        const card = document.createElement('div');
        card.className = 'modCard';
        const titleEl = document.createElement('h3');
        titleEl.textContent = mod.title;
        const descEl = document.createElement('p');
        descEl.textContent = mod.description;
        const versionEl = document.createElement('small');
        versionEl.textContent = "Version: " + mod.gameVersion;
        if (!isModCompatible(mod)) {
          versionEl.classList.add('incompatible');
          versionEl.title = "Incompatible! Made for version " + mod.gameVersion;
        }
        const statusEl = document.createElement('div');
        statusEl.textContent = 'Status: ' + (mod.enabled ? 'Enabled' : 'Disabled');
        const execButton = document.createElement('button');
        execButton.textContent = 'Execute Code';
        execButton.addEventListener('click', () => {
          if (!mod.enabled) {
            try {
              eval(mod.code);
              mod.enabled = true;
              updateModListUI();
            } catch (e) {
              statusEl.textContent = 'Error: ' + e;
            }
          }
        });
        const termButton = document.createElement('button');
        termButton.textContent = 'Terminate';
        termButton.addEventListener('click', () => {
          if (mod.enabled && mod.terminateCode) {
            try {
              eval(mod.terminateCode);
              mod.enabled = false;
              updateModListUI();
            } catch (e) {
              statusEl.textContent = 'Error: ' + e;
            }
          }
        });
        card.appendChild(titleEl);
        card.appendChild(descEl);
        card.appendChild(versionEl);
        card.appendChild(statusEl);
        card.appendChild(execButton);
        card.appendChild(termButton);
        container.appendChild(card);
      });
    }
    const modButton = document.getElementById('modButton');
    const modMenu = document.getElementById('modMenu');
    const closeModMenu = document.getElementById('closeModMenu');
    modButton.addEventListener('click', function() {
      modMenu.style.display = 'block';
      updateModListUI();
    });
    closeModMenu.addEventListener('click', function() {
      modMenu.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == modMenu) {
        modMenu.style.display = 'none';
      }
    });
    const addModButton = document.getElementById('addModButton');
    const addModModal = document.getElementById('addModModal');
    const closeAddModModal = document.getElementById('closeAddModModal');
    const saveNewModButton = document.getElementById('saveNewModButton');
    addModButton.addEventListener('click', function() {
      addModModal.style.display = 'block';
    });
    closeAddModModal.addEventListener('click', function() {
      addModModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == addModModal) {
        addModModal.style.display = 'none';
      }
    });
    saveNewModButton.addEventListener('click', function() {
      const modCode = document.getElementById('newModCode').value;
      if (modCode.trim() !== '') {
        const forcedInfo = parseForcedModInfo(modCode);
        if (forcedInfo && forcedInfo.id && forcedInfo.title && forcedInfo.description && forcedInfo.gameVersion) {
          const newMod = {
            id: forcedInfo.id,
            title: forcedInfo.title,
            description: forcedInfo.description,
            gameVersion: forcedInfo.gameVersion,
            code: modCode,
            terminateCode: '',
            enabled: false
          };
          modsList.push(newMod);
          updateModListUI();
          document.getElementById('newModCode').value = '';
          addModModal.style.display = 'none';
        }
      }
    });
    const optionsButton = document.getElementById('optionsButton');
    const optionsModal = document.getElementById('optionsModal');
    const closeOptionsModal = document.getElementById('closeOptionsModal');
    optionsButton.addEventListener('click', function() {
      optionsModal.style.display = 'block';
      // Initialize dynamic lighting select with current state
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.value = window.isDynamicLightingEnabled ? '1' : '0';
      }
    });
    closeOptionsModal.addEventListener('click', function() {
      optionsModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == optionsModal) {
        optionsModal.style.display = 'none';
      }
    });
    // Safely add event listener with error handling
    const applyOptionsButton = document.getElementById('applyOptionsButton');
    if (applyOptionsButton) {
      applyOptionsButton.addEventListener('click', function() {
        try {
          const sizeSelect = document.getElementById('stageSizeSelect');
          if (!sizeSelect) return;
          
          const size = parseInt(sizeSelect.value);
          if (isNaN(size) || size < 10 || size > 200) {
            console.error('Invalid grid size:', size);
            return;
          }
          
          // Reset game state variables before changing grid size
          lastFrameTime = 0;
          stepAccumulator = 0;
          
          // Initialize the grid with the new size
          initGrid(size);
          
          // Hide the modal
          if (optionsModal) optionsModal.style.display = 'none';
        } catch (error) {
          console.error('Error applying options:', error);
        }
      });
    }
    const saveLoadButton = document.getElementById('saveLoadButton');
    const saveLoadModal = document.getElementById('saveLoadModal');
    const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');
    saveLoadButton.addEventListener('click', function() {
      saveLoadModal.style.display = 'block';
      updateSavedGamesList();
    });
    closeSaveLoadModal.addEventListener('click', function() {
      saveLoadModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == saveLoadModal) {
        saveLoadModal.style.display = 'none';
      }
    });
    
    // Community menu functionality - removed since the community button was removed
    // const communityButton = document.getElementById('communityButton');
    // const communityModal = document.getElementById('communityModal');
    // const closeCommunityModal = document.getElementById('closeCommunityModal');
    // if (communityButton) {
    //   communityButton.addEventListener('click', function() {
    //     communityModal.style.display = 'block';
    //     updateCommunitySavesList();
    //   });
    // }
    // if (closeCommunityModal) {
    //   closeCommunityModal.addEventListener('click', function() {
    //     communityModal.style.display = 'none';
    //   });
    // }
    // Remove event listener for community modal since it was removed
    // window.addEventListener('click', function(event) {
    //   if (event.target == communityModal) {
    //     communityModal.style.display = 'none';
    //   }
    // });
    function getSaveIndex() {
      const index = localStorage.getItem("dbr_save_index");
      return index ? JSON.parse(index) : [];
    }
    function setSaveIndex(index) {
      localStorage.setItem("dbr_save_index", JSON.stringify(index));
    }
    function saveGame() {
      const title = document.getElementById('saveTitle').value.trim();
      const description = document.getElementById('saveDescription').value.trim();
      if (!title) return;
      const saveData = {
        GRID_SIZE,
        grid, temp, vaporLife, cloudLife, fireLife, smokeLife, burningWoodTime, wheatHeight, wheatMaxHeight,
        seedGrowthTime, rootLife, sparkLife, sparkTimer, smokeMaxLife, cloudMaxLife, branchLevel,
        branchLen, branchMaxArr, branchSubCount, branchDirX, branchDirY, oakTreeGrowthTime, oakTreeHeight,
        oakTreeMaxHeight, oakTreeRootTimer, oakTreeRootDepth, oakTreeRootMax, grassStage, burningGasTime,
        chargedStateTime, colorVariations
      };
      const key = "dbr_save_" + Date.now();
      localStorage.setItem(key, JSON.stringify(saveData));
      let index = getSaveIndex();
      index.push({ key, title, description, timestamp: Date.now() });
      setSaveIndex(index);
      updateSavedGamesList();
      document.getElementById('saveTitle').value = '';
      document.getElementById('saveDescription').value = '';
    }
    document.getElementById('saveGameButton').addEventListener('click', saveGame);
    function updateSavedGamesList() {
    const container = document.getElementById('savedGamesList');
    container.innerHTML = "";
    const index = getSaveIndex();
    
    index.forEach(item => {
      // Create a card for each saved game
      const card = document.createElement('div');
      card.className = 'save-game-card';
      
      // Create the preview section
      const previewContainer = document.createElement('div');
      previewContainer.className = 'save-preview';
      
      // Create the actual preview grid
      const previewGrid = document.createElement('div');
      previewGrid.className = 'preview-grid';
      
      // Try to load the save data to create a preview
      const saveData = localStorage.getItem(item.key);
      if (saveData) {
        try {
          const save = JSON.parse(saveData);
          
          // We'll show a smaller version of the grid (20x20)
          const previewSize = 20;
          previewGrid.style.gridTemplateColumns = `repeat(${previewSize}, 1fr)`;
          previewGrid.style.gridTemplateRows = `repeat(${previewSize}, 1fr)`;
          
          // Figure out how to scale down the full grid to our preview size
          const scaleFactor = save.GRID_SIZE / previewSize;
          
          // Create the tiny preview cells
          for (let y = 0; y < previewSize; y++) {
            for (let x = 0; x < previewSize; x++) {
              // Map preview coordinates to the actual saved grid
              const gridX = Math.floor(x * scaleFactor);
              const gridY = Math.floor(y * scaleFactor);
              
              // Create a cell
              const cell = document.createElement('div');
              
              // Color the cell based on what's in the saved grid
              if (gridX < save.GRID_SIZE && gridY < save.GRID_SIZE) {
                const element = save.grid[gridY][gridX];
                cell.style.backgroundColor = getElementColor(element);
              } else {
                cell.style.backgroundColor = '#000'; // Default black
              }
              
              previewGrid.appendChild(cell);
            }
          }
        } catch (e) {
          console.error("Error creating preview:", e);
        }
      }
      
      // Add the preview grid to the container
      previewContainer.appendChild(previewGrid);
      card.appendChild(previewContainer);
      
      // Create the info section with title and description
      const infoDiv = document.createElement('div');
      infoDiv.className = 'save-info';
      
      const titleDiv = document.createElement('div');
      titleDiv.className = 'save-title';
      titleDiv.textContent = item.title;
      
      const descDiv = document.createElement('div');
      descDiv.className = 'save-description';
      descDiv.textContent = item.description;
      
      infoDiv.appendChild(titleDiv);
      infoDiv.appendChild(descDiv);
      card.appendChild(infoDiv);
      
      // Create the buttons
      const buttonsDiv = document.createElement('div');
      buttonsDiv.className = 'save-buttons';
      
      const loadBtn = document.createElement('button');
      loadBtn.className = 'load-button';
      loadBtn.textContent = "Load";
      loadBtn.addEventListener('click', () => {
        // Use the existing load functionality
        const data = localStorage.getItem(item.key);
        if (data) {
          const save = JSON.parse(data);
          GRID_SIZE = save.GRID_SIZE;
          initGrid(GRID_SIZE);
          grid = save.grid;
          temp = save.temp;
          vaporLife = save.vaporLife;
          cloudLife = save.cloudLife;
          fireLife = save.fireLife;
          smokeLife = save.smokeLife;
          burningWoodTime = save.burningWoodTime;
          wheatHeight = save.wheatHeight;
          wheatMaxHeight = save.wheatMaxHeight;
          seedGrowthTime = save.seedGrowthTime;
          rootLife = save.rootLife;
          sparkLife = save.sparkLife;
          sparkTimer = save.sparkTimer;
          smokeMaxLife = save.smokeMaxLife;
          cloudMaxLife = save.cloudMaxLife;
          branchLevel = save.branchLevel;
          branchLen = save.branchLen;
          branchMaxArr = save.branchMaxArr;
          branchSubCount = save.branchSubCount;
          branchDirX = save.branchDirX;
          branchDirY = save.branchDirY;
          oakTreeGrowthTime = save.oakTreeGrowthTime;
          oakTreeHeight = save.oakTreeHeight;
          oakTreeMaxHeight = save.oakTreeMaxHeight;
          oakTreeRootTimer = save.oakTreeRootTimer;
          oakTreeRootDepth = save.oakTreeRootDepth;
          oakTreeRootMax = save.oakTreeRootMax;
          grassStage = save.grassStage;
          burningGasTime = save.burningGasTime;
          chargedStateTime = save.chargedStateTime;
          
          // Load color variations if they exist in the save data
          if (save.colorVariations) {
            colorVariations = save.colorVariations;
          } else {
            // Initialize color variations for existing elements if loading an old save
            colorVariations = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            
            // Generate variations for existing elements
            const variation = 0.05;
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                if (grid[y][x] !== EMPTY) {
                  colorVariations[y][x] = {
                    r: 1 + (Math.random() * variation * 2 - variation),
                    g: 1 + (Math.random() * variation * 2 - variation),
                    b: 1 + (Math.random() * variation * 2 - variation)
                  };
                }
              }
            }
          }
          
          renderGrid();
        }
      });
      
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener('click', () => {
        // Use the existing delete functionality
        let index = getSaveIndex();
        index = index.filter(i => i.key !== item.key);
        setSaveIndex(index);
        localStorage.removeItem(item.key);
        updateSavedGamesList();
      });
      
      const exportBtn = document.createElement('button');
      exportBtn.textContent = "Export";
      exportBtn.addEventListener('click', () => {
        // Use the existing export functionality
        const data = localStorage.getItem(item.key);
        if (data) {
          const blob = new Blob([data], {type: "application/json"});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = item.title + ".dbr";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      });
      
      buttonsDiv.appendChild(loadBtn);
      buttonsDiv.appendChild(deleteBtn);
      buttonsDiv.appendChild(exportBtn);
      card.appendChild(buttonsDiv);
      
      // Add the complete card to the container
      container.appendChild(card);
    });
  }
    document.getElementById('importSaveButton').addEventListener('click', () => {
      const fileInput = document.getElementById('importFileInput');
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const save = JSON.parse(e.target.result);
          const key = "dbr_save_" + Date.now();
          localStorage.setItem(key, JSON.stringify(save));
          let index = getSaveIndex();
          index.push({ key, title: file.name, description: "Imported Save", timestamp: Date.now() });
          setSaveIndex(index);
          updateSavedGamesList();
        } catch (err) {
          console.error("Import error", err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById('stageSizeSelect').addEventListener('change', function() {
      const newSize = parseInt(this.value);
      if (newSize !== GRID_SIZE) {
        pendingStageSize = newSize;
        confirmationModal.style.display = 'block';
      } else {
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        document.getElementById('applyOptionsButton').style.display = 'none';
      }
    });

    confirmYes.addEventListener('click', function() {
      if (pendingStageSize !== null) {
        initGrid(pendingStageSize);
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        optionsModal.style.display = 'none';
      }
    });

    confirmNo.addEventListener('click', function() {
      pendingStageSize = null;
      confirmationModal.style.display = 'none';
      document.getElementById('stageSizeSelect').value = GRID_SIZE.toString();
      document.getElementById('applyOptionsButton').style.display = 'none';
    });

    // DabyFPS setting
    document.getElementById('setting-dabyfps').value = localStorage.getItem('setting-dabyfps') || 'false';
    document.getElementById('setting-dabyfps').addEventListener('change', function() {
      localStorage.setItem('setting-dabyfps', this.value);
      // Show or hide the FPS cap setting based on DabyFPS being enabled
      document.getElementById('fps-cap-container').style.display = 
        this.value === 'true' ? 'block' : 'none';
    });
    
    // FPS Cap setting
    document.getElementById('setting-fps-cap').value = localStorage.getItem('setting-fps-cap') || '60';
    document.getElementById('setting-fps-cap').addEventListener('change', function() {
      localStorage.setItem('setting-fps-cap', this.value);
    });
    
    // Show/hide FPS cap based on saved DabyFPS setting
    document.getElementById('fps-cap-container').style.display = 
      document.getElementById('setting-dabyfps').value === 'true' ? 'block' : 'none';

    // This function returns the color for each element type; I used to implement it during debugging, however it's now used for the Save/Load functionality.
    function getElementColor(element) {
    // This matches the game's element colors! Modders should use this for new elements.
    switch(element) {
      case 0: return '#000000'; // EMPTY
      case 1: return '#e6c88e'; // SAND
      case 2: return '#4286f4'; // WATER
      case 3: return '#ff4500'; // LAVA
      case 4: return '#808080'; // STONE
      case 5: return '#ffb6c1'; // ERASER
      case 6: return '#b3e6ff'; // WATER_VAPOR
      case 7: return '#ffffff'; // CLOUD
      case 8: return '#555555'; // BASALT
      case 9: return '#333333'; // OBSIDIAN
      case 10: return '#a52a2a'; // MOLTEN_SLAG
      case 11: return '#b87333'; // COPPER
      case 12: return '#aaaaaa'; // STEEL
      case 13: return '#cceeff'; // ICE
      case 14: return '#8b4513'; // WOOD
      case 15: return '#ff6600'; // FIRE
      case 16: return '#777777'; // SMOKE
      case 17: return '#a52a2a'; // BURNING_WOOD
      case 18: return '#555555'; // ASH
      case 19: return '#d3d3d3'; // GLASS
      case 20: return '#ff0000'; // BOMB
      case 21: return '#8b4513'; // DIRT
      case 22: return '#a0522d'; // WET_DIRT
      case 23: return '#f5deb3'; // WHEAT_SEEDS
      case 24: return '#f0e68c'; // WHEAT
      case 25: return '#fff8dc'; // FLOUR
      case 26: return '#f5deb3'; // DOUGH
      case 27: return '#d2b48c'; // BREAD
      case 28: return '#8b4513'; // ROOT
      case 29: return '#a52a2a'; // BURNING_ORGANIC
      case 30: return '#ffff00'; // SPARK
      case 31: return '#ffa500'; // CHARGED_COPPER
      case 32: return '#556b2f'; // OAK_SEEDS
      case 33: return '#228b22'; // OAK_LEAVES
      case 34: return '#32cd32'; // OAK_BABY_LEAVES
      case 35: return '#8b4513'; // DEAD_OAK
      case 36: return '#d2b48c'; // WET_SAND
      case 37: return '#7cfc00'; // GRASS
      case 38: return '#8b4513'; // DEAD_PLANT
      case 39: return '#a52a2a'; // BURNING_LEAVES
      case 40: return '#a52a2a'; // BURNING_ROOT
      case 41: return '#8b4513'; // DEAD_ROOT
      case 42: return '#e6e6fa'; // GAS
      case 43: return '#ff6347'; // BURNING_GAS
      case 44: return '#696969'; // WALL
      case 45: return '#cd853f'; // CHARGED_DOWN_COPPER
      case 46: return '#00bfff'; // COOLER
      case 47: return '#ff4500'; // HEATER
      case 48: return '#ffd700'; // HEAT_SEPARATOR
      case 49: return '#ffa500'; // CHARGED_HEAT_SEPARATOR
      case 50: return '#cd853f'; // CHARGED_DOWN_HEAT_SEPARATOR
      case 51: return '#00ff00'; // INPUT
      case 52: return '#7fff00'; // CHARGED_INPUT
      case 53: return '#0000ff'; // OUTPUT
      case 54: return '#1e90ff'; // CHARGED_OUTPUT
      case 55: return '#ff00ff'; // NOT_GATE
      case 56: return '#9932cc'; // AND_GATE
      case 57: return '#800080'; // BLOCKER
      case 60: return '#00ffff'; // CLONER
      case 61: return '#9370db'; // CHARGED_BLOCKER
      case 62: return '#2f4f4f'; // COAL
      case 63: return '#2f4f4f'; // COAL_LUMP
      case 64: return '#8b0000'; // BURNING_COAL
      case 65: return '#8b0000'; // BURNING_COAL_LUMP
      case 68: return '#a9a9a9'; // THERMITE
      case 69: return '#ff4500'; // BURNING_THERMITE
      case 70: return '#32cd32'; // ACID
      case 71: return '#98fb98'; // ACID_STEAM
      case 72: return '#90ee90'; // ACID_CLOUD
      case 73: return '#00ff7f'; // SLIME
      case 74: return '#d3d3d3'; // CARBON_DIOXIDE
      case 75: return '#e0ffff'; // OXYGEN
      case 76: return '#000000'; // BIRD
      case 77: return '#cd5c5c'; // MEAT
      case 78: return '#8b4513'; // COOKED_MEAT
      case 79: return '#a9a9a9'; // COBBLESTONE
      case 80: return '#000000'; // OIL
      case 81: return '#ff0000'; // BIG_BOMB
      case 82: return '#4169e1'; // WATER_BOMB
      case 83: return '#ff4500'; // FIRE_BOMB
      case 84: return '#00ffff'; // CRYO_BOMB
      case 85: return '#ff00ff'; // NUKE_BOMB
      case 86: return '#e6f7ff'; // HELIUM
      case 87: return '#ff1493'; // BOUNCY_BALL
      default: return '#333333'; // Default dark gray
    }
  }
  </script>

  <!-- Initialize all event handlers after DOM is loaded -->
  <script>
    // HUD toggle functionality
    function updateHudVisibility() {
      const hud = document.getElementById('hud');
      const hudToggle = document.getElementById('hudToggle');
      if (hud && hudToggle) {
        const isVisible = hudToggle.value === '1';
        hud.style.display = isVisible ? 'block' : 'none';
        // Save preference
        localStorage.setItem('hudVisible', isVisible ? '1' : '0');
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Debug elements
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });

      // Initialize HUD visibility from saved preference
      const savedHudPreference = localStorage.getItem('hudVisible');
      const hudToggle = document.getElementById('hudToggle');
      if (hudToggle) {
        if (savedHudPreference !== null) {
          hudToggle.value = savedHudPreference;
        }
        updateHudVisibility();
        hudToggle.addEventListener('change', updateHudVisibility);
      }

      // DabyFPS handler
      const dabyFpsSelect = document.getElementById('dabyFps');
      if (dabyFpsSelect) {
        dabyFpsSelect.addEventListener('change', function(e) {
          targetFps = parseInt(e.target.value);
        });
      }

      // Pop out mode handler
      const popOutModeSelect = document.getElementById('popOutMode');
      if (popOutModeSelect) {
        popOutModeSelect.addEventListener('change', function(e) {
          if (parseInt(e.target.value) === 1) {
            if (!popOutWindow || popOutWindow.closed) {
              popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
              const popOutDoc = popOutWindow.document;
              
              // Create pop-out window content
              popOutDoc.write(`
                <!DOCTYPE html>
                <html>
                <head>
                  <style>
                    body { margin: 0; background: #222; overflow: hidden; }
                    #popOutGrid { width: 100%; height: 100%; }
                  </style>
                </head>
                <body>
                  <div id="popOutGrid"></div>
                </body>
                </html>
              `);
              
              // Move grid to pop-out window
              const originalGrid = document.getElementById('grid');
              popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
              
              // Handle window resize
              popOutWindow.addEventListener('resize', function() {
                const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
                originalGrid.style.width = size + 'px';
                originalGrid.style.height = size + 'px';
              });
              
              // Handle window close
              popOutWindow.addEventListener('unload', function() {
                if (!popOutWindow.closed) {
                  document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
                  originalGrid.style.width = '500px';
                  originalGrid.style.height = '500px';
                  document.getElementById('popOutMode').value = "0";
                }
              });
            }
          } else {
            if (popOutWindow && !popOutWindow.closed) {
              popOutWindow.close();
            }
          }
        });
      }

      // Store the current stage size
      let currentStageSize = GRID_SIZE;
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      const applyButton = document.getElementById('applyOptionsButton');

      // Update stage size select to show current size
      stageSizeSelect.value = currentStageSize.toString();

      // Handle stage size change
      stageSizeSelect.addEventListener('change', function(e) {
        const newSize = parseInt(e.target.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
      });

      // Modify applyOptionsButton click handler
      applyButton.addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          currentStageSize = newSize;
          initGrid(newSize);
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'none';
      });

      // When options modal is opened, check if size is different
      document.getElementById('optionsButton').addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'block';
      });
    });

    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>

  <script>
    // Terrain Generation
    window.generateTerrain = function() {
      // Clear the grid first
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          eraseCell(x, y);
        }
      }

      // Generate surface level (about 30% down from top)
      const surfaceLevel = Math.floor(GRID_SIZE * 0.3);
      
      // Generate perlin noise for surface variation
      const surfaceNoise = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        surfaceNoise[x] = Math.sin(x * 0.1) * 3 + Math.random() * 2;
      }

      // Generate caves using a simple cellular automata approach
      let caves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
      
      // Initialize random cave seeds (increased frequency)
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (Math.random() < 0.2) {
            caves[y][x] = true;
          }
        }
      }

      // Smooth caves
      for (let i = 0; i < 3; i++) {
        const newCaves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            let neighbors = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (caves[ny][nx]) neighbors++;
                }
              }
            }
            newCaves[y][x] = neighbors >= 4 || (caves[y][x] && neighbors >= 3);
          }
        }
        caves = newCaves;
      }

      // Generate terrain
      for (let x = 0; x < GRID_SIZE; x++) {
        const localSurface = Math.floor(surfaceLevel + surfaceNoise[x]);
        
        // Generate seeds and plants first
        if (Math.random() < 0.15) {
          grid[localSurface][x-1] = OAK_SEEDS;
          temp[localSurface][x-1] = 20;
        } else if (Math.random() < 0.15) {
          grid[localSurface][x-1] = WHEAT_SEEDS;
          temp[localSurface][x-1] = 20;
        }
        
        // Generate grass layer
        grid[localSurface + 1][x] = GRASS;
        temp[localSurface + 1][x] = 20;
        
        // Add atmospheric gasses
        if (Math.random() < 0.1 && localSurface > 0) {
          grid[localSurface - 1][x] = Math.random() < 0.5 ? CARBON_DIOXIDE : OXYGEN;
          temp[localSurface - 1][x] = 20;
        }
        
        // Generate dirt and occasional cobblestone layer
        for (let y = localSurface + 2; y < localSurface + 7; y++) {
          if (y >= GRID_SIZE) continue;
          if (!caves[y][x]) {
            if (Math.random() < 0.1) {
              grid[y][x] = COBBLESTONE;
            } else {
              grid[y][x] = DIRT;
            }
            temp[y][x] = 20;
          }
        }
        
        // Generate stone layer with ores
        for (let y = localSurface + 7; y < GRID_SIZE; y++) {
          if (!caves[y][x]) {
            if (Math.random() < 0.05) {
              const depth = y / GRID_SIZE;
              if (depth > 0.8 && Math.random() < 0.3) {
                grid[y][x] = STEEL;
              } else if (depth > 0.6 && Math.random() < 0.3) {
                grid[y][x] = COPPER;
              } else if (Math.random() < 0.4) {
                grid[y][x] = COAL;
              } else {
                grid[y][x] = STONE;
              }
            } else {
              grid[y][x] = STONE;
            }
            temp[y][x] = 20;
          }
        }
      }

      // Add water/lava to caves
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.02) {
            const isLava = y > GRID_SIZE * 0.7 && Math.random() < 0.3;
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 50;

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = isLava ? LAVA : WATER;
                temp[cy][cx] = isLava ? 1200 : 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add oil deposits near bottom
      for (let y = Math.floor(GRID_SIZE * 0.8); y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.03) {
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 30;

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = OIL;
                temp[cy][cx] = 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add random birds near surface
      for (let y = 0; y < surfaceLevel; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === EMPTY && Math.random() < 0.01) {
            grid[y][x] = BIRD;
            temp[y][x] = 20;
          }
        }
      }
    };
  </script>
</body>
</html>